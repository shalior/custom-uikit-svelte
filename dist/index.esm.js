import UIkit from 'uikit';
import { writable, readable, derived } from 'svelte/store';
import { SvelteComponent, init, safe_not_equal, create_slot, element, space, attr, toggle_class, insert, append, listen, stop_propagation, update_slot_base, get_all_dirty_from_scope, get_slot_changes, transition_in, transition_out, detach, run_all, bubble, binding_callbacks, noop as noop$1, group_outros, check_outros, component_subscribe, empty, create_component, mount_component, destroy_component, null_to_empty, text, set_data, set_input_value, ensure_array_like, destroy_each, add_render_callback, set_style, add_iframe_resize_listener, update_keyed_each, destroy_block, globals, prevent_default, bind, add_flush_callback, outro_and_destroy_block, construct_svelte_component, get_spread_update, get_spread_object, assign, src_url_equal, HtmlTag, fix_and_outro_and_destroy_block, fix_position, create_animation, create_in_transition, is_function, to_number } from 'svelte/internal';
import 'svelte/internal/disclose-version';
import { getContext, createEventDispatcher, onMount, setContext, onDestroy, tick } from 'svelte';
import { debounce } from 'debounce';
import { cubicInOut } from 'svelte/easing';
import { fly } from 'svelte/transition';
import leven from 'leven';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var uikitIcons = createCommonjsModule(function (module, exports) {
/*! UIkit 3.21.12 | https://www.getuikit.com | (c) 2014 - 2024 YOOtheme | MIT License */

(function (global, factory) {
    module.exports = factory() ;
})(commonjsGlobal, (function () {
    function plugin(UIkit) {
      if (plugin.installed) {
        return;
      }
      UIkit.icon.add({
        "youtube": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M15,4.1c1,0.1,2.3,0,3,0.8c0.8,0.8,0.9,2.1,0.9,3.1C19,9.2,19,10.9,19,12c-0.1,1.1,0,2.4-0.5,3.4c-0.5,1.1-1.4,1.5-2.5,1.6 c-1.2,0.1-8.6,0.1-11,0c-1.1-0.1-2.4-0.1-3.2-1c-0.7-0.8-0.7-2-0.8-3C1,11.8,1,10.1,1,8.9c0-1.1,0-2.4,0.5-3.4C2,4.5,3,4.3,4.1,4.2 C5.3,4.1,12.6,4,15,4.1z M8,7.5v6l5.5-3L8,7.5z"/></svg>',
        "yootheme": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m16.15,5.48c-1.37,0-2.45.61-3.11,1.54-.66-.93-1.74-1.54-3.11-1.54-1.75,0-3.03,1-3.57,2.41v-2.22h-2.01v4.45c0,.85-.31,1.35-1.18,1.35s-1.18-.5-1.18-1.35v-4.45H0v4.86c0,.7.17,1.33.53,1.82.34.49.88.85,1.6,1v3.16h2.1v-3.16c1.28-.28,1.96-1.17,2.1-2.35.52,1.44,1.81,2.48,3.59,2.48,1.37,0,2.45-.61,3.11-1.54.66.93,1.74,1.54,3.11,1.54,2.37,0,3.85-1.82,3.85-4s-1.49-4-3.85-4Zm-6.22,5.99c-1.11,0-1.85-.72-1.85-1.99s.74-1.99,1.85-1.99,1.85.72,1.85,1.99-.74,1.99-1.85,1.99Zm6.22,0c-1.11,0-1.85-.72-1.85-1.99s.74-1.99,1.85-1.99,1.85.72,1.85,1.99-.74,1.99-1.85,1.99Z"/></svg>',
        "yelp": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.175,14.971c-0.112,0.77-1.686,2.767-2.406,3.054c-0.246,0.1-0.487,0.076-0.675-0.069	c-0.122-0.096-2.446-3.859-2.446-3.859c-0.194-0.293-0.157-0.682,0.083-0.978c0.234-0.284,0.581-0.393,0.881-0.276	c0.016,0.01,4.21,1.394,4.332,1.482c0.178,0.148,0.263,0.379,0.225,0.646L17.175,14.971L17.175,14.971z M11.464,10.789	c-0.203-0.307-0.199-0.666,0.009-0.916c0,0,2.625-3.574,2.745-3.657c0.203-0.135,0.452-0.141,0.69-0.025	c0.691,0.335,2.085,2.405,2.167,3.199v0.027c0.024,0.271-0.082,0.491-0.273,0.623c-0.132,0.083-4.43,1.155-4.43,1.155	c-0.322,0.096-0.68-0.06-0.882-0.381L11.464,10.789z M9.475,9.563C9.32,9.609,8.848,9.757,8.269,8.817c0,0-3.916-6.16-4.007-6.351	c-0.057-0.212,0.011-0.455,0.202-0.65C5.047,1.211,8.21,0.327,9.037,0.529c0.27,0.069,0.457,0.238,0.522,0.479	c0.047,0.266,0.433,5.982,0.488,7.264C10.098,9.368,9.629,9.517,9.475,9.563z M9.927,19.066c-0.083,0.225-0.273,0.373-0.54,0.421	c-0.762,0.13-3.15-0.751-3.647-1.342c-0.096-0.131-0.155-0.262-0.167-0.394c-0.011-0.095,0-0.189,0.036-0.272	c0.061-0.155,2.917-3.538,2.917-3.538c0.214-0.272,0.595-0.355,0.952-0.213c0.345,0.13,0.56,0.428,0.536,0.749	C10.014,14.479,9.977,18.923,9.927,19.066z M3.495,13.912c-0.235-0.009-0.444-0.148-0.568-0.382c-0.089-0.17-0.151-0.453-0.19-0.794	C2.63,11.701,2.761,10.144,3.07,9.648c0.145-0.226,0.357-0.345,0.592-0.336c0.154,0,4.255,1.667,4.255,1.667	c0.321,0.118,0.521,0.453,0.5,0.833c-0.023,0.37-0.236,0.655-0.551,0.738L3.495,13.912z"/></svg>',
        "xing": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M4.4,4.56 C4.24,4.56 4.11,4.61 4.05,4.72 C3.98,4.83 3.99,4.97 4.07,5.12 L5.82,8.16 L5.82,8.17 L3.06,13.04 C2.99,13.18 2.99,13.33 3.06,13.44 C3.12,13.55 3.24,13.62 3.4,13.62 L6,13.62 C6.39,13.62 6.57,13.36 6.71,13.12 C6.71,13.12 9.41,8.35 9.51,8.16 C9.49,8.14 7.72,5.04 7.72,5.04 C7.58,4.81 7.39,4.56 6.99,4.56 L4.4,4.56 L4.4,4.56 Z"/><path d="M15.3,1 C14.91,1 14.74,1.25 14.6,1.5 C14.6,1.5 9.01,11.42 8.82,11.74 C8.83,11.76 12.51,18.51 12.51,18.51 C12.64,18.74 12.84,19 13.23,19 L15.82,19 C15.98,19 16.1,18.94 16.16,18.83 C16.23,18.72 16.23,18.57 16.16,18.43 L12.5,11.74 L12.5,11.72 L18.25,1.56 C18.32,1.42 18.32,1.27 18.25,1.16 C18.21,1.06 18.08,1 17.93,1 L15.3,1 L15.3,1 Z"/></svg>',
        "x": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m15.08,2.1h2.68l-5.89,6.71,6.88,9.1h-5.4l-4.23-5.53-4.84,5.53H1.59l6.24-7.18L1.24,2.1h5.54l3.82,5.05,4.48-5.05Zm-.94,14.23h1.48L6,3.61h-1.6l9.73,12.71h0Z"/></svg>',
        "world": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M1,10.5 L19,10.5"/><path fill="none" stroke="#000" d="M2.35,15.5 L17.65,15.5"/><path fill="none" stroke="#000" d="M2.35,5.5 L17.523,5.5"/><path fill="none" stroke="#000" d="M10,19.46 L9.98,19.46 C7.31,17.33 5.61,14.141 5.61,10.58 C5.61,7.02 7.33,3.83 10,1.7 C10.01,1.7 9.99,1.7 10,1.7 L10,1.7 C12.67,3.83 14.4,7.02 14.4,10.58 C14.4,14.141 12.67,17.33 10,19.46 L10,19.46 L10,19.46 L10,19.46 Z"/><circle fill="none" stroke="#000" cx="10" cy="10.5" r="9"/></svg>',
        "wordpress": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10,0.5c-5.2,0-9.5,4.3-9.5,9.5s4.3,9.5,9.5,9.5c5.2,0,9.5-4.3,9.5-9.5S15.2,0.5,10,0.5L10,0.5L10,0.5z M15.6,3.9h-0.1 c-0.8,0-1.4,0.7-1.4,1.5c0,0.7,0.4,1.3,0.8,1.9c0.3,0.6,0.7,1.3,0.7,2.3c0,0.7-0.3,1.5-0.6,2.7L14.1,15l-3-8.9 c0.5,0,0.9-0.1,0.9-0.1C12.5,6,12.5,5.3,12,5.4c0,0-1.3,0.1-2.2,0.1C9,5.5,7.7,5.4,7.7,5.4C7.2,5.3,7.2,6,7.6,6c0,0,0.4,0.1,0.9,0.1 l1.3,3.5L8,15L5,6.1C5.5,6.1,5.9,6,5.9,6C6.4,6,6.3,5.3,5.9,5.4c0,0-1.3,0.1-2.2,0.1c-0.2,0-0.3,0-0.5,0c1.5-2.2,4-3.7,6.9-3.7 C12.2,1.7,14.1,2.6,15.6,3.9L15.6,3.9L15.6,3.9z M2.5,6.6l3.9,10.8c-2.7-1.3-4.6-4.2-4.6-7.4C1.8,8.8,2,7.6,2.5,6.6L2.5,6.6L2.5,6.6 z M10.2,10.7l2.5,6.9c0,0,0,0.1,0.1,0.1C11.9,18,11,18.2,10,18.2c-0.8,0-1.6-0.1-2.3-0.3L10.2,10.7L10.2,10.7L10.2,10.7z M14.2,17.1 l2.5-7.3c0.5-1.2,0.6-2.1,0.6-2.9c0-0.3,0-0.6-0.1-0.8c0.6,1.2,1,2.5,1,4C18.3,13,16.6,15.7,14.2,17.1L14.2,17.1L14.2,17.1z"/></svg>',
        "whatsapp": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M16.7,3.3c-1.8-1.8-4.1-2.8-6.7-2.8c-5.2,0-9.4,4.2-9.4,9.4c0,1.7,0.4,3.3,1.3,4.7l-1.3,4.9l5-1.3c1.4,0.8,2.9,1.2,4.5,1.2 l0,0l0,0c5.2,0,9.4-4.2,9.4-9.4C19.5,7.4,18.5,5,16.7,3.3 M10.1,17.7L10.1,17.7c-1.4,0-2.8-0.4-4-1.1l-0.3-0.2l-3,0.8l0.8-2.9 l-0.2-0.3c-0.8-1.2-1.2-2.7-1.2-4.2c0-4.3,3.5-7.8,7.8-7.8c2.1,0,4.1,0.8,5.5,2.3c1.5,1.5,2.3,3.4,2.3,5.5 C17.9,14.2,14.4,17.7,10.1,17.7 M14.4,11.9c-0.2-0.1-1.4-0.7-1.6-0.8c-0.2-0.1-0.4-0.1-0.5,0.1c-0.2,0.2-0.6,0.8-0.8,0.9 c-0.1,0.2-0.3,0.2-0.5,0.1c-0.2-0.1-1-0.4-1.9-1.2c-0.7-0.6-1.2-1.4-1.3-1.6c-0.1-0.2,0-0.4,0.1-0.5C8,8.8,8.1,8.7,8.2,8.5 c0.1-0.1,0.2-0.2,0.2-0.4c0.1-0.2,0-0.3,0-0.4C8.4,7.6,7.9,6.5,7.7,6C7.5,5.5,7.3,5.6,7.2,5.6c-0.1,0-0.3,0-0.4,0 c-0.2,0-0.4,0.1-0.6,0.3c-0.2,0.2-0.8,0.8-0.8,2c0,1.2,0.8,2.3,1,2.4c0.1,0.2,1.7,2.5,4,3.5c0.6,0.2,1,0.4,1.3,0.5 c0.6,0.2,1.1,0.2,1.5,0.1c0.5-0.1,1.4-0.6,1.6-1.1c0.2-0.5,0.2-1,0.1-1.1C14.8,12.1,14.6,12,14.4,11.9"/></svg>',
        "warning": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="10" cy="14" r="1"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><path d="M10.97,7.72 C10.85,9.54 10.56,11.29 10.56,11.29 C10.51,11.87 10.27,12 9.99,12 C9.69,12 9.49,11.87 9.43,11.29 C9.43,11.29 9.16,9.54 9.03,7.72 C8.96,6.54 9.03,6 9.03,6 C9.03,5.45 9.46,5.02 9.99,5 C10.53,5.01 10.97,5.44 10.97,6 C10.97,6 11.04,6.54 10.97,7.72 L10.97,7.72 Z"/></svg>',
        "vimeo": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M2.065,7.59C1.84,7.367,1.654,7.082,1.468,6.838c-0.332-0.42-0.137-0.411,0.274-0.772c1.026-0.91,2.004-1.896,3.127-2.688 c1.017-0.713,2.365-1.173,3.286-0.039c0.849,1.045,0.869,2.629,1.084,3.891c0.215,1.309,0.421,2.648,0.88,3.901 c0.127,0.352,0.37,1.018,0.81,1.074c0.567,0.078,1.145-0.917,1.408-1.289c0.684-0.987,1.611-2.317,1.494-3.587 c-0.115-1.349-1.572-1.095-2.482-0.773c0.146-1.514,1.555-3.216,2.912-3.792c1.439-0.597,3.579-0.587,4.302,1.036 c0.772,1.759,0.078,3.802-0.763,5.396c-0.918,1.731-2.1,3.333-3.363,4.829c-1.114,1.329-2.432,2.787-4.093,3.422 c-1.897,0.723-3.021-0.686-3.667-2.318c-0.705-1.777-1.056-3.771-1.565-5.621C4.898,8.726,4.644,7.836,4.136,7.191 C3.473,6.358,2.72,7.141,2.065,7.59C1.977,7.502,2.115,7.551,2.065,7.59L2.065,7.59z"/></svg>',
        "video-camera": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="19.5 5.9 19.5 14.1 14.5 10.4 14.5 15.5 .5 15.5 .5 4.5 14.5 4.5 14.5 9.6 19.5 5.9"/></svg>',
        "users": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="7.7" cy="8.6" r="3.5"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1,18.1 C1.7,14.6 4.4,12.1 7.6,12.1 C10.9,12.1 13.7,14.8 14.3,18.3"/><path fill="none" stroke="#000" stroke-width="1.1" d="M11.4,4 C12.8,2.4 15.4,2.8 16.3,4.7 C17.2,6.6 15.7,8.9 13.6,8.9 C16.5,8.9 18.8,11.3 19.2,14.1"/></svg>',
        "user": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9.9" cy="6.4" r="4.4"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1.5,19 C2.3,14.5 5.8,11.2 10,11.2 C14.2,11.2 17.7,14.6 18.5,19.2"/></svg>',
        "upload": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="5 8 9.5 3.5 14 8"/><rect width="13" height="1" x="3" y="17"/><line fill="none" stroke="#000" x1="9.5" y1="15" x2="9.5" y2="4"/></svg>',
        "unlock": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="13" height="10" fill="none" stroke="#000" x="3.5" y="8.5"/><path fill="none" stroke="#000" d="M6.5,8.5 L6.5,4.9 C6.5,3 8.1,1.5 10,1.5 C11.9,1.5 13.5,3 13.5,4.9"/></svg>',
        "uikit": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="14.4,3.1 11.3,5.1 15,7.3 15,12.9 10,15.7 5,12.9 5,8.5 2,6.8 2,14.8 9.9,19.5 18,14.8 18,5.3"/><polygon points="9.8,4.2 6.7,2.4 9.8,0.4 12.9,2.3"/></svg>',
        "twitter": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M19,4.74 C18.339,5.029 17.626,5.229 16.881,5.32 C17.644,4.86 18.227,4.139 18.503,3.28 C17.79,3.7 17.001,4.009 16.159,4.17 C15.485,3.45 14.526,3 13.464,3 C11.423,3 9.771,4.66 9.771,6.7 C9.771,6.99 9.804,7.269 9.868,7.539 C6.795,7.38 4.076,5.919 2.254,3.679 C1.936,4.219 1.754,4.86 1.754,5.539 C1.754,6.82 2.405,7.95 3.397,8.61 C2.79,8.589 2.22,8.429 1.723,8.149 L1.723,8.189 C1.723,9.978 2.997,11.478 4.686,11.82 C4.376,11.899 4.049,11.939 3.713,11.939 C3.475,11.939 3.245,11.919 3.018,11.88 C3.49,13.349 4.852,14.419 6.469,14.449 C5.205,15.429 3.612,16.019 1.882,16.019 C1.583,16.019 1.29,16.009 1,15.969 C2.635,17.019 4.576,17.629 6.662,17.629 C13.454,17.629 17.17,12 17.17,7.129 C17.17,6.969 17.166,6.809 17.157,6.649 C17.879,6.129 18.504,5.478 19,4.74"/></svg>',
        "twitch": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M5.23,1,2,4.23V15.85H5.88v3.23L9.1,15.85h2.59L17.5,10V1Zm11,8.4L13.62,12H11L8.78,14.24V12H5.88V2.29H16.21Z"/><rect width="1.29" height="3.88" x="12.98" y="4.55"/><rect width="1.29" height="3.88" x="9.43" y="4.55"/></svg>',
        "tv": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="6" height="1" x="7" y="16"/><rect width="19" height="11" fill="none" stroke="#000" x=".5" y="3.5"/></svg>',
        "tumblr": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M6.885,8.598c0,0,0,3.393,0,4.996c0,0.282,0,0.66,0.094,0.942c0.377,1.509,1.131,2.545,2.545,3.11 c1.319,0.472,2.356,0.472,3.676,0c0.565-0.188,1.132-0.659,1.132-0.659l-0.849-2.263c0,0-1.036,0.378-1.603,0.283 c-0.565-0.094-1.226-0.66-1.226-1.508c0-1.603,0-4.902,0-4.902h2.828V5.771h-2.828V2H8.205c0,0-0.094,0.66-0.188,0.942 C7.828,3.791,7.262,4.733,6.603,5.394C5.848,6.147,5,6.43,5,6.43v2.168H6.885z"/></svg>',
        "tripadvisor": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M19.021,7.866C19.256,6.862,20,5.854,20,5.854h-3.346C14.781,4.641,12.504,4,9.98,4C7.363,4,4.999,4.651,3.135,5.876H0	c0,0,0.738,0.987,0.976,1.988c-0.611,0.837-0.973,1.852-0.973,2.964c0,2.763,2.249,5.009,5.011,5.009	c1.576,0,2.976-0.737,3.901-1.879l1.063,1.599l1.075-1.615c0.475,0.611,1.1,1.111,1.838,1.451c1.213,0.547,2.574,0.612,3.825,0.15	c2.589-0.963,3.913-3.852,2.964-6.439c-0.175-0.463-0.4-0.876-0.675-1.238H19.021z M16.38,14.594	c-1.002,0.371-2.088,0.328-3.06-0.119c-0.688-0.317-1.252-0.817-1.657-1.438c-0.164-0.25-0.313-0.52-0.417-0.811	c-0.124-0.328-0.186-0.668-0.217-1.014c-0.063-0.689,0.037-1.396,0.339-2.043c0.448-0.971,1.251-1.71,2.25-2.079	c2.075-0.765,4.375,0.3,5.14,2.366c0.762,2.066-0.301,4.37-2.363,5.134L16.38,14.594L16.38,14.594z M8.322,13.066	c-0.72,1.059-1.935,1.76-3.309,1.76c-2.207,0-4.001-1.797-4.001-3.996c0-2.203,1.795-4.002,4.001-4.002	c2.204,0,3.999,1.8,3.999,4.002c0,0.137-0.024,0.261-0.04,0.396c-0.067,0.678-0.284,1.313-0.648,1.853v-0.013H8.322z M2.472,10.775	c0,1.367,1.112,2.479,2.476,2.479c1.363,0,2.472-1.11,2.472-2.479c0-1.359-1.11-2.468-2.472-2.468	C3.584,8.306,2.473,9.416,2.472,10.775L2.472,10.775z M12.514,10.775c0,1.367,1.104,2.479,2.471,2.479	c1.363,0,2.474-1.108,2.474-2.479c0-1.359-1.11-2.468-2.474-2.468c-1.364,0-2.477,1.109-2.477,2.468H12.514z M3.324,10.775	c0-0.893,0.726-1.618,1.614-1.618c0.889,0,1.625,0.727,1.625,1.618c0,0.898-0.725,1.627-1.625,1.627	c-0.901,0-1.625-0.729-1.625-1.627H3.324z M13.354,10.775c0-0.893,0.726-1.618,1.627-1.618c0.886,0,1.61,0.727,1.61,1.618	c0,0.898-0.726,1.627-1.626,1.627s-1.625-0.729-1.625-1.627H13.354z M9.977,4.875c1.798,0,3.425,0.324,4.849,0.968	c-0.535,0.015-1.061,0.108-1.586,0.3c-1.264,0.463-2.264,1.388-2.815,2.604c-0.262,0.551-0.398,1.133-0.448,1.72	C9.79,7.905,7.677,5.873,5.076,5.82C6.501,5.208,8.153,4.875,9.94,4.875H9.977z"/></svg>',
        "triangle-up": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="5 13 10 8 15 13"/></svg>',
        "triangle-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="8 5 13 10 8 15"/></svg>',
        "triangle-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="12 5 7 10 12 15"/></svg>',
        "triangle-down": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="5 7 15 7 10 12"/></svg>',
        "trash": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="6.5 3 6.5 1.5 13.5 1.5 13.5 3"/><polyline fill="none" stroke="#000" points="4.5 4 4.5 18.5 15.5 18.5 15.5 4"/><rect width="1" height="9" x="8" y="7"/><rect width="1" height="9" x="11" y="7"/><rect width="16" height="1" x="2" y="3"/></svg>',
        "tiktok": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.24,6V8.82a6.79,6.79,0,0,1-4-1.28v5.81A5.26,5.26,0,1,1,8,8.1a4.36,4.36,0,0,1,.72.05v2.9A2.57,2.57,0,0,0,7.64,11a2.4,2.4,0,1,0,2.77,2.38V2h2.86a4,4,0,0,0,1.84,3.38A4,4,0,0,0,17.24,6Z"/></svg>',
        "thumbnails": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="5" height="5" fill="none" stroke="#000" x="3.5" y="3.5"/><rect width="5" height="5" fill="none" stroke="#000" x="11.5" y="3.5"/><rect width="5" height="5" fill="none" stroke="#000" x="11.5" y="11.5"/><rect width="5" height="5" fill="none" stroke="#000" x="3.5" y="11.5"/></svg>',
        "threads": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m14.47,9.29c-.08-.04-.16-.08-.25-.11-.14-2.66-1.6-4.18-4.04-4.2-.01,0-.02,0-.03,0-1.46,0-2.67.62-3.42,1.76l1.34.92c.56-.85,1.43-1.03,2.08-1.03,0,0,.01,0,.02,0,.8,0,1.41.24,1.8.69.29.33.48.79.57,1.37-.71-.12-1.48-.16-2.31-.11-2.32.13-3.81,1.49-3.71,3.37.05.95.53,1.77,1.34,2.31.69.45,1.57.67,2.49.62,1.21-.07,2.16-.53,2.83-1.38.5-.64.82-1.48.96-2.52.58.35,1.01.81,1.24,1.36.4.94.43,2.48-.83,3.74-1.1,1.1-2.43,1.58-4.43,1.59-2.22-.02-3.9-.73-4.99-2.12-1.02-1.3-1.55-3.18-1.57-5.58.02-2.4.55-4.28,1.57-5.58,1.09-1.39,2.77-2.1,4.99-2.12,2.24.02,3.95.73,5.08,2.13.56.68.98,1.54,1.25,2.55l1.57-.42c-.33-1.23-.86-2.3-1.58-3.18-1.45-1.79-3.58-2.7-6.32-2.72h-.01c-2.73.02-4.84.94-6.25,2.73-1.26,1.6-1.9,3.82-1.93,6.61h0s0,.01,0,.01c.02,2.79.67,5.01,1.93,6.61,1.41,1.8,3.51,2.71,6.25,2.73h.01c2.43-.02,4.14-.65,5.55-2.06,1.85-1.84,1.79-4.16,1.18-5.58-.44-1.02-1.27-1.84-2.41-2.39Zm-4.2,3.95c-1.02.06-2.07-.4-2.12-1.38-.04-.72.52-1.53,2.19-1.63.19-.01.38-.02.56-.02.61,0,1.17.06,1.69.17-.19,2.41-1.32,2.8-2.32,2.85Z"/></svg>',
        "telegram": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m10,1.09C5.08,1.09,1.09,5.08,1.09,10s3.99,8.91,8.91,8.91,8.91-3.99,8.91-8.91S14.92,1.09,10,1.09Zm4.25,5.8c-.03.36-.23,1.62-.44,2.99-.31,1.93-.64,4.04-.64,4.04,0,0-.05.59-.49.7s-1.16-.36-1.29-.46c-.1-.08-1.93-1.24-2.6-1.8-.18-.15-.39-.46.03-.82.93-.85,2.04-1.91,2.7-2.58.31-.31.62-1.03-.67-.15-1.83,1.26-3.63,2.45-3.63,2.45,0,0-.41.26-1.19.03-.77-.23-1.67-.54-1.67-.54,0,0-.62-.39.44-.8h0s4.46-1.83,6-2.47c.59-.26,2.6-1.08,2.6-1.08,0,0,.93-.36.85.52Z"/></svg>',
        "tag": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M17.5,3.71 L17.5,7.72 C17.5,7.96 17.4,8.2 17.21,8.39 L8.39,17.2 C7.99,17.6 7.33,17.6 6.93,17.2 L2.8,13.07 C2.4,12.67 2.4,12.01 2.8,11.61 L11.61,2.8 C11.81,2.6 12.08,2.5 12.34,2.5 L16.19,2.5 C16.52,2.5 16.86,2.63 17.11,2.88 C17.35,3.11 17.48,3.4 17.5,3.71 L17.5,3.71 Z"/><circle cx="14" cy="6" r="1"/></svg>',
        "tablet": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M5,18.5 C4.2,18.5 3.5,17.8 3.5,17 L3.5,3 C3.5,2.2 4.2,1.5 5,1.5 L16,1.5 C16.8,1.5 17.5,2.2 17.5,3 L17.5,17 C17.5,17.8 16.8,18.5 16,18.5 L5,18.5 L5,18.5 L5,18.5 Z"/><circle cx="10.5" cy="16.3" r=".8"/></svg>',
        "tablet-landscape": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M1.5,5 C1.5,4.2 2.2,3.5 3,3.5 L17,3.5 C17.8,3.5 18.5,4.2 18.5,5 L18.5,16 C18.5,16.8 17.8,17.5 17,17.5 L3,17.5 C2.2,17.5 1.5,16.8 1.5,16 L1.5,5 L1.5,5 L1.5,5 Z"/><circle cx="3.7" cy="10.5" r=".8"/></svg>',
        "table": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="18" height="1" x="1" y="3"/><rect width="18" height="1" x="1" y="7"/><rect width="18" height="1" x="1" y="11"/><rect width="18" height="1" x="1" y="15"/></svg>',
        "strikethrough": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M6,13.02 L6.65,13.02 C7.64,15.16 8.86,16.12 10.41,16.12 C12.22,16.12 12.92,14.93 12.92,13.89 C12.92,12.55 11.99,12.03 9.74,11.23 C8.05,10.64 6.23,10.11 6.23,7.83 C6.23,5.5 8.09,4.09 10.4,4.09 C11.44,4.09 12.13,4.31 12.72,4.54 L13.33,4 L13.81,4 L13.81,7.59 L13.16,7.59 C12.55,5.88 11.52,4.89 10.07,4.89 C8.84,4.89 7.89,5.69 7.89,7.03 C7.89,8.29 8.89,8.78 10.88,9.45 C12.57,10.03 14.38,10.6 14.38,12.91 C14.38,14.75 13.27,16.93 10.18,16.93 C9.18,16.93 8.17,16.69 7.46,16.39 L6.52,17 L6,17 L6,13.02 L6,13.02 Z"/><rect width="15" height="1" x="3" y="10"/></svg>',
        "star": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" stroke-width="1.01" points="10 2 12.63 7.27 18.5 8.12 14.25 12.22 15.25 18 10 15.27 4.75 18 5.75 12.22 1.5 8.12 7.37 7.27"/></svg>',
        "soundcloud": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.2,9.4c-0.4,0-0.8,0.1-1.101,0.2c-0.199-2.5-2.399-4.5-5-4.5c-0.6,0-1.2,0.1-1.7,0.3C9.2,5.5,9.1,5.6,9.1,5.6V15h8 c1.601,0,2.801-1.2,2.801-2.8C20,10.7,18.7,9.4,17.2,9.4L17.2,9.4z"/><rect width="1.5" height="8.5" x="6" y="6.5"/><rect width="1.5" height="7" x="3" y="8"/><rect width="1.5" height="5" y="10"/></svg>',
        "social": '<svg width="20" height="20" viewBox="0 0 20 20"><line fill="none" stroke="#000" stroke-width="1.1" x1="13.4" y1="14" x2="6.3" y2="10.7"/><line fill="none" stroke="#000" stroke-width="1.1" x1="13.5" y1="5.5" x2="6.5" y2="8.8"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="15.5" cy="4.6" r="2.3"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="15.5" cy="14.8" r="2.3"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="4.5" cy="9.8" r="2.3"/></svg>',
        "signal": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m7.86,1.34l.2.81c-.79.19-1.54.51-2.24.93l-.43-.71c.77-.46,1.6-.81,2.47-1.02Zm4.28,0l-.2.81c.79.19,1.54.51,2.24.93l.43-.72c-.77-.46-1.6-.81-2.47-1.02h0ZM2.37,5.39c-.46.77-.81,1.6-1.02,2.47l.81.2c.19-.79.51-1.54.93-2.24l-.71-.43Zm-.45,4.61c0-.41.03-.81.09-1.21l-.83-.13c-.13.89-.13,1.79,0,2.67l.83-.13c-.06-.4-.09-.81-.09-1.21h0Zm12.69,7.63l-.43-.72c-.7.42-1.45.73-2.24.93l.2.81c.87-.21,1.7-.56,2.46-1.02h0Zm3.47-7.63c0,.41-.03.81-.09,1.21l.83.13c.13-.89.13-1.79,0-2.67l-.83.13c.06.4.09.81.09,1.21Zm.58,2.14l-.81-.2c-.19.79-.51,1.54-.93,2.24l.72.43c.46-.77.81-1.6,1.02-2.47h0Zm-7.44,5.85c-.8.12-1.62.12-2.42,0l-.13.83c.89.13,1.79.13,2.67,0l-.13-.83Zm5.29-3.2c-.48.65-1.06,1.23-1.71,1.71l.5.67c.72-.53,1.36-1.16,1.89-1.88l-.67-.5Zm-1.71-11.29c.65.48,1.23,1.06,1.71,1.71l.67-.5c-.53-.72-1.17-1.35-1.88-1.88l-.5.67Zm-11.29,1.71c.48-.65,1.06-1.23,1.71-1.71l-.5-.67c-.72.53-1.35,1.17-1.88,1.88l.67.5Zm14.14.18l-.72.43c.42.7.73,1.45.93,2.24l.81-.2c-.21-.87-.56-1.7-1.02-2.46h0Zm-8.84-3.38c.8-.12,1.62-.12,2.42,0l.13-.83c-.89-.13-1.79-.13-2.67,0l.13.83Zm-4.86,15.38l-1.73.4.4-1.73-.81-.19-.4,1.73c-.07.28.02.58.22.78s.5.29.78.22l1.73-.39-.19-.82Zm-1.96-2.26l.81.19.28-1.2c-.41-.68-.71-1.42-.9-2.19l-.81.2c.18.74.46,1.45.82,2.12l-.2.88Zm3.9,1.81l-1.19.28.19.81.88-.2c.67.36,1.38.64,2.12.82l.2-.81c-.77-.19-1.51-.5-2.19-.9h0ZM10,2.75c-2.63,0-5.06,1.43-6.34,3.74s-1.19,5.12.21,7.36l-.7,2.97,2.97-.7c2.61,1.64,5.96,1.46,8.37-.46s3.34-5.15,2.32-8.06c-1.02-2.91-3.77-4.85-6.85-4.85Z"/></svg>',
        "sign-out": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="13.1 13.4 12.5 12.8 15.28 10 8 10 8 9 15.28 9 12.5 6.2 13.1 5.62 17 9.5"/><polygon points="13 2 3 2 3 17 13 17 13 16 4 16 4 3 13 3"/></svg>',
        "sign-in": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="7 2 17 2 17 17 7 17 7 16 16 16 16 3 7 3"/><polygon points="9.1 13.4 8.5 12.8 11.28 10 4 10 4 9 11.28 9 8.5 6.2 9.1 5.62 13 9.5"/></svg>',
        "shrink": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="11 4 12 4 12 8 16 8 16 9 11 9"/><polygon points="4 11 9 11 9 16 8 16 8 12 4 12"/><path fill="none" stroke="#000" stroke-width="1.1" d="M12,8 L18,2"/><path fill="none" stroke="#000" stroke-width="1.1" d="M2,18 L8,12"/></svg>',
        "settings": '<svg width="20" height="20" viewBox="0 0 20 20"><ellipse fill="none" stroke="#000" cx="6.11" cy="3.55" rx="2.11" ry="2.15"/><ellipse fill="none" stroke="#000" cx="6.11" cy="15.55" rx="2.11" ry="2.15"/><circle fill="none" stroke="#000" cx="13.15" cy="9.55" r="2.15"/><rect width="3" height="1" x="1" y="3"/><rect width="8" height="1" x="10" y="3"/><rect width="8" height="1" x="1" y="9"/><rect width="3" height="1" x="15" y="9"/><rect width="3" height="1" x="1" y="15"/><rect width="8" height="1" x="10" y="15"/></svg>',
        "server": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="1" height="2" x="3" y="3"/><rect width="1" height="2" x="5" y="3"/><rect width="1" height="2" x="7" y="3"/><rect width="1" height="1" x="16" y="3"/><rect width="1" height="1" x="16" y="10"/><circle fill="none" stroke="#000" cx="9.9" cy="17.4" r="1.4"/><rect width="1" height="2" x="3" y="10"/><rect width="1" height="2" x="5" y="10"/><rect width="1" height="2" x="9.5" y="14"/><rect width="6" height="1" x="3" y="17"/><rect width="6" height="1" x="11" y="17"/><rect width="17" height="5" fill="none" stroke="#000" x="1.5" y="1.5"/><rect width="17" height="5" fill="none" stroke="#000" x="1.5" y="8.5"/></svg>',
        "search": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9" cy="9" r="7"/><path fill="none" stroke="#000" stroke-width="1.1" d="M14,14 L18,18 L14,14 Z"/></svg>',
        "rss": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="3.12" cy="16.8" r="1.85"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1.5,8.2 C1.78,8.18 2.06,8.16 2.35,8.16 C7.57,8.16 11.81,12.37 11.81,17.57 C11.81,17.89 11.79,18.19 11.76,18.5"/><path fill="none" stroke="#000" stroke-width="1.1" d="M1.5,2.52 C1.78,2.51 2.06,2.5 2.35,2.5 C10.72,2.5 17.5,9.24 17.5,17.57 C17.5,17.89 17.49,18.19 17.47,18.5"/></svg>',
        "reply": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.7,13.11 C16.12,10.02 13.84,7.85 11.02,6.61 C10.57,6.41 9.75,6.13 9,5.91 L9,2 L1,9 L9,16 L9,12.13 C10.78,12.47 12.5,13.19 14.09,14.25 C17.13,16.28 18.56,18.54 18.56,18.54 C18.56,18.54 18.81,15.28 17.7,13.11 L17.7,13.11 Z M14.82,13.53 C13.17,12.4 11.01,11.4 8,10.92 L8,13.63 L2.55,9 L8,4.25 L8,6.8 C8.3,6.86 9.16,7.02 10.37,7.49 C13.3,8.65 15.54,10.96 16.65,13.08 C16.97,13.7 17.48,14.86 17.68,16 C16.87,15.05 15.73,14.15 14.82,13.53 L14.82,13.53 Z"/></svg>',
        "refresh": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M17.08,11.15 C17.09,11.31 17.1,11.47 17.1,11.64 C17.1,15.53 13.94,18.69 10.05,18.69 C6.16,18.68 3,15.53 3,11.63 C3,7.74 6.16,4.58 10.05,4.58 C10.9,4.58 11.71,4.73 12.46,5"/><polyline fill="none" stroke="#000" points="9.9 2 12.79 4.89 9.79 7.9"/></svg>',
        "reddit": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M19 9.05a2.56 2.56 0 0 0-2.56-2.56 2.59 2.59 0 0 0-1.88.82 10.63 10.63 0 0 0-4.14-1v-.08c.58-1.62 1.58-3.89 2.7-4.1.38-.08.77.12 1.19.57a1.15 1.15 0 0 0-.06.37 1.48 1.48 0 1 0 1.51-1.45 1.43 1.43 0 0 0-.76.19A2.29 2.29 0 0 0 12.91 1c-2.11.43-3.39 4.38-3.63 5.19 0 0 0 .11-.06.11a10.65 10.65 0 0 0-3.75 1A2.56 2.56 0 0 0 1 9.05a2.42 2.42 0 0 0 .72 1.76A5.18 5.18 0 0 0 1.24 13c0 3.66 3.92 6.64 8.73 6.64s8.74-3 8.74-6.64a5.23 5.23 0 0 0-.46-2.13A2.58 2.58 0 0 0 19 9.05zm-16.88 0a1.44 1.44 0 0 1 2.27-1.19 7.68 7.68 0 0 0-2.07 1.91 1.33 1.33 0 0 1-.2-.72zM10 18.4c-4.17 0-7.55-2.4-7.55-5.4S5.83 7.53 10 7.53 17.5 10 17.5 13s-3.38 5.4-7.5 5.4zm7.69-8.61a7.62 7.62 0 0 0-2.09-1.91 1.41 1.41 0 0 1 .84-.28 1.47 1.47 0 0 1 1.44 1.45 1.34 1.34 0 0 1-.21.72z"/><path d="M6.69 12.58a1.39 1.39 0 1 1 1.39-1.39 1.38 1.38 0 0 1-1.38 1.39z"/><path d="M14.26 11.2a1.39 1.39 0 1 1-1.39-1.39 1.39 1.39 0 0 1 1.39 1.39z"/><path d="M13.09 14.88a.54.54 0 0 1-.09.77 5.3 5.3 0 0 1-3.26 1.19 5.61 5.61 0 0 1-3.4-1.22.55.55 0 1 1 .73-.83 4.09 4.09 0 0 0 5.25 0 .56.56 0 0 1 .77.09z"/></svg>',
        "receiver": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.01" d="M6.189,13.611C8.134,15.525 11.097,18.239 13.867,18.257C16.47,18.275 18.2,16.241 18.2,16.241L14.509,12.551L11.539,13.639L6.189,8.29L7.313,5.355L3.76,1.8C3.76,1.8 1.732,3.537 1.7,6.092C1.667,8.809 4.347,11.738 6.189,13.611"/></svg>',
        "quote-right": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.27,7.79 C17.27,9.45 16.97,10.43 15.99,12.02 C14.98,13.64 13,15.23 11.56,15.97 L11.1,15.08 C12.34,14.2 13.14,13.51 14.02,11.82 C14.27,11.34 14.41,10.92 14.49,10.54 C14.3,10.58 14.09,10.6 13.88,10.6 C12.06,10.6 10.59,9.12 10.59,7.3 C10.59,5.48 12.06,4 13.88,4 C15.39,4 16.67,5.02 17.05,6.42 C17.19,6.82 17.27,7.27 17.27,7.79 L17.27,7.79 Z"/><path d="M8.68,7.79 C8.68,9.45 8.38,10.43 7.4,12.02 C6.39,13.64 4.41,15.23 2.97,15.97 L2.51,15.08 C3.75,14.2 4.55,13.51 5.43,11.82 C5.68,11.34 5.82,10.92 5.9,10.54 C5.71,10.58 5.5,10.6 5.29,10.6 C3.47,10.6 2,9.12 2,7.3 C2,5.48 3.47,4 5.29,4 C6.8,4 8.08,5.02 8.46,6.42 C8.6,6.82 8.68,7.27 8.68,7.79 L8.68,7.79 Z"/></svg>',
        "question": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><circle cx="9.99" cy="14.24" r="1.05"/><path fill="none" stroke="#000" stroke-width="1.2" d="m7.72,7.61c0-3.04,4.55-3.06,4.55-.07,0,.95-.91,1.43-1.49,2.03-.48.49-.72.98-.78,1.65-.01.13-.02.24-.02.35"/></svg>',
        "push": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="12.15,4 9.5,1.4 6.85,4 6.15,3.3 9.5,0 12.85,3.3"/><line fill="none" stroke="#000" x1="9.5" y1="10" x2="9.5" y2="1"/><polyline fill="none" stroke="#000" points="6 5.5 3.5 5.5 3.5 18.5 15.5 18.5 15.5 5.5 13 5.5"/></svg>',
        "pull": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="6.85,8 9.5,10.6 12.15,8 12.85,8.7 9.5,12 6.15,8.7"/><line fill="none" stroke="#000" x1="9.5" y1="11" x2="9.5" y2="2"/><polyline fill="none" stroke="#000" points="6,5.5 3.5,5.5 3.5,18.5 15.5,18.5 15.5,5.5 13,5.5"/></svg>',
        "print": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="4.5 13.5 1.5 13.5 1.5 6.5 18.5 6.5 18.5 13.5 15.5 13.5"/><polyline fill="none" stroke="#000" points="15.5 6.5 15.5 2.5 4.5 2.5 4.5 6.5"/><rect width="11" height="6" fill="none" stroke="#000" x="4.5" y="11.5"/><rect width="8" height="1" x="6" y="13"/><rect width="8" height="1" x="6" y="15"/></svg>',
        "plus": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="1" height="17" x="9" y="1"/><rect width="17" height="1" x="1" y="9"/></svg>',
        "plus-circle": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9.5" cy="9.5" r="9"/><line fill="none" stroke="#000" x1="9.5" y1="5" x2="9.5" y2="14"/><line fill="none" stroke="#000" x1="5" y1="9.5" x2="14" y2="9.5"/></svg>',
        "play": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="6.5,5 14.5,10 6.5,15"/></svg>',
        "play-circle": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" stroke-width="1.1" points="8.5 7 13.5 10 8.5 13"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/></svg>',
        "pinterest": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10.21,1 C5.5,1 3,4.16 3,7.61 C3,9.21 3.85,11.2 5.22,11.84 C5.43,11.94 5.54,11.89 5.58,11.69 C5.62,11.54 5.8,10.8 5.88,10.45 C5.91,10.34 5.89,10.24 5.8,10.14 C5.36,9.59 5,8.58 5,7.65 C5,5.24 6.82,2.91 9.93,2.91 C12.61,2.91 14.49,4.74 14.49,7.35 C14.49,10.3 13,12.35 11.06,12.35 C9.99,12.35 9.19,11.47 9.44,10.38 C9.75,9.08 10.35,7.68 10.35,6.75 C10.35,5.91 9.9,5.21 8.97,5.21 C7.87,5.21 6.99,6.34 6.99,7.86 C6.99,8.83 7.32,9.48 7.32,9.48 C7.32,9.48 6.24,14.06 6.04,14.91 C5.7,16.35 6.08,18.7 6.12,18.9 C6.14,19.01 6.26,19.05 6.33,18.95 C6.44,18.81 7.74,16.85 8.11,15.44 C8.24,14.93 8.79,12.84 8.79,12.84 C9.15,13.52 10.19,14.09 11.29,14.09 C14.58,14.09 16.96,11.06 16.96,7.3 C16.94,3.7 14,1 10.21,1"/></svg>',
        "phone": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M15.5,17 C15.5,17.8 14.8,18.5 14,18.5 L7,18.5 C6.2,18.5 5.5,17.8 5.5,17 L5.5,3 C5.5,2.2 6.2,1.5 7,1.5 L14,1.5 C14.8,1.5 15.5,2.2 15.5,3 L15.5,17 L15.5,17 L15.5,17 Z"/><circle cx="10.5" cy="16.5" r=".8"/></svg>',
        "phone-landscape": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M17,5.5 C17.8,5.5 18.5,6.2 18.5,7 L18.5,14 C18.5,14.8 17.8,15.5 17,15.5 L3,15.5 C2.2,15.5 1.5,14.8 1.5,14 L1.5,7 C1.5,6.2 2.2,5.5 3,5.5 L17,5.5 L17,5.5 L17,5.5 Z"/><circle cx="3.8" cy="10.5" r=".8"/></svg>',
        "pencil": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M17.25,6.01 L7.12,16.1 L3.82,17.2 L5.02,13.9 L15.12,3.88 C15.71,3.29 16.66,3.29 17.25,3.88 C17.83,4.47 17.83,5.42 17.25,6.01 L17.25,6.01 Z"/><path fill="none" stroke="#000" d="M15.98,7.268 L13.851,5.148"/></svg>',
        "paint-bucket": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="m6.42,2.16l5.28,5.28"/><path d="m18.49,11.83s1.51,2.06,1.51,3.36c0,.92-.76,1.64-1.51,1.64h0c-.75,0-1.49-.72-1.49-1.64,0-1.3,1.49-3.36,1.49-3.36h0Z"/><line fill="none" stroke="#000" x1="1.26" y1="10.5" x2="16" y2="10.5"/><polygon fill="none" stroke="#000" stroke-width="1.1" points="10.2 1.55 17.6 8.93 8.08 18.45 .7 11.07 10.2 1.55"/></svg>',
        "nut": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="2.5,5.7 10,1.3 17.5,5.7 17.5,14.3 10,18.7 2.5,14.3"/><circle fill="none" stroke="#000" cx="10" cy="10" r="3.5"/></svg>',
        "move": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="4,5 1,5 1,9 2,9 2,6 4,6"/><polygon points="1,16 2,16 2,18 4,18 4,19 1,19"/><polygon points="14,16 14,19 11,19 11,18 13,18 13,16"/><rect width="13" height="13" fill="none" stroke="#000" x="5.5" y="1.5"/><rect width="1" height="3" x="1" y="11"/><rect width="3" height="1" x="6" y="18"/></svg>',
        "more": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="3" cy="10" r="2"/><circle cx="10" cy="10" r="2"/><circle cx="17" cy="10" r="2"/></svg>',
        "more-vertical": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="10" cy="3" r="2"/><circle cx="10" cy="10" r="2"/><circle cx="10" cy="17" r="2"/></svg>',
        "minus": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="18" height="1" x="1" y="9"/></svg>',
        "minus-circle": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="9.5" cy="9.5" r="9"/><line fill="none" stroke="#000" x1="5" y1="9.5" x2="14" y2="9.5"/></svg>',
        "microsoft": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m2,2h7.58v7.58H2V2Zm8.42,0h7.58v7.58h-7.58V2ZM2,10.42h7.58v7.58H2v-7.58Zm8.42,0h7.58v7.58h-7.58"/></svg>',
        "microphone": '<svg width="20" height="20" viewBox="0 0 20 20"><line fill="none" stroke="#000" x1="10" y1="16.44" x2="10" y2="18.5"/><line fill="none" stroke="#000" x1="7" y1="18.5" x2="13" y2="18.5"/><path fill="none" stroke="#000" stroke-width="1.1" d="M13.5 4.89v5.87a3.5 3.5 0 0 1-7 0V4.89a3.5 3.5 0 0 1 7 0z"/><path fill="none" stroke="#000" stroke-width="1.1" d="M15.5 10.36V11a5.5 5.5 0 0 1-11 0v-.6"/></svg>',
        "menu": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="16" height="1" x="2" y="4"/><rect width="16" height="1" x="2" y="9"/><rect width="16" height="1" x="2" y="14"/></svg>',
        "mastodon": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m18.5,6.87c0-3.95-2.59-5.11-2.59-5.11-1.31-.6-3.55-.85-5.88-.87h-.06c-2.33.02-4.57.27-5.88.87,0,0-2.59,1.16-2.59,5.11,0,.91-.02,1.99.01,3.14.09,3.87.71,7.68,4.28,8.62,1.65.44,3.06.53,4.2.47,2.07-.11,3.23-.74,3.23-.74l-.07-1.5s-1.48.47-3.14.41c-1.64-.06-3.38-.18-3.64-2.2-.02-.18-.04-.37-.04-.57,0,0,1.61.39,3.66.49,1.25.06,2.42-.07,3.61-.22,2.28-.27,4.27-1.68,4.52-2.97.39-2.02.36-4.94.36-4.94Zm-3.05,5.09h-1.9v-4.65c0-.98-.41-1.48-1.24-1.48-.91,0-1.37.59-1.37,1.76v2.54h-1.89v-2.54c0-1.17-.46-1.76-1.37-1.76-.82,0-1.24.5-1.24,1.48v4.65h-1.9v-4.79c0-.98.25-1.76.75-2.33.52-.58,1.19-.87,2.03-.87.97,0,1.71.37,2.19,1.12l.47.79.47-.79c.49-.75,1.22-1.12,2.19-1.12.84,0,1.51.29,2.03.87.5.58.75,1.35.75,2.33v4.79Z"/></svg>',
        "mail": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="1.4,6.5 10,11 18.6,6.5"/><path d="M 1,4 1,16 19,16 19,4 1,4 Z M 18,15 2,15 2,5 18,5 18,15 Z"/></svg>',
        "lock": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="13" height="10" fill="none" stroke="#000" x="3.5" y="8.5"/><path fill="none" stroke="#000" d="M6.5,8 L6.5,4.88 C6.5,3.01 8.07,1.5 10,1.5 C11.93,1.5 13.5,3.01 13.5,4.88 L13.5,8"/></svg>',
        "location": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.01" d="M10,0.5 C6.41,0.5 3.5,3.39 3.5,6.98 C3.5,11.83 10,19 10,19 C10,19 16.5,11.83 16.5,6.98 C16.5,3.39 13.59,0.5 10,0.5 L10,0.5 Z"/><circle fill="none" stroke="#000" cx="10" cy="6.8" r="2.3"/></svg>',
        "list": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="12" height="1" x="6" y="4"/><rect width="12" height="1" x="6" y="9"/><rect width="12" height="1" x="6" y="14"/><rect width="2" height="1" x="2" y="4"/><rect width="2" height="1" x="2" y="9"/><rect width="2" height="1" x="2" y="14"/></svg>',
        "linkedin": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M5.77,17.89 L5.77,7.17 L2.21,7.17 L2.21,17.89 L5.77,17.89 L5.77,17.89 Z M3.99,5.71 C5.23,5.71 6.01,4.89 6.01,3.86 C5.99,2.8 5.24,2 4.02,2 C2.8,2 2,2.8 2,3.85 C2,4.88 2.77,5.7 3.97,5.7 L3.99,5.7 L3.99,5.71 L3.99,5.71 Z"/><path d="M7.75,17.89 L11.31,17.89 L11.31,11.9 C11.31,11.58 11.33,11.26 11.43,11.03 C11.69,10.39 12.27,9.73 13.26,9.73 C14.55,9.73 15.06,10.71 15.06,12.15 L15.06,17.89 L18.62,17.89 L18.62,11.74 C18.62,8.45 16.86,6.92 14.52,6.92 C12.6,6.92 11.75,7.99 11.28,8.73 L11.3,8.73 L11.3,7.17 L7.75,7.17 C7.79,8.17 7.75,17.89 7.75,17.89 L7.75,17.89 L7.75,17.89 Z"/></svg>',
        "link": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M10.625,12.375 L7.525,15.475 C6.825,16.175 5.925,16.175 5.225,15.475 L4.525,14.775 C3.825,14.074 3.825,13.175 4.525,12.475 L7.625,9.375"/><path fill="none" stroke="#000" stroke-width="1.1" d="M9.325,7.375 L12.425,4.275 C13.125,3.575 14.025,3.575 14.724,4.275 L15.425,4.975 C16.125,5.675 16.125,6.575 15.425,7.275 L12.325,10.375"/><path fill="none" stroke="#000" stroke-width="1.1" d="M7.925,11.875 L11.925,7.975"/></svg>',
        "link-external": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="14.5 10.5 14.5 16.5 3.5 16.5 3.5 5.5 8.5 5.5"/><polyline fill="none" stroke="#000" points="17.5 8.5 17.5 2.5 11.5 2.5"/><line fill="none" stroke="#000" x1="6.5" y1="13.5" x2="17.5" y2="2.5"/></svg>',
        "lifesaver": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="10" cy="10" r="9"/><circle fill="none" stroke="#000" cx="10" cy="10" r="5"/><line fill="none" stroke="#000" stroke-width="1.1" x1="5.17" y1="2.39" x2="8.11" y2="5.33"/><line fill="none" stroke="#000" stroke-width="1.1" x1="5.33" y1="8.11" x2="2.39" y2="5.17"/><line fill="none" stroke="#000" stroke-width="1.1" x1="14.83" y1="17.61" x2="11.89" y2="14.67"/><line fill="none" stroke="#000" stroke-width="1.1" x1="14.67" y1="11.89" x2="17.61" y2="14.83"/><line fill="none" stroke="#000" stroke-width="1.1" x1="17.61" y1="5.17" x2="14.67" y2="8.11"/><line fill="none" stroke="#000" stroke-width="1.1" x1="11.89" y1="5.33" x2="14.83" y2="2.39"/><line fill="none" stroke="#000" stroke-width="1.1" x1="8.11" y1="14.67" x2="5.17" y2="17.61"/><line fill="none" stroke="#000" stroke-width="1.1" x1="2.39" y1="14.83" x2="5.33" y2="11.89"/></svg>',
        "laptop": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="20" height="1" y="16"/><rect width="15" height="10" fill="none" stroke="#000" x="2.5" y="4.5"/></svg>',
        "joomla": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M7.8,13.4l1.7-1.7L5.9,8c-0.6-0.5-0.6-1.5,0-2c0.6-0.6,1.4-0.6,2,0l1.7-1.7c-1-1-2.3-1.3-3.6-1C5.8,2.2,4.8,1.4,3.7,1.4 c-1.3,0-2.3,1-2.3,2.3c0,1.1,0.8,2,1.8,2.3c-0.4,1.3-0.1,2.8,1,3.8L7.8,13.4L7.8,13.4z"/><path d="M10.2,4.3c1-1,2.5-1.4,3.8-1c0.2-1.1,1.1-2,2.3-2c1.3,0,2.3,1,2.3,2.3c0,1.2-0.9,2.2-2,2.3c0.4,1.3,0,2.8-1,3.8L13.9,8 c0.6-0.5,0.6-1.5,0-2c-0.5-0.6-1.5-0.6-2,0L8.2,9.7L6.5,8"/><path d="M14.1,16.8c-1.3,0.4-2.8,0.1-3.8-1l1.7-1.7c0.6,0.6,1.5,0.6,2,0c0.5-0.6,0.6-1.5,0-2l-3.7-3.7L12,6.7l3.7,3.7 c1,1,1.3,2.4,1,3.6c1.1,0.2,2,1.1,2,2.3c0,1.3-1,2.3-2.3,2.3C15.2,18.6,14.3,17.8,14.1,16.8"/><path d="M13.2,12.2l-3.7,3.7c-1,1-2.4,1.3-3.6,1c-0.2,1-1.2,1.8-2.2,1.8c-1.3,0-2.3-1-2.3-2.3c0-1.1,0.8-2,1.8-2.3 c-0.3-1.3,0-2.7,1-3.7l1.7,1.7c-0.6,0.6-0.6,1.5,0,2c0.6,0.6,1.4,0.6,2,0l3.7-3.7"/></svg>',
        "italic": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M12.63,5.48 L10.15,14.52 C10,15.08 10.37,15.25 11.92,15.3 L11.72,16 L6,16 L6.2,15.31 C7.78,15.26 8.19,15.09 8.34,14.53 L10.82,5.49 C10.97,4.92 10.63,4.76 9.09,4.71 L9.28,4 L15,4 L14.81,4.69 C13.23,4.75 12.78,4.91 12.63,5.48 L12.63,5.48 Z"/></svg>',
        "instagram": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M13.55,1H6.46C3.45,1,1,3.44,1,6.44v7.12c0,3,2.45,5.44,5.46,5.44h7.08c3.02,0,5.46-2.44,5.46-5.44V6.44 C19.01,3.44,16.56,1,13.55,1z M17.5,14c0,1.93-1.57,3.5-3.5,3.5H6c-1.93,0-3.5-1.57-3.5-3.5V6c0-1.93,1.57-3.5,3.5-3.5h8 c1.93,0,3.5,1.57,3.5,3.5V14z"/><circle cx="14.87" cy="5.26" r="1.09"/><path d="M10.03,5.45c-2.55,0-4.63,2.06-4.63,4.6c0,2.55,2.07,4.61,4.63,4.61c2.56,0,4.63-2.061,4.63-4.61 C14.65,7.51,12.58,5.45,10.03,5.45L10.03,5.45L10.03,5.45z M10.08,13c-1.66,0-3-1.34-3-2.99c0-1.65,1.34-2.99,3-2.99s3,1.34,3,2.99 C13.08,11.66,11.74,13,10.08,13L10.08,13L10.08,13z"/></svg>',
        "info": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M12.13,11.59 C11.97,12.84 10.35,14.12 9.1,14.16 C6.17,14.2 9.89,9.46 8.74,8.37 C9.3,8.16 10.62,7.83 10.62,8.81 C10.62,9.63 10.12,10.55 9.88,11.32 C8.66,15.16 12.13,11.15 12.14,11.18 C12.16,11.21 12.16,11.35 12.13,11.59 C12.08,11.95 12.16,11.35 12.13,11.59 L12.13,11.59 Z M11.56,5.67 C11.56,6.67 9.36,7.15 9.36,6.03 C9.36,5 11.56,4.54 11.56,5.67 L11.56,5.67 Z"/><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/></svg>',
        "image": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="16.1" cy="6.1" r="1.1"/><rect width="19" height="15" fill="none" stroke="#000" x=".5" y="2.5"/><polyline fill="none" stroke="#000" stroke-width="1.01" points="4,13 8,9 13,14"/><polyline fill="none" stroke="#000" stroke-width="1.01" points="11,12 12.5,10.5 16,14"/></svg>',
        "home": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="18.65 11.35 10 2.71 1.35 11.35 0.65 10.65 10 1.29 19.35 10.65"/><polygon points="15 4 18 4 18 7 17 7 17 5 15 5"/><polygon points="3 11 4 11 4 18 7 18 7 12 12 12 12 18 16 18 16 11 17 11 17 19 11 19 11 13 8 13 8 19 3 19"/></svg>',
        "history": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="#000" points="1 2 2 2 2 6 6 6 6 7 1 7 1 2"/><path fill="none" stroke="#000" stroke-width="1.1" d="M2.1,6.548 C3.391,3.29 6.746,1 10.5,1 C15.5,1 19.5,5 19.5,10 C19.5,15 15.5,19 10.5,19 C5.5,19 1.5,15 1.5,10"/><rect width="1" height="7" x="9" y="4"/><path fill="none" stroke="#000" stroke-width="1.1" d="M13.018,14.197 L9.445,10.625"/></svg>',
        "heart": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.03" d="M10,4 C10,4 8.1,2 5.74,2 C3.38,2 1,3.55 1,6.73 C1,8.84 2.67,10.44 2.67,10.44 L10,18 L17.33,10.44 C17.33,10.44 19,8.84 19,6.73 C19,3.55 16.62,2 14.26,2 C11.9,2 10,4 10,4 L10,4 Z"/></svg>',
        "hashtag": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M15.431,8 L15.661,7 L12.911,7 L13.831,3 L12.901,3 L11.98,7 L9.29,7 L10.21,3 L9.281,3 L8.361,7 L5.23,7 L5,8 L8.13,8 L7.21,12 L4.23,12 L4,13 L6.98,13 L6.061,17 L6.991,17 L7.911,13 L10.601,13 L9.681,17 L10.611,17 L11.531,13 L14.431,13 L14.661,12 L11.76,12 L12.681,8 L15.431,8 Z M10.831,12 L8.141,12 L9.061,8 L11.75,8 L10.831,12 Z"/></svg>',
        "happy": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="13" cy="7" r="1"/><circle cx="7" cy="7" r="1"/><circle fill="none" stroke="#000" cx="10" cy="10" r="8.5"/><path fill="none" stroke="#000" d="M14.6,11.4 C13.9,13.3 12.1,14.5 10,14.5 C7.9,14.5 6.1,13.3 5.4,11.4"/></svg>',
        "grid": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="3" height="3" x="2" y="2"/><rect width="3" height="3" x="8" y="2"/><rect width="3" height="3" x="14" y="2"/><rect width="3" height="3" x="2" y="8"/><rect width="3" height="3" x="8" y="8"/><rect width="3" height="3" x="14" y="8"/><rect width="3" height="3" x="2" y="14"/><rect width="3" height="3" x="8" y="14"/><rect width="3" height="3" x="14" y="14"/></svg>',
        "google": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M17.86,9.09 C18.46,12.12 17.14,16.05 13.81,17.56 C9.45,19.53 4.13,17.68 2.47,12.87 C0.68,7.68 4.22,2.42 9.5,2.03 C11.57,1.88 13.42,2.37 15.05,3.65 C15.22,3.78 15.37,3.93 15.61,4.14 C14.9,4.81 14.23,5.45 13.5,6.14 C12.27,5.08 10.84,4.72 9.28,4.98 C8.12,5.17 7.16,5.76 6.37,6.63 C4.88,8.27 4.62,10.86 5.76,12.82 C6.95,14.87 9.17,15.8 11.57,15.25 C13.27,14.87 14.76,13.33 14.89,11.75 L10.51,11.75 L10.51,9.09 L17.86,9.09 L17.86,9.09 Z"/></svg>',
        "gitter": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="1.531" height="11.471" x="3.5" y="1"/><rect width="1.529" height="15.294" x="7.324" y="4.059"/><rect width="1.527" height="15.294" x="11.148" y="4.059"/><rect width="1.529" height="8.412" x="14.971" y="4.059"/></svg>',
        "github": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10,1 C5.03,1 1,5.03 1,10 C1,13.98 3.58,17.35 7.16,18.54 C7.61,18.62 7.77,18.34 7.77,18.11 C7.77,17.9 7.76,17.33 7.76,16.58 C5.26,17.12 4.73,15.37 4.73,15.37 C4.32,14.33 3.73,14.05 3.73,14.05 C2.91,13.5 3.79,13.5 3.79,13.5 C4.69,13.56 5.17,14.43 5.17,14.43 C5.97,15.8 7.28,15.41 7.79,15.18 C7.87,14.6 8.1,14.2 8.36,13.98 C6.36,13.75 4.26,12.98 4.26,9.53 C4.26,8.55 4.61,7.74 5.19,7.11 C5.1,6.88 4.79,5.97 5.28,4.73 C5.28,4.73 6.04,4.49 7.75,5.65 C8.47,5.45 9.24,5.35 10,5.35 C10.76,5.35 11.53,5.45 12.25,5.65 C13.97,4.48 14.72,4.73 14.72,4.73 C15.21,5.97 14.9,6.88 14.81,7.11 C15.39,7.74 15.73,8.54 15.73,9.53 C15.73,12.99 13.63,13.75 11.62,13.97 C11.94,14.25 12.23,14.8 12.23,15.64 C12.23,16.84 12.22,17.81 12.22,18.11 C12.22,18.35 12.38,18.63 12.84,18.54 C16.42,17.35 19,13.98 19,10 C19,5.03 14.97,1 10,1 L10,1 Z"/></svg>',
        "github-alt": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M10,0.5 C4.75,0.5 0.5,4.76 0.5,10.01 C0.5,15.26 4.75,19.51 10,19.51 C15.24,19.51 19.5,15.26 19.5,10.01 C19.5,4.76 15.25,0.5 10,0.5 L10,0.5 Z M12.81,17.69 C12.81,17.69 12.81,17.7 12.79,17.69 C12.47,17.75 12.35,17.59 12.35,17.36 L12.35,16.17 C12.35,15.45 12.09,14.92 11.58,14.56 C12.2,14.51 12.77,14.39 13.26,14.21 C13.87,13.98 14.36,13.69 14.74,13.29 C15.42,12.59 15.76,11.55 15.76,10.17 C15.76,9.25 15.45,8.46 14.83,7.8 C15.1,7.08 15.07,6.29 14.75,5.44 L14.51,5.42 C14.34,5.4 14.06,5.46 13.67,5.61 C13.25,5.78 12.79,6.03 12.31,6.35 C11.55,6.16 10.81,6.05 10.09,6.05 C9.36,6.05 8.61,6.15 7.88,6.35 C7.28,5.96 6.75,5.68 6.26,5.54 C6.07,5.47 5.9,5.44 5.78,5.44 L5.42,5.44 C5.06,6.29 5.04,7.08 5.32,7.8 C4.7,8.46 4.4,9.25 4.4,10.17 C4.4,11.94 4.96,13.16 6.08,13.84 C6.53,14.13 7.05,14.32 7.69,14.43 C8.03,14.5 8.32,14.54 8.55,14.55 C8.07,14.89 7.82,15.42 7.82,16.16 L7.82,17.51 C7.8,17.69 7.7,17.8 7.51,17.8 C4.21,16.74 1.82,13.65 1.82,10.01 C1.82,5.5 5.49,1.83 10,1.83 C14.5,1.83 18.17,5.5 18.17,10.01 C18.18,13.53 15.94,16.54 12.81,17.69 L12.81,17.69 Z"/></svg>',
        "git-fork": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="6" cy="3" r="1.79"/><circle fill="none" stroke="#000" cx="14" cy="3" r="1.79"/><circle fill="none" stroke="#000" cx="10" cy="17" r="1.79"/><path fill="none" stroke="#000" d="m6,4.78v1.99c0,2.63,4,3.66,4,6.75,0,1.55.01,1.24.01,1.24,0-.18,0,.31,0-1.24,0-3.09,3.99-4.12,3.99-6.75v-1.99"/></svg>',
        "git-branch": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="m13.5,8c0,2.41-1.57,2.87-3.44,3.25-1.47.29-3.56.81-3.56,3.75V5"/><circle fill="none" stroke="#000" cx="6.5" cy="3" r="1.79"/><circle fill="none" stroke="#000" cx="13.5" cy="6" r="1.79"/><circle fill="none" stroke="#000" cx="6.5" cy="17" r="1.79"/></svg>',
        "future": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline points="19 2 18 2 18 6 14 6 14 7 19 7 19 2"/><path fill="none" stroke="#000" stroke-width="1.1" d="M18,6.548 C16.709,3.29 13.354,1 9.6,1 C4.6,1 0.6,5 0.6,10 C0.6,15 4.6,19 9.6,19 C14.6,19 18.6,15 18.6,10"/><rect width="1" height="7" x="9" y="4"/><path fill="none" stroke="#000" stroke-width="1.1" d="M13.018,14.197 L9.445,10.625"/></svg>',
        "foursquare": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M15.23,2 C15.96,2 16.4,2.41 16.5,2.86 C16.57,3.15 16.56,3.44 16.51,3.73 C16.46,4.04 14.86,11.72 14.75,12.03 C14.56,12.56 14.16,12.82 13.61,12.83 C13.03,12.84 11.09,12.51 10.69,13 C10.38,13.38 7.79,16.39 6.81,17.53 C6.61,17.76 6.4,17.96 6.08,17.99 C5.68,18.04 5.29,17.87 5.17,17.45 C5.12,17.28 5.1,17.09 5.1,16.91 C5.1,12.4 4.86,7.81 5.11,3.31 C5.17,2.5 5.81,2.12 6.53,2 L15.23,2 L15.23,2 Z M9.76,11.42 C9.94,11.19 10.17,11.1 10.45,11.1 L12.86,11.1 C13.12,11.1 13.31,10.94 13.36,10.69 C13.37,10.64 13.62,9.41 13.74,8.83 C13.81,8.52 13.53,8.28 13.27,8.28 C12.35,8.29 11.42,8.28 10.5,8.28 C9.84,8.28 9.83,7.69 9.82,7.21 C9.8,6.85 10.13,6.55 10.5,6.55 C11.59,6.56 12.67,6.55 13.76,6.55 C14.03,6.55 14.23,6.4 14.28,6.14 C14.34,5.87 14.67,4.29 14.67,4.29 C14.67,4.29 14.82,3.74 14.19,3.74 L7.34,3.74 C7,3.75 6.84,4.02 6.84,4.33 C6.84,7.58 6.85,14.95 6.85,14.99 C6.87,15 8.89,12.51 9.76,11.42 L9.76,11.42 Z"/></svg>',
        "forward": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M2.47,13.11 C4.02,10.02 6.27,7.85 9.04,6.61 C9.48,6.41 10.27,6.13 11,5.91 L11,2 L18.89,9 L11,16 L11,12.13 C9.25,12.47 7.58,13.19 6.02,14.25 C3.03,16.28 1.63,18.54 1.63,18.54 C1.63,18.54 1.38,15.28 2.47,13.11 L2.47,13.11 Z M5.3,13.53 C6.92,12.4 9.04,11.4 12,10.92 L12,13.63 L17.36,9 L12,4.25 L12,6.8 C11.71,6.86 10.86,7.02 9.67,7.49 C6.79,8.65 4.58,10.96 3.49,13.08 C3.18,13.7 2.68,14.87 2.49,16 C3.28,15.05 4.4,14.15 5.3,13.53 L5.3,13.53 Z"/></svg>',
        "folder": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="9.5 5.5 8.5 3.5 1.5 3.5 1.5 16.5 18.5 16.5 18.5 5.5"/></svg>',
        "flickr": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="5.5" cy="9.5" r="3.5"/><circle cx="14.5" cy="9.5" r="3.5"/></svg>',
        "file": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="13" height="17" fill="none" stroke="#000" x="3.5" y="1.5"/></svg>',
        "file-text": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="13" height="17" fill="none" stroke="#000" x="3.5" y="1.5"/><line fill="none" stroke="#000" x1="6" y1="12.5" x2="12" y2="12.5"/><line fill="none" stroke="#000" x1="6" y1="8.5" x2="14" y2="8.5"/><line fill="none" stroke="#000" x1="6" y1="6.5" x2="14" y2="6.5"/><line fill="none" stroke="#000" x1="6" y1="10.5" x2="14" y2="10.5"/></svg>',
        "file-pdf": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="13" height="17" fill="none" stroke="#000" x="3.5" y="1.5"/><path d="M14.65 11.67c-.48.3-1.37-.19-1.79-.37a4.65 4.65 0 0 1 1.49.06c.35.1.36.28.3.31zm-6.3.06l.43-.79a14.7 14.7 0 0 0 .75-1.64 5.48 5.48 0 0 0 1.25 1.55l.2.15a16.36 16.36 0 0 0-2.63.73zM9.5 5.32c.2 0 .32.5.32.97a1.99 1.99 0 0 1-.23 1.04 5.05 5.05 0 0 1-.17-1.3s0-.71.08-.71zm-3.9 9a4.35 4.35 0 0 1 1.21-1.46l.24-.22a4.35 4.35 0 0 1-1.46 1.68zm9.23-3.3a2.05 2.05 0 0 0-1.32-.3 11.07 11.07 0 0 0-1.58.11 4.09 4.09 0 0 1-.74-.5 5.39 5.39 0 0 1-1.32-2.06 10.37 10.37 0 0 0 .28-2.62 1.83 1.83 0 0 0-.07-.25.57.57 0 0 0-.52-.4H9.4a.59.59 0 0 0-.6.38 6.95 6.95 0 0 0 .37 3.14c-.26.63-1 2.12-1 2.12-.3.58-.57 1.08-.82 1.5l-.8.44A3.11 3.11 0 0 0 5 14.16a.39.39 0 0 0 .15.42l.24.13c1.15.56 2.28-1.74 2.66-2.42a23.1 23.1 0 0 1 3.59-.85 4.56 4.56 0 0 0 2.91.8.5.5 0 0 0 .3-.21 1.1 1.1 0 0 0 .12-.75.84.84 0 0 0-.14-.25z"/></svg>',
        "file-edit": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M18.65,1.68 C18.41,1.45 18.109,1.33 17.81,1.33 C17.499,1.33 17.209,1.45 16.98,1.68 L8.92,9.76 L8,12.33 L10.55,11.41 L18.651,3.34 C19.12,2.87 19.12,2.15 18.65,1.68 L18.65,1.68 L18.65,1.68 Z"/><polyline fill="none" stroke="#000" points="16.5 8.482 16.5 18.5 3.5 18.5 3.5 1.5 14.211 1.5"/></svg>',
        "facebook": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M11,10h2.6l0.4-3H11V5.3c0-0.9,0.2-1.5,1.5-1.5H14V1.1c-0.3,0-1-0.1-2.1-0.1C9.6,1,8,2.4,8,5v2H5.5v3H8v8h3V10z"/></svg>',
        "eye": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="10" cy="10" r="3.45"/><path fill="none" stroke="#000" d="m19.5,10c-2.4,3.66-5.26,7-9.5,7h0,0,0c-4.24,0-7.1-3.34-9.49-7C2.89,6.34,5.75,3,9.99,3h0,0,0c4.25,0,7.11,3.34,9.5,7Z"/></svg>',
        "eye-slash": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="m7.56,7.56c.62-.62,1.49-1.01,2.44-1.01,1.91,0,3.45,1.54,3.45,3.45,0,.95-.39,1.82-1.01,2.44"/><path fill="none" stroke="#000" d="m19.5,10c-2.4,3.66-5.26,7-9.5,7h0,0,0c-4.24,0-7.1-3.34-9.49-7C2.89,6.34,5.75,3,9.99,3h0,0,0c4.25,0,7.11,3.34,9.5,7Z"/><line fill="none" stroke="#000" x1="2.5" y1="2.5" x2="17.5" y2="17.5"/></svg>',
        "expand": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="13 2 18 2 18 7 17 7 17 3 13 3"/><polygon points="2 13 3 13 3 17 7 17 7 18 2 18"/><path fill="none" stroke="#000" stroke-width="1.1" d="M11,9 L17,3"/><path fill="none" stroke="#000" stroke-width="1.1" d="M3,17 L9,11"/></svg>',
        "etsy": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M8,4.26C8,4.07,8,4,8.31,4h4.46c.79,0,1.22.67,1.53,1.91l.25,1h.76c.14-2.82.26-4,.26-4S13.65,3,12.52,3H6.81L3.75,2.92v.84l1,.2c.73.11.9.27,1,1,0,0,.06,2,.06,5.17s-.06,5.14-.06,5.14c0,.59-.23.81-1,.94l-1,.2v.84l3.06-.1h5.11c1.15,0,3.82.1,3.82.1,0-.7.45-3.88.51-4.22h-.73l-.76,1.69a2.25,2.25,0,0,1-2.45,1.47H9.4c-1,0-1.44-.4-1.44-1.24V10.44s2.16,0,2.86.06c.55,0,.85.19,1.06,1l.23,1H13L12.9,9.94,13,7.41h-.85l-.28,1.13c-.16.74-.28.84-1,1-1,.1-2.89.09-2.89.09Z"/></svg>',
        "dribbble": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.4" d="M1.3,8.9c0,0,5,0.1,8.6-1c1.4-0.4,2.6-0.9,4-1.9 c1.4-1.1,2.5-2.5,2.5-2.5"/><path fill="none" stroke="#000" stroke-width="1.4" d="M3.9,16.6c0,0,1.7-2.8,3.5-4.2 c1.8-1.3,4-2,5.7-2.2C16,10,19,10.6,19,10.6"/><path fill="none" stroke="#000" stroke-width="1.4" d="M6.9,1.6c0,0,3.3,4.6,4.2,6.8 c0.4,0.9,1.3,3.1,1.9,5.2c0.6,2,0.9,4.4,0.9,4.4"/><circle fill="none" stroke="#000" stroke-width="1.4" cx="10" cy="10" r="9"/></svg>',
        "download": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="14,10 9.5,14.5 5,10"/><rect width="13" height="1" x="3" y="17"/><line fill="none" stroke="#000" x1="9.5" y1="13.91" x2="9.5" y2="3"/></svg>',
        "discord": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M16.074,4.361a14.243,14.243,0,0,0-3.61-1.134,10.61,10.61,0,0,0-.463.96,13.219,13.219,0,0,0-4,0,10.138,10.138,0,0,0-.468-.96A14.206,14.206,0,0,0,3.919,4.364,15.146,15.146,0,0,0,1.324,14.5a14.435,14.435,0,0,0,4.428,2.269A10.982,10.982,0,0,0,6.7,15.21a9.294,9.294,0,0,1-1.494-.727c.125-.093.248-.19.366-.289a10.212,10.212,0,0,0,8.854,0c.119.1.242.2.366.289a9.274,9.274,0,0,1-1.5.728,10.8,10.8,0,0,0,.948,1.562,14.419,14.419,0,0,0,4.431-2.27A15.128,15.128,0,0,0,16.074,4.361Zm-8.981,8.1a1.7,1.7,0,0,1-1.573-1.79A1.689,1.689,0,0,1,7.093,8.881a1.679,1.679,0,0,1,1.573,1.791A1.687,1.687,0,0,1,7.093,12.462Zm5.814,0a1.7,1.7,0,0,1-1.573-1.79,1.689,1.689,0,0,1,1.573-1.791,1.679,1.679,0,0,1,1.573,1.791A1.688,1.688,0,0,1,12.907,12.462Z"/></svg>',
        "desktop": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="1" height="2" x="8" y="15"/><rect width="1" height="2" x="11" y="15"/><rect width="10" height="1" x="5" y="16"/><rect width="17" height="11" fill="none" stroke="#000" x="1.5" y="3.5"/></svg>',
        "database": '<svg width="20" height="20" viewBox="0 0 20 20"><ellipse fill="none" stroke="#000" cx="10" cy="4.64" rx="7.5" ry="3.14"/><path fill="none" stroke="#000" d="M17.5,8.11 C17.5,9.85 14.14,11.25 10,11.25 C5.86,11.25 2.5,9.84 2.5,8.11"/><path fill="none" stroke="#000" d="M17.5,11.25 C17.5,12.99 14.14,14.39 10,14.39 C5.86,14.39 2.5,12.98 2.5,11.25"/><path fill="none" stroke="#000" d="M17.49,4.64 L17.5,14.36 C17.5,16.1 14.14,17.5 10,17.5 C5.86,17.5 2.5,16.09 2.5,14.36 L2.5,4.64"/></svg>',
        "crosshairs": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="10" cy="10" r="7.5"/><line fill="none" stroke="#000" x1="10" x2="10" y2="8"/><line fill="none" stroke="#000" x1="10" y1="12" x2="10" y2="20"/><line fill="none" stroke="#000" y1="10" x2="8" y2="10"/><line fill="none" stroke="#000" x1="12" y1="10" x2="20" y2="10"/></svg>',
        "credit-card": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="17" height="12" fill="none" stroke="#000" x="1.5" y="4.5"/><rect width="18" height="3" x="1" y="7"/></svg>',
        "copy": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="12" height="16" fill="none" stroke="#000" x="3.5" y="2.5"/><polyline fill="none" stroke="#000" points="5 0.5 17.5 0.5 17.5 17"/></svg>',
        "comments": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="2 0.5 19.5 0.5 19.5 13"/><path d="M5,19.71 L5,15 L0,15 L0,2 L18,2 L18,15 L9.71,15 L5,19.71 L5,19.71 L5,19.71 Z M1,14 L6,14 L6,17.29 L9.29,14 L17,14 L17,3 L1,3 L1,14 L1,14 L1,14 Z"/></svg>',
        "commenting": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="1.5,1.5 18.5,1.5 18.5,13.5 10.5,13.5 6.5,17.5 6.5,13.5 1.5,13.5"/><circle cx="10" cy="8" r="1"/><circle cx="6" cy="8" r="1"/><circle cx="14" cy="8" r="1"/></svg>',
        "comment": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M6,18.71 L6,14 L1,14 L1,1 L19,1 L19,14 L10.71,14 L6,18.71 L6,18.71 Z M2,13 L7,13 L7,16.29 L10.29,13 L18,13 L18,2 L2,2 L2,13 L2,13 Z"/></svg>',
        "cog": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" cx="9.997" cy="10" r="3.31"/><path fill="none" stroke="#000" d="M18.488,12.285 L16.205,16.237 C15.322,15.496 14.185,15.281 13.303,15.791 C12.428,16.289 12.047,17.373 12.246,18.5 L7.735,18.5 C7.938,17.374 7.553,16.299 6.684,15.791 C5.801,15.27 4.655,15.492 3.773,16.237 L1.5,12.285 C2.573,11.871 3.317,10.999 3.317,9.991 C3.305,8.98 2.573,8.121 1.5,7.716 L3.765,3.784 C4.645,4.516 5.794,4.738 6.687,4.232 C7.555,3.722 7.939,2.637 7.735,1.5 L12.263,1.5 C12.072,2.637 12.441,3.71 13.314,4.22 C14.206,4.73 15.343,4.516 16.225,3.794 L18.487,7.714 C17.404,8.117 16.661,8.988 16.67,10.009 C16.672,11.018 17.415,11.88 18.488,12.285 L18.488,12.285 Z"/></svg>',
        "code": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.01" points="13,4 19,10 13,16"/><polyline fill="none" stroke="#000" stroke-width="1.01" points="7,4 1,10 7,16"/></svg>',
        "cloud-upload": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.31,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6"/><polyline fill="none" stroke="#000" points="7.25 11.75 9.5 9.5 11.75 11.75"/><path fill="none" stroke="#000" d="M9.5,18 L9.5,9.5"/></svg>',
        "cloud-download": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M6.5,14.61 L3.75,14.61 C1.96,14.61 0.5,13.17 0.5,11.39 C0.5,9.76 1.72,8.41 3.3,8.2 C3.38,5.31 5.75,3 8.68,3 C11.19,3 13.31,4.71 13.89,7.02 C14.39,6.8 14.93,6.68 15.5,6.68 C17.71,6.68 19.5,8.45 19.5,10.64 C19.5,12.83 17.71,14.6 15.5,14.6 L12.5,14.6"/><polyline fill="none" stroke="#000" points="11.75 16 9.5 18.25 7.25 16"/><path fill="none" stroke="#000" d="M9.5,18 L9.5,9.5"/></svg>',
        "close": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.06" d="M16,16 L4,4"/><path fill="none" stroke="#000" stroke-width="1.06" d="M16,4 L4,16"/></svg>',
        "clock": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><rect width="1" height="7" x="9" y="4"/><path fill="none" stroke="#000" stroke-width="1.1" d="M13.018,14.197 L9.445,10.625"/></svg>',
        "chevron-up": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="4 13 10 7 16 13"/></svg>',
        "chevron-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="7 4 13 10 7 16"/></svg>',
        "chevron-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="13 16 7 10 13 4"/></svg>',
        "chevron-down": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="16 7 10 13 4 7"/></svg>',
        "chevron-double-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="10 6 14 10 10 14"/><polyline fill="none" stroke="#000" stroke-width="1.03" points="6 6 10 10 6 14"/></svg>',
        "chevron-double-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.03" points="10 14 6 10 10 6"/><polyline fill="none" stroke="#000" stroke-width="1.03" points="14 14 10 10 14 6"/></svg>',
        "check": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" stroke-width="1.1" points="4,10 8,15 17,4"/></svg>',
        "cart": '<svg width="20" height="20" viewBox="0 0 20 20"><circle cx="7.3" cy="17.3" r="1.4"/><circle cx="13.3" cy="17.3" r="1.4"/><polyline fill="none" stroke="#000" points="0 2 3.2 4 5.3 12.5 16 12.5 18 6.5 8 6.5"/></svg>',
        "camera": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10.8" r="3.8"/><path fill="none" stroke="#000" d="M1,4.5 C0.7,4.5 0.5,4.7 0.5,5 L0.5,17 C0.5,17.3 0.7,17.5 1,17.5 L19,17.5 C19.3,17.5 19.5,17.3 19.5,17 L19.5,5 C19.5,4.7 19.3,4.5 19,4.5 L13.5,4.5 L13.5,2.9 C13.5,2.6 13.3,2.5 13,2.5 L7,2.5 C6.7,2.5 6.5,2.6 6.5,2.9 L6.5,4.5 L1,4.5 L1,4.5 Z"/></svg>',
        "calendar": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M 2,3 2,17 18,17 18,3 2,3 Z M 17,16 3,16 3,8 17,8 17,16 Z M 17,7 3,7 3,4 17,4 17,7 Z"/><rect width="1" height="3" x="6" y="2"/><rect width="1" height="3" x="13" y="2"/></svg>',
        "bookmark": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon fill="none" stroke="#000" points="5.5 1.5 15.5 1.5 15.5 17.5 10.5 12.5 5.5 17.5"/></svg>',
        "bolt": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M4.74,20 L7.73,12 L3,12 L15.43,1 L12.32,9 L17.02,9 L4.74,20 L4.74,20 L4.74,20 Z M9.18,11 L7.1,16.39 L14.47,10 L10.86,10 L12.99,4.67 L5.61,11 L9.18,11 L9.18,11 L9.18,11 Z"/></svg>',
        "bold": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M5,15.3 C5.66,15.3 5.9,15 5.9,14.53 L5.9,5.5 C5.9,4.92 5.56,4.7 5,4.7 L5,4 L8.95,4 C12.6,4 13.7,5.37 13.7,6.9 C13.7,7.87 13.14,9.17 10.86,9.59 L10.86,9.7 C13.25,9.86 14.29,11.28 14.3,12.54 C14.3,14.47 12.94,16 9,16 L5,16 L5,15.3 Z M9,9.3 C11.19,9.3 11.8,8.5 11.85,7 C11.85,5.65 11.3,4.8 9,4.8 L7.67,4.8 L7.67,9.3 L9,9.3 Z M9.185,15.22 C11.97,15 12.39,14 12.4,12.58 C12.4,11.15 11.39,10 9,10 L7.67,10 L7.67,15 L9.18,15 Z"/></svg>',
        "bluesky": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M9.993,9.149c-.772-1.495-2.865-4.288-4.813-5.662-1.866-1.317-2.58-1.09-3.043-.878-.54.246-.637,1.075-.637,1.563s.265,4.003.444,4.587c.579,1.939,2.628,2.595,4.519,2.382.096-.014.193-.029.294-.039-.096.014-.198.029-.294.039-2.768.41-5.233,1.418-2.001,5.011,3.55,3.675,4.866-.786,5.541-3.053.675,2.262,1.452,6.564,5.474,3.053,3.024-3.053.83-4.601-1.939-5.011-.096-.01-.198-.024-.294-.039.101.014.198.024.294.039,1.89.212,3.945-.444,4.519-2.382.174-.588.444-4.099.444-4.587s-.096-1.317-.637-1.563c-.468-.212-1.177-.439-3.043.878-1.963,1.379-4.056,4.167-4.827,5.662h0Z"/></svg>',
        "bell": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" stroke-width="1.1" d="M17,15.5 L3,15.5 C2.99,14.61 3.79,13.34 4.1,12.51 C4.58,11.3 4.72,10.35 5.19,7.01 C5.54,4.53 5.89,3.2 7.28,2.16 C8.13,1.56 9.37,1.5 9.81,1.5 L9.96,1.5 C9.96,1.5 11.62,1.41 12.67,2.17 C14.08,3.2 14.42,4.54 14.77,7.02 C15.26,10.35 15.4,11.31 15.87,12.52 C16.2,13.34 17.01,14.61 17,15.5 L17,15.5 Z"/><path fill="none" stroke="#000" d="M12.39,16 C12.39,17.37 11.35,18.43 9.91,18.43 C8.48,18.43 7.42,17.37 7.42,16"/></svg>',
        "behance": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M9.5,10.6c-0.4-0.5-0.9-0.9-1.6-1.1c1.7-1,2.2-3.2,0.7-4.7C7.8,4,6.3,4,5.2,4C3.5,4,1.7,4,0,4v12c1.7,0,3.4,0,5.2,0 c1,0,2.1,0,3.1-0.5C10.2,14.6,10.5,12.3,9.5,10.6L9.5,10.6z M5.6,6.1c1.8,0,1.8,2.7-0.1,2.7c-1,0-2,0-2.9,0V6.1H5.6z M2.6,13.8v-3.1 c1.1,0,2.1,0,3.2,0c2.1,0,2.1,3.2,0.1,3.2L2.6,13.8z"/><path d="M19.9,10.9C19.7,9.2,18.7,7.6,17,7c-4.2-1.3-7.3,3.4-5.3,7.1c0.9,1.7,2.8,2.3,4.7,2.1c1.7-0.2,2.9-1.3,3.4-2.9h-2.2 c-0.4,1.3-2.4,1.5-3.5,0.6c-0.4-0.4-0.6-1.1-0.6-1.7H20C20,11.7,19.9,10.9,19.9,10.9z M13.5,10.6c0-1.6,2.3-2.7,3.5-1.4 c0.4,0.4,0.5,0.9,0.6,1.4H13.5L13.5,10.6z"/><rect width="5" height="1.4" x="13" y="4"/></svg>',
        "ban": '<svg width="20" height="20" viewBox="0 0 20 20"><circle fill="none" stroke="#000" stroke-width="1.1" cx="10" cy="10" r="9"/><line fill="none" stroke="#000" stroke-width="1.1" x1="4" y1="3.5" x2="16" y2="16.5"/></svg>',
        "bag": '<svg width="20" height="20" viewBox="0 0 20 20"><path fill="none" stroke="#000" d="M7.5,7.5V4A2.48,2.48,0,0,1,10,1.5,2.54,2.54,0,0,1,12.5,4V7.5"/><polygon fill="none" stroke="#000" points="16.5 7.5 3.5 7.5 2.5 18.5 17.5 18.5 16.5 7.5"/></svg>',
        "arrow-up": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="10.5,4 15.37,9.4 14.63,10.08 10.5,5.49 6.37,10.08 5.63,9.4"/><line fill="none" stroke="#000" x1="10.5" y1="16" x2="10.5" y2="5"/></svg>',
        "arrow-up-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="16 10 16 4 10 4"/><line fill="none" stroke="#000" x1="4" y1="16" x2="16" y2="4"/></svg>',
        "arrow-right": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="10 5 15 9.5 10 14"/><line fill="none" stroke="#000" x1="4" y1="9.5" x2="15" y2="9.5"/></svg>',
        "arrow-left": '<svg width="20" height="20" viewBox="0 0 20 20"><polyline fill="none" stroke="#000" points="10 14 5 9.5 10 5"/><line fill="none" stroke="#000" x1="16" y1="9.5" x2="5" y2="9.52"/></svg>',
        "arrow-down": '<svg width="20" height="20" viewBox="0 0 20 20"><polygon points="10.5,16.08 5.63,10.66 6.37,10 10.5,14.58 14.63,10 15.37,10.66"/><line fill="none" stroke="#000" x1="10.5" y1="4" x2="10.5" y2="15"/></svg>',
        "apple": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m17.23,6.93c-.1.08-1.95,1.12-1.95,3.43,0,2.67,2.35,3.62,2.42,3.64-.01.06-.37,1.29-1.24,2.55-.77,1.11-1.58,2.22-2.8,2.22s-1.54-.71-2.95-.71-1.87.73-2.99.73-1.9-1.03-2.8-2.29c-1.04-1.48-1.88-3.78-1.88-5.96,0-3.5,2.28-5.36,4.51-5.36,1.19,0,2.18.78,2.93.78s1.82-.83,3.17-.83c.51,0,2.36.05,3.57,1.79h0Zm-4.21-3.27c.56-.66.96-1.59.96-2.51,0-.13-.01-.26-.03-.36-.91.03-1.99.61-2.65,1.36-.51.58-.99,1.5-.99,2.44,0,.14.02.28.03.33.06.01.15.02.24.02.82,0,1.85-.55,2.44-1.28h0Z"/></svg>',
        "android": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m14.88,6.77l1.66-2.87c.09-.16.04-.37-.12-.46-.16-.09-.37-.04-.46.12l-1.68,2.91c-1.28-.59-2.73-.91-4.28-.91s-3,.33-4.28.91l-1.68-2.91c-.09-.16-.3-.22-.46-.12-.16.09-.22.3-.12.46l1.66,2.87C2.26,8.32.32,11.22,0,14.61h20c-.32-3.39-2.26-6.29-5.12-7.84h0Zm-9.47,5.03c-.46,0-.84-.38-.84-.84s.38-.84.84-.84.84.38.84.84c0,.46-.37.84-.84.84Zm9.18,0c-.46,0-.84-.38-.84-.84s.38-.84.84-.84.84.38.84.84c0,.46-.37.84-.84.84Z"/></svg>',
        "android-robot": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="m17.61,7.96v4.64c-.06,1.48-2.17,1.48-2.23,0v-4.64c.06-1.48,2.17-1.48,2.23,0Z"/><path d="m4.62,7.96v4.64c-.06,1.48-2.17,1.48-2.23,0v-4.64c.06-1.48,2.17-1.48,2.23,0Z"/><path d="m12.78,2.85c-.11-.07-.23-.13-.34-.19.13-.23.65-1.17.79-1.42.07-.12-.05-.27-.18-.23-.04.01-.07.04-.09.08l-.79,1.43c-1.32-.6-2.98-.6-4.3,0-.13-.23-.65-1.18-.79-1.43-.04-.07-.14-.1-.21-.06-.08.04-.1.14-.06.21,0,0,.79,1.42.79,1.42-1.49.77-2.53,2.28-2.53,3.99-.02,0,9.93,0,9.93,0,.01-1.55-.87-2.98-2.19-3.8Zm-5.07,1.98c-.23,0-.41-.19-.41-.41.01-.27.21-.41.41-.41s.4.14.42.41c0,.22-.18.42-.41.41Zm4.58,0c-.23,0-.42-.19-.41-.41.01-.28.21-.41.41-.41s.4.14.41.41c0,.23-.19.41-.41.41Z"/><path d="m14.97,7.03v7.2c0,.66-.54,1.2-1.2,1.2h-.8v2.46c-.06,1.48-2.16,1.48-2.23,0,0,0,0-2.46,0-2.46h-1.48v2.46c0,.61-.5,1.11-1.11,1.11s-1.11-.5-1.11-1.11v-2.46h-.8c-.66,0-1.2-.54-1.2-1.2,0,0,0-7.2,0-7.2h9.93Z"/></svg>',
        "album": '<svg width="20" height="20" viewBox="0 0 20 20"><rect width="10" height="1" x="5" y="2"/><rect width="14" height="1" x="3" y="4"/><rect width="17" height="11" fill="none" stroke="#000" x="1.5" y="6.5"/></svg>',
        "500px": '<svg width="20" height="20" viewBox="0 0 20 20"><path d="M9.624,11.866c-0.141,0.132,0.479,0.658,0.662,0.418c0.051-0.046,0.607-0.61,0.662-0.664c0,0,0.738,0.719,0.814,0.719 c0.1,0,0.207-0.055,0.322-0.17c0.27-0.269,0.135-0.416,0.066-0.495l-0.631-0.616l0.658-0.668c0.146-0.156,0.021-0.314-0.1-0.449 c-0.182-0.18-0.359-0.226-0.471-0.125l-0.656,0.654l-0.654-0.654c-0.033-0.034-0.08-0.045-0.124-0.045 c-0.079,0-0.191,0.068-0.307,0.181c-0.202,0.202-0.247,0.351-0.133,0.462l0.665,0.665L9.624,11.866z"/><path d="M11.066,2.884c-1.061,0-2.185,0.248-3.011,0.604c-0.087,0.034-0.141,0.106-0.15,0.205C7.893,3.784,7.919,3.909,7.982,4.066 c0.05,0.136,0.187,0.474,0.452,0.372c0.844-0.326,1.779-0.507,2.633-0.507c0.963,0,1.9,0.191,2.781,0.564 c0.695,0.292,1.357,0.719,2.078,1.34c0.051,0.044,0.105,0.068,0.164,0.068c0.143,0,0.273-0.137,0.389-0.271 c0.191-0.214,0.324-0.395,0.135-0.575c-0.686-0.654-1.436-1.138-2.363-1.533C13.24,3.097,12.168,2.884,11.066,2.884z"/><path d="M16.43,15.747c-0.092-0.028-0.242,0.05-0.309,0.119l0,0c-0.652,0.652-1.42,1.169-2.268,1.521 c-0.877,0.371-1.814,0.551-2.779,0.551c-0.961,0-1.896-0.189-2.775-0.564c-0.848-0.36-1.612-0.879-2.268-1.53 c-0.682-0.688-1.196-1.455-1.529-2.268c-0.325-0.799-0.471-1.643-0.471-1.643c-0.045-0.24-0.258-0.249-0.567-0.203 c-0.128,0.021-0.519,0.079-0.483,0.36v0.01c0.105,0.644,0.289,1.284,0.545,1.895c0.417,0.969,1.002,1.849,1.756,2.604 c0.757,0.754,1.636,1.34,2.604,1.757C8.901,18.785,9.97,19,11.088,19c1.104,0,2.186-0.215,3.188-0.645 c1.838-0.896,2.604-1.757,2.604-1.757c0.182-0.204,0.227-0.317-0.1-0.643C16.779,15.956,16.525,15.774,16.43,15.747z"/><path d="M5.633,13.287c0.293,0.71,0.723,1.341,1.262,1.882c0.54,0.54,1.172,0.971,1.882,1.264c0.731,0.303,1.509,0.461,2.298,0.461 c0.801,0,1.578-0.158,2.297-0.461c0.711-0.293,1.344-0.724,1.883-1.264c0.543-0.541,0.971-1.172,1.264-1.882 c0.314-0.721,0.463-1.5,0.463-2.298c0-0.79-0.148-1.569-0.463-2.289c-0.293-0.699-0.721-1.329-1.264-1.881 c-0.539-0.541-1.172-0.959-1.867-1.263c-0.721-0.303-1.5-0.461-2.299-0.461c-0.802,0-1.613,0.159-2.322,0.461 c-0.577,0.25-1.544,0.867-2.119,1.454v0.012V2.108h8.16C15.1,2.104,15.1,1.69,15.1,1.552C15.1,1.417,15.1,1,14.809,1H5.915 C5.676,1,5.527,1.192,5.527,1.384v6.84c0,0.214,0.273,0.372,0.529,0.428c0.5,0.105,0.614-0.056,0.737-0.224l0,0 c0.18-0.273,0.776-0.884,0.787-0.894c0.901-0.905,2.117-1.408,3.416-1.408c1.285,0,2.5,0.501,3.412,1.408 c0.914,0.914,1.408,2.122,1.408,3.405c0,1.288-0.508,2.496-1.408,3.405c-0.9,0.896-2.152,1.406-3.438,1.406 c-0.877,0-1.711-0.229-2.433-0.671v-4.158c0-0.553,0.237-1.151,0.643-1.614c0.462-0.519,1.094-0.799,1.782-0.799 c0.664,0,1.293,0.253,1.758,0.715c0.459,0.459,0.709,1.071,0.709,1.723c0,1.385-1.094,2.468-2.488,2.468 c-0.273,0-0.769-0.121-0.781-0.125c-0.281-0.087-0.405,0.306-0.438,0.436c-0.159,0.496,0.079,0.585,0.123,0.607 c0.452,0.137,0.743,0.157,1.129,0.157c1.973,0,3.572-1.6,3.572-3.57c0-1.964-1.6-3.552-3.572-3.552c-0.97,0-1.872,0.36-2.546,1.038 c-0.656,0.631-1.027,1.487-1.027,2.322v3.438v-0.011c-0.372-0.42-0.732-1.041-0.981-1.682c-0.102-0.248-0.315-0.202-0.607-0.113 c-0.135,0.035-0.519,0.157-0.44,0.439C5.372,12.799,5.577,13.164,5.633,13.287z"/></svg>'
      });
    }
    if (typeof window !== "undefined" && window.UIkit) {
      window.UIkit.use(plugin);
    }

    return plugin;

}));
});

UIkit.icon.add({
	newline: `
		<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
			<polyline fill="none" stroke="#000" points="10 14 5 9.5 10 5" />
			<line fill="none" stroke="#000" x1="16" y1="9.5" x2="5" y2="9.52" />
			<line fill="none" stroke="#000" x1="15.61" y1="10" x2="15.59" y2="4" />
		</svg>
	`,
	euro: `
		<svg width="20" height="20" viewBox="0 0 20 20">
			<path
				d="m 16.733414,17.816691 c -0.05866,-0.295983 -0.349776,-0.485358 -0.643928,-0.418259 -0.477322,0.108884 -1.228361,0.323364 -2.027947,0.241651 C 11.551621,17.383587 8.4667598,14.78834 7.5947954,12.526777 h 5.1640266 c 0.250612,0 0.458634,-0.175968 0.522679,-0.418259 l 0.195885,-0.74106 c 0.07527,-0.334911 -0.17942,-0.65317 -0.522679,-0.65317 H 6.9619827 C 6.9079647,10.074645 6.9810677,9.4514749 7.0503087,8.8283499 H 13.59464 c 0.251735,1.2e-5 0.38731,-0.175248 0.441139,-0.42116 l 0.290714,-0.8838051 c 0.07313,-0.334107 -0.181295,-0.6500849 -0.523348,-0.650267 l -6.1731264,-0.0033 c 0.9211162,-2.008527 3.8685044,-4.41549 6.2952264,-4.6786709 0.642926,-0.06973 1.061456,-0.0051 1.689777,0.185044 0.2775,0.05661 0.551205,-0.111517 0.625089,-0.3849551 l 0.535312,-1.09284695 c 0.08134,-0.300937 -0.110044,-0.607857 -0.416339,-0.665937 -0.540357,-0.102455 -1.411205,-0.232455 -2.352054,-0.232455 -4.338572,0 -7.8395097,3.13436505 -9.1321437,6.87311595 H 3.3983237 c -0.2958482,5e-6 -0.5357143,0.239871 -0.5357143,0.535719 v 0.8838041 c 0,0.2958479 0.2398661,0.535714 0.5357143,0.535714 h 0.9629019 c -0.045045,0.607456 -0.052723,1.3074561 -0.00808,1.8859381 H 3.3983237 c -0.2958482,0 -0.5357143,0.239866 -0.5357143,0.535714 v 0.741061 c 0,0.295848 0.2398661,0.535714 0.5357143,0.535714 h 1.3443751 c 1.1171876,4.032679 4.604911,7.473226 9.2643312,7.473226 1.174152,0 2.167947,-0.202857 2.727724,-0.347679 0.275312,-0.07121 0.447634,-0.344107 0.392321,-0.62308 z"
				fill="currentColor" />
		</svg>
	`,
	percentage: `
		<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
			<circle fill="none" stroke="currentColor" cx="4" cy="3.5" r="2.5"></circle>
			<circle fill="none" stroke="currentColor" cx="16" cy="16.5" r="2.5"></circle>
			<line fill="none" stroke="currentColor" stroke-width="1.1" x1="16" y1="3.5" x2="4" y2="16.5"></line>
		</svg>
	`,
	'chevron-double-up': `
		<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-svg="chevron-double-up">
			<polyline fill="none" stroke="#000" stroke-width="1.03" points="4 10 10 4 16 10"></polyline>
			<polyline fill="none" stroke="#000" stroke-width="1.03" points="4 16 10 10 16 16"></polyline>
		</svg>
	`,
	'chevron-double-down': `
	<svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg" data-svg="chevron-double-down">
		<polyline fill="none" stroke="#000" stroke-width="1.03" points="16 4 10 10 4 4"></polyline>
		<polyline fill="none" stroke="#000" stroke-width="1.03" points="16 10 10 16 4 10"></polyline>
	</svg>
	`,
});
UIkit.use(uikitIcons);

const globalRequiredMarker = writable('*');
const globalOptionalMarker = writable('');

let counter = 0;
let prefix = 'html-id-' + Math.random().toString(16).split('.')[1];

function generateId() {
  return prefix + '-' + (counter++);
}

/* src/components/Alert.svelte generated by Svelte v4.2.19 */

function create_if_block$s(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			attr(button, "class", "uk-alert-close");
			attr(button, "uk-close", "");
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}
		}
	};
}

function create_fragment$M(ctx) {
	let div;
	let t;
	let div_uk_alert_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*closable*/ ctx[1] && create_if_block$s();
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			if (default_slot) default_slot.c();
			attr(div, "style", /*style*/ ctx[5]);
			attr(div, "class", /*className*/ ctx[6]);
			attr(div, "uk-alert", div_uk_alert_value = "animation: " + /*animation*/ ctx[3] + "; duration: " + /*animationDuration*/ ctx[4] + ";");
			toggle_class(div, "uk-alert-primary", /*variant*/ ctx[2] === "primary");
			toggle_class(div, "uk-alert-success", /*variant*/ ctx[2] === "success");
			toggle_class(div, "uk-alert-warning", /*variant*/ ctx[2] === "warning");
			toggle_class(div, "uk-alert-danger", /*variant*/ ctx[2] === "danger");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append(div, t);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[11](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "hide", stop_propagation(/*hide_handler*/ ctx[9])),
					listen(div, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[10]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*closable*/ ctx[1]) {
				if (if_block) ; else {
					if_block = create_if_block$s();
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*style*/ 32) {
				attr(div, "style", /*style*/ ctx[5]);
			}

			if (!current || dirty & /*className*/ 64) {
				attr(div, "class", /*className*/ ctx[6]);
			}

			if (!current || dirty & /*animation, animationDuration*/ 24 && div_uk_alert_value !== (div_uk_alert_value = "animation: " + /*animation*/ ctx[3] + "; duration: " + /*animationDuration*/ ctx[4] + ";")) {
				attr(div, "uk-alert", div_uk_alert_value);
			}

			if (!current || dirty & /*className, variant*/ 68) {
				toggle_class(div, "uk-alert-primary", /*variant*/ ctx[2] === "primary");
			}

			if (!current || dirty & /*className, variant*/ 68) {
				toggle_class(div, "uk-alert-success", /*variant*/ ctx[2] === "success");
			}

			if (!current || dirty & /*className, variant*/ 68) {
				toggle_class(div, "uk-alert-warning", /*variant*/ ctx[2] === "warning");
			}

			if (!current || dirty & /*className, variant*/ 68) {
				toggle_class(div, "uk-alert-danger", /*variant*/ ctx[2] === "danger");
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (if_block) if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[11](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$M($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { closable = true } = $$props;
	let { variant = undefined } = $$props;
	let { animation = true } = $$props;
	let { animationDuration = 150 } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { ref = undefined } = $$props;

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('closable' in $$props) $$invalidate(1, closable = $$props.closable);
		if ('variant' in $$props) $$invalidate(2, variant = $$props.variant);
		if ('animation' in $$props) $$invalidate(3, animation = $$props.animation);
		if ('animationDuration' in $$props) $$invalidate(4, animationDuration = $$props.animationDuration);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [
		ref,
		closable,
		variant,
		animation,
		animationDuration,
		style,
		className,
		$$scope,
		slots,
		hide_handler,
		beforehide_handler,
		div_binding
	];
}

class Alert extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$M, create_fragment$M, safe_not_equal, {
			closable: 1,
			variant: 2,
			animation: 3,
			animationDuration: 4,
			style: 5,
			className: 6,
			ref: 0
		});
	}
}

/* src/components/Article.svelte generated by Svelte v4.2.19 */

function create_if_block_1$i(ctx) {
	let h1;

	return {
		c() {
			h1 = element("h1");
			attr(h1, "class", "uk-article-title");
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			h1.innerHTML = /*titleAsHtml*/ ctx[3];
		},
		p(ctx, dirty) {
			if (dirty & /*titleAsHtml*/ 8) h1.innerHTML = /*titleAsHtml*/ ctx[3];		},
		d(detaching) {
			if (detaching) {
				detach(h1);
			}
		}
	};
}

// (34:1) {#if articleMetaAsHtml}
function create_if_block$r(ctx) {
	let p;

	return {
		c() {
			p = element("p");
			attr(p, "class", "uk-article-meta");
		},
		m(target, anchor) {
			insert(target, p, anchor);
			p.innerHTML = /*articleMetaAsHtml*/ ctx[4];
		},
		p(ctx, dirty) {
			if (dirty & /*articleMetaAsHtml*/ 16) p.innerHTML = /*articleMetaAsHtml*/ ctx[4];		},
		d(detaching) {
			if (detaching) {
				detach(p);
			}
		}
	};
}

function create_fragment$L(ctx) {
	let article;
	let t0;
	let t1;
	let article_class_value;
	let current;
	let if_block0 = /*titleAsHtml*/ ctx[3] && create_if_block_1$i(ctx);
	let if_block1 = /*articleMetaAsHtml*/ ctx[4] && create_if_block$r(ctx);
	const default_slot_template = /*#slots*/ ctx[6].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

	return {
		c() {
			article = element("article");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			if (default_slot) default_slot.c();
			attr(article, "style", /*style*/ ctx[2]);

			attr(article, "class", article_class_value = /*className*/ ctx[1]
			? "uk-article " + /*className*/ ctx[1]
			: "uk-article");
		},
		m(target, anchor) {
			insert(target, article, anchor);
			if (if_block0) if_block0.m(article, null);
			append(article, t0);
			if (if_block1) if_block1.m(article, null);
			append(article, t1);

			if (default_slot) {
				default_slot.m(article, null);
			}

			/*article_binding*/ ctx[7](article);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*titleAsHtml*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$i(ctx);
					if_block0.c();
					if_block0.m(article, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*articleMetaAsHtml*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$r(ctx);
					if_block1.c();
					if_block1.m(article, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*style*/ 4) {
				attr(article, "style", /*style*/ ctx[2]);
			}

			if (!current || dirty & /*className*/ 2 && article_class_value !== (article_class_value = /*className*/ ctx[1]
			? "uk-article " + /*className*/ ctx[1]
			: "uk-article")) {
				attr(article, "class", article_class_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(article);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*article_binding*/ ctx[7](null);
		}
	};
}

function instance$L($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { titleAsHtml = "" } = $$props;
	let { articleMetaAsHtml = "" } = $$props;
	let { ref = undefined } = $$props;

	function article_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('titleAsHtml' in $$props) $$invalidate(3, titleAsHtml = $$props.titleAsHtml);
		if ('articleMetaAsHtml' in $$props) $$invalidate(4, articleMetaAsHtml = $$props.articleMetaAsHtml);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	return [
		ref,
		className,
		style,
		titleAsHtml,
		articleMetaAsHtml,
		$$scope,
		slots,
		article_binding
	];
}

class Article extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$L, create_fragment$L, safe_not_equal, {
			className: 1,
			style: 2,
			titleAsHtml: 3,
			articleMetaAsHtml: 4,
			ref: 0
		});
	}
}

/* src/components/Loader.svelte generated by Svelte v4.2.19 */

function create_fragment$K(ctx) {
	let div;
	let div_uk_spinner_value;

	return {
		c() {
			div = element("div");
			attr(div, "class", /*className*/ ctx[1]);
			attr(div, "style", /*style*/ ctx[3]);
			attr(div, "uk-spinner", div_uk_spinner_value = "ratio: " + /*ratio*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[4](div);
		},
		p(ctx, [dirty]) {
			if (dirty & /*className*/ 2) {
				attr(div, "class", /*className*/ ctx[1]);
			}

			if (dirty & /*style*/ 8) {
				attr(div, "style", /*style*/ ctx[3]);
			}

			if (dirty & /*ratio*/ 4 && div_uk_spinner_value !== (div_uk_spinner_value = "ratio: " + /*ratio*/ ctx[2])) {
				attr(div, "uk-spinner", div_uk_spinner_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding*/ ctx[4](null);
		}
	};
}

function instance$K($$self, $$props, $$invalidate) {
	let { className = undefined } = $$props;
	let { ratio = 1 } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('ratio' in $$props) $$invalidate(2, ratio = $$props.ratio);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
	};

	return [ref, className, ratio, style, div_binding];
}

class Loader extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$K, create_fragment$K, safe_not_equal, { className: 1, ratio: 2, style: 3, ref: 0 });
	}
}

/* src/components/Button.svelte generated by Svelte v4.2.19 */

function create_if_block_3$8(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_4$5, create_if_block_5$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*disabled*/ ctx[5] && (/*loading*/ ctx[6] || /*type*/ ctx[4] === 'submit' && /*$formState*/ ctx[12] === 'loading')) return 0;
		if (/*icon*/ ctx[8]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

// (86:19) 
function create_if_block_5$5(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-icon");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[8] + "; ratio: .75");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 256 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[8] + "; ratio: .75")) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (84:2) {#if !disabled && (loading || (type === 'submit' && $formState === 'loading'))}
function create_if_block_4$5(ctx) {
	let loader;
	let current;

	loader = new Loader({
			props: { className: "uk-icon", ratio: 0.4 }
		});

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p: noop$1,
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

// (91:2) {#if iconPosition === 'right'}
function create_if_block$q(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1$h, create_if_block_2$d];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (!/*disabled*/ ctx[5] && (/*loading*/ ctx[6] || /*type*/ ctx[4] === 'submit' && /*$formState*/ ctx[12] === 'loading')) return 0;
		if (/*icon*/ ctx[8]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}
		}
	};
}

// (94:19) 
function create_if_block_2$d(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-icon");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[8] + "; ratio: .75");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*icon*/ 256 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[8] + "; ratio: .75")) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (92:4) {#if !disabled && (loading || (type === 'submit' && $formState === 'loading'))}
function create_if_block_1$h(ctx) {
	let loader;
	let current;

	loader = new Loader({
			props: { className: "uk-icon", ratio: 0.4 }
		});

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p: noop$1,
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

function create_fragment$J(ctx) {
	let button;
	let t0;
	let t1;
	let button_disabled_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*iconPosition*/ ctx[9] === 'left' && create_if_block_3$8(ctx);
	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);
	let if_block1 = /*iconPosition*/ ctx[9] === 'right' && create_if_block$q(ctx);

	return {
		c() {
			button = element("button");
			if (if_block0) if_block0.c();
			t0 = space();
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			attr(button, "id", /*id*/ ctx[1]);
			button.disabled = button_disabled_value = /*disabled*/ ctx[5] || /*loading*/ ctx[6] || /*type*/ ctx[4] === 'submit' && ['loading'].includes(/*$formState*/ ctx[12]);
			attr(button, "class", /*className*/ ctx[2]);
			attr(button, "type", /*type*/ ctx[4]);
			attr(button, "style", /*style*/ ctx[3]);
			attr(button, "uk-tooltip", /*tooltip*/ ctx[11]);
			toggle_class(button, "uk-button-default", /*variant*/ ctx[7] === 'default');
			toggle_class(button, "uk-button-primary", /*variant*/ ctx[7] === 'primary');
			toggle_class(button, "uk-button-secondary", /*variant*/ ctx[7] === 'secondary');
			toggle_class(button, "uk-button-danger", /*variant*/ ctx[7] === 'danger');
			toggle_class(button, "uk-button-text", /*variant*/ ctx[7] === 'text');
			toggle_class(button, "uk-button-link", /*variant*/ ctx[7] === 'link');
			toggle_class(button, "uk-button-small", /*size*/ ctx[10] === 'small');
			toggle_class(button, "uk-button-large", /*size*/ ctx[10] === 'large');
			toggle_class(button, "uk-button", true);
		},
		m(target, anchor) {
			insert(target, button, anchor);
			if (if_block0) if_block0.m(button, null);
			append(button, t0);

			if (default_slot) {
				default_slot.m(button, null);
			}

			append(button, t1);
			if (if_block1) if_block1.m(button, null);
			/*button_binding*/ ctx[17](button);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*click_handler*/ ctx[16]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*iconPosition*/ ctx[9] === 'left') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*iconPosition*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3$8(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(button, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}

			if (/*iconPosition*/ ctx[9] === 'right') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*iconPosition*/ 512) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$q(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(button, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*id*/ 2) {
				attr(button, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*disabled, loading, type, $formState*/ 4208 && button_disabled_value !== (button_disabled_value = /*disabled*/ ctx[5] || /*loading*/ ctx[6] || /*type*/ ctx[4] === 'submit' && ['loading'].includes(/*$formState*/ ctx[12]))) {
				button.disabled = button_disabled_value;
			}

			if (!current || dirty & /*className*/ 4) {
				attr(button, "class", /*className*/ ctx[2]);
			}

			if (!current || dirty & /*type*/ 16) {
				attr(button, "type", /*type*/ ctx[4]);
			}

			if (!current || dirty & /*style*/ 8) {
				attr(button, "style", /*style*/ ctx[3]);
			}

			if (!current || dirty & /*tooltip*/ 2048) {
				attr(button, "uk-tooltip", /*tooltip*/ ctx[11]);
			}

			if (!current || dirty & /*className, variant*/ 132) {
				toggle_class(button, "uk-button-default", /*variant*/ ctx[7] === 'default');
			}

			if (!current || dirty & /*className, variant*/ 132) {
				toggle_class(button, "uk-button-primary", /*variant*/ ctx[7] === 'primary');
			}

			if (!current || dirty & /*className, variant*/ 132) {
				toggle_class(button, "uk-button-secondary", /*variant*/ ctx[7] === 'secondary');
			}

			if (!current || dirty & /*className, variant*/ 132) {
				toggle_class(button, "uk-button-danger", /*variant*/ ctx[7] === 'danger');
			}

			if (!current || dirty & /*className, variant*/ 132) {
				toggle_class(button, "uk-button-text", /*variant*/ ctx[7] === 'text');
			}

			if (!current || dirty & /*className, variant*/ 132) {
				toggle_class(button, "uk-button-link", /*variant*/ ctx[7] === 'link');
			}

			if (!current || dirty & /*className, size*/ 1028) {
				toggle_class(button, "uk-button-small", /*size*/ ctx[10] === 'small');
			}

			if (!current || dirty & /*className, size*/ 1028) {
				toggle_class(button, "uk-button-large", /*size*/ ctx[10] === 'large');
			}

			if (!current || dirty & /*className*/ 4) {
				toggle_class(button, "uk-button", true);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			/*button_binding*/ ctx[17](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$J($$self, $$props, $$invalidate) {
	let $formState;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id = undefined } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { type = "button" } = $$props;
	let { disabled = false } = $$props;
	let { loading = false } = $$props;
	let { variant = type === "submit" ? "primary" : "default" } = $$props;
	let { icon = type === "submit" ? "newline" : undefined } = $$props;
	let { iconPosition = 'right' } = $$props;
	let { size = undefined } = $$props;
	let { tooltip = undefined } = $$props;
	let { ref = undefined } = $$props;

	/** @type {Readable<'initial'|'invalid'|'loading'|'error'|'success'>} */
	const formState = getContext("form") || readable("initial");

	component_subscribe($$self, formState, value => $$invalidate(12, $formState = value));

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function button_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('className' in $$props) $$invalidate(2, className = $$props.className);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('type' in $$props) $$invalidate(4, type = $$props.type);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('loading' in $$props) $$invalidate(6, loading = $$props.loading);
		if ('variant' in $$props) $$invalidate(7, variant = $$props.variant);
		if ('icon' in $$props) $$invalidate(8, icon = $$props.icon);
		if ('iconPosition' in $$props) $$invalidate(9, iconPosition = $$props.iconPosition);
		if ('size' in $$props) $$invalidate(10, size = $$props.size);
		if ('tooltip' in $$props) $$invalidate(11, tooltip = $$props.tooltip);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	};

	return [
		ref,
		id,
		className,
		style,
		type,
		disabled,
		loading,
		variant,
		icon,
		iconPosition,
		size,
		tooltip,
		$formState,
		formState,
		$$scope,
		slots,
		click_handler,
		button_binding
	];
}

class Button extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$J, create_fragment$J, safe_not_equal, {
			id: 1,
			className: 2,
			style: 3,
			type: 4,
			disabled: 5,
			loading: 6,
			variant: 7,
			icon: 8,
			iconPosition: 9,
			size: 10,
			tooltip: 11,
			ref: 0
		});
	}
}

/* src/components/form/Field.svelte generated by Svelte v4.2.19 */

function create_else_block$c(ctx) {
	let t;
	let div;
	let current;
	let if_block = /*label*/ ctx[3] && create_if_block_5$4(ctx);
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "uk-form-controls svelte-1diggri");
			toggle_class(div, "relative", /*hasIcon*/ ctx[2]);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_5$4(ctx);
					if_block.c();
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*hasIcon*/ 4) {
				toggle_class(div, "relative", /*hasIcon*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(div);
			}

			if (if_block) if_block.d(detaching);
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (53:2) {#if labelWrap}
function create_if_block_4$4(ctx) {
	let div;
	let label_1;
	let t0;
	let t1;
	let t2;
	let t3;
	let current;
	const default_slot_template = /*#slots*/ ctx[18].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

	return {
		c() {
			div = element("div");
			label_1 = element("label");
			if (default_slot) default_slot.c();
			t0 = space();
			t1 = text(/*label*/ ctx[3]);
			t2 = space();
			t3 = text(/*suffix*/ ctx[11]);
			attr(label_1, "for", /*inputId*/ ctx[1]);
			attr(label_1, "class", "uk-form-label");
			attr(div, "class", "uk-form-controls uk-form-controls-text svelte-1diggri");
			toggle_class(div, "relative", /*hasIcon*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, label_1);

			if (default_slot) {
				default_slot.m(label_1, null);
			}

			append(label_1, t0);
			append(label_1, t1);
			append(label_1, t2);
			append(label_1, t3);
			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*label*/ 8) set_data(t1, /*label*/ ctx[3]);
			if (!current || dirty & /*suffix*/ 2048) set_data(t3, /*suffix*/ ctx[11]);

			if (!current || dirty & /*inputId*/ 2) {
				attr(label_1, "for", /*inputId*/ ctx[1]);
			}

			if (!current || dirty & /*hasIcon*/ 4) {
				toggle_class(div, "relative", /*hasIcon*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (64:4) {#if label}
function create_if_block_5$4(ctx) {
	let label_1;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			label_1 = element("label");
			t0 = text(/*label*/ ctx[3]);
			t1 = space();
			t2 = text(/*suffix*/ ctx[11]);
			attr(label_1, "class", "uk-form-label");
			attr(label_1, "for", /*inputId*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			append(label_1, t0);
			append(label_1, t1);
			append(label_1, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 8) set_data(t0, /*label*/ ctx[3]);
			if (dirty & /*suffix*/ 2048) set_data(t2, /*suffix*/ ctx[11]);

			if (dirty & /*inputId*/ 2) {
				attr(label_1, "for", /*inputId*/ ctx[1]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(label_1);
			}
		}
	};
}

// (74:2) {#if helperText || textIfInvalid || textIfValid}
function create_if_block$p(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*state*/ ctx[9] === 'initial') return create_if_block_1$g;
		if (/*state*/ ctx[9] === 'valid') return create_if_block_2$c;
		if (/*state*/ ctx[9] === 'invalid') return create_if_block_3$7;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) {
				if_block.d(detaching);
			}
		}
	};
}

// (79:34) 
function create_if_block_3$7(ctx) {
	let div;
	let t_value = (/*textIfInvalid*/ ctx[6] || '\xA0') + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "invalid-text svelte-1diggri");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*textIfInvalid*/ 64 && t_value !== (t_value = (/*textIfInvalid*/ ctx[6] || '\xA0') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (77:32) 
function create_if_block_2$c(ctx) {
	let div;
	let t_value = (/*textIfValid*/ ctx[7] || '\xA0') + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "valid-text svelte-1diggri");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*textIfValid*/ 128 && t_value !== (t_value = (/*textIfValid*/ ctx[7] || '\xA0') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (75:4) {#if state === 'initial'}
function create_if_block_1$g(ctx) {
	let div;
	let t_value = (/*helperText*/ ctx[8] || '\xA0') + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "helper-text svelte-1diggri");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*helperText*/ 256 && t_value !== (t_value = (/*helperText*/ ctx[8] || '\xA0') + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

function create_fragment$I(ctx) {
	let div;
	let current_block_type_index;
	let if_block0;
	let t;
	let div_class_value;
	let current;
	const if_block_creators = [create_if_block_4$4, create_else_block$c];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*labelWrap*/ ctx[10]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block1 = (/*helperText*/ ctx[8] || /*textIfInvalid*/ ctx[6] || /*textIfValid*/ ctx[7]) && create_if_block$p(ctx);

	return {
		c() {
			div = element("div");
			if_block0.c();
			t = space();
			if (if_block1) if_block1.c();
			attr(div, "style", /*style*/ ctx[4]);
			attr(div, "class", div_class_value = "" + (null_to_empty(/*className*/ ctx[5]) + " svelte-1diggri"));
			toggle_class(div, "uk-margin-bottom", true);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if_blocks[current_block_type_index].m(div, null);
			append(div, t);
			if (if_block1) if_block1.m(div, null);
			/*div_binding*/ ctx[19](div);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block0 = if_blocks[current_block_type_index];

				if (!if_block0) {
					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block0.c();
				} else {
					if_block0.p(ctx, dirty);
				}

				transition_in(if_block0, 1);
				if_block0.m(div, t);
			}

			if (/*helperText*/ ctx[8] || /*textIfInvalid*/ ctx[6] || /*textIfValid*/ ctx[7]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$p(ctx);
					if_block1.c();
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (!current || dirty & /*style*/ 16) {
				attr(div, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*className*/ 32 && div_class_value !== (div_class_value = "" + (null_to_empty(/*className*/ ctx[5]) + " svelte-1diggri"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty & /*className*/ 32) {
				toggle_class(div, "uk-margin-bottom", true);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if_blocks[current_block_type_index].d();
			if (if_block1) if_block1.d();
			/*div_binding*/ ctx[19](null);
		}
	};
}

function instance$I($$self, $$props, $$invalidate) {
	let $globalOptionalMarker;
	let $globalRequiredMarker;
	component_subscribe($$self, globalOptionalMarker, $$value => $$invalidate(15, $globalOptionalMarker = $$value));
	component_subscribe($$self, globalRequiredMarker, $$value => $$invalidate(16, $globalRequiredMarker = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let { inputId } = $$props;
	let { hasIcon = false } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { optional = false } = $$props;
	let { state = "initial" } = $$props;
	let { labelWrap = false } = $$props;
	let { ref = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let suffix = '';

	function updateLabelSuffix() {
		if (optional) {
			$$invalidate(11, suffix = typeof optionalMarker === 'string'
			? optionalMarker
			: $globalOptionalMarker);
		} else {
			$$invalidate(11, suffix = typeof requiredMarker === 'string'
			? requiredMarker
			: $globalRequiredMarker);
		}
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('inputId' in $$props) $$invalidate(1, inputId = $$props.inputId);
		if ('hasIcon' in $$props) $$invalidate(2, hasIcon = $$props.hasIcon);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('className' in $$props) $$invalidate(5, className = $$props.className);
		if ('textIfInvalid' in $$props) $$invalidate(6, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(7, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(8, helperText = $$props.helperText);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('state' in $$props) $$invalidate(9, state = $$props.state);
		if ('labelWrap' in $$props) $$invalidate(10, labelWrap = $$props.labelWrap);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('requiredMarker' in $$props) $$invalidate(13, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(14, optionalMarker = $$props.optionalMarker);
		if ('$$scope' in $$props) $$invalidate(17, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*optional, requiredMarker, optionalMarker, $globalRequiredMarker, $globalOptionalMarker*/ 126976) {
			(updateLabelSuffix());
		}
	};

	return [
		ref,
		inputId,
		hasIcon,
		label,
		style,
		className,
		textIfInvalid,
		textIfValid,
		helperText,
		state,
		labelWrap,
		suffix,
		optional,
		requiredMarker,
		optionalMarker,
		$globalOptionalMarker,
		$globalRequiredMarker,
		$$scope,
		slots,
		div_binding
	];
}

class Field extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
			inputId: 1,
			hasIcon: 2,
			label: 3,
			style: 4,
			className: 5,
			textIfInvalid: 6,
			textIfValid: 7,
			helperText: 8,
			optional: 12,
			state: 9,
			labelWrap: 10,
			ref: 0,
			requiredMarker: 13,
			optionalMarker: 14
		});
	}
}

/* src/components/form/SearchInput.svelte generated by Svelte v4.2.19 */

function create_if_block_2$b(ctx) {
	let if_block_anchor;
	let if_block = /*icon*/ ctx[15] && create_if_block_3$6(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[15]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$6(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (89:4) {#if icon}
function create_if_block_3$6(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-form-icon");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[15]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 32768 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[15])) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (119:2) {#if iconPosition === 'right'}
function create_if_block$o(ctx) {
	let if_block_anchor;
	let if_block = /*icon*/ ctx[15] && create_if_block_1$f(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[15]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$f(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (120:4) {#if icon}
function create_if_block_1$f(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-form-icon right svelte-1whx3ya");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[15]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 32768 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[15])) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (75:0) <Field   hasIcon={!!icon}   inputId={id}   {requiredMarker}   {optionalMarker}   {label}   {state}   {style}   {className}   {textIfInvalid}   {textIfValid}   {helperText}   {optional}>
function create_default_slot$i(ctx) {
	let t0;
	let input;
	let input_required_value;
	let t1;
	let if_block1_anchor;
	let mounted;
	let dispose;
	let if_block0 = /*iconPosition*/ ctx[16] === 'left' && create_if_block_2$b(ctx);
	let if_block1 = /*iconPosition*/ ctx[16] === 'right' && create_if_block$o(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			input = element("input");
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(input, "minlength", /*minlength*/ ctx[23]);
			attr(input, "maxlength", /*maxlength*/ ctx[24]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[19]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[20]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[21]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[22]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "search");
			attr(input, "inputmode", /*inputmode*/ ctx[17]);
			attr(input, "pattern", /*pattern*/ ctx[18]);
			attr(input, "class", "uk-input svelte-1whx3ya");
			toggle_class(input, "paddingRight", /*iconPosition*/ ctx[16] === 'right');
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, input, anchor);
			/*input_binding*/ ctx[31](input);
			set_input_value(input, /*value*/ ctx[0]);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[32]),
					listen(input, "input", /*input_handler*/ ctx[27]),
					listen(input, "change", /*change_handler*/ ctx[28]),
					listen(input, "blur", /*blur_handler*/ ctx[29]),
					listen(input, "focus", /*focus_handler*/ ctx[30]),
					listen(input, "blur", /*blur_handler_1*/ ctx[33]),
					listen(input, "focus", /*focus_handler_1*/ ctx[34])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*iconPosition*/ ctx[16] === 'left') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$b(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*minlength*/ 8388608) {
				attr(input, "minlength", /*minlength*/ ctx[23]);
			}

			if (dirty[0] & /*maxlength*/ 16777216) {
				attr(input, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (dirty[0] & /*autocapitalize*/ 524288) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[19]);
			}

			if (dirty[0] & /*autocomplete*/ 1048576) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[20]);
			}

			if (dirty[0] & /*autocorrect*/ 2097152) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[21]);
			}

			if (dirty[0] & /*spellcheck*/ 4194304) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[22]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty[0] & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*inputmode*/ 131072) {
				attr(input, "inputmode", /*inputmode*/ ctx[17]);
			}

			if (dirty[0] & /*pattern*/ 262144) {
				attr(input, "pattern", /*pattern*/ ctx[18]);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*iconPosition*/ 65536) {
				toggle_class(input, "paddingRight", /*iconPosition*/ ctx[16] === 'right');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}

			if (/*iconPosition*/ ctx[16] === 'right') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$o(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(input);
				detach(t1);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			/*input_binding*/ ctx[31](null);
			if (if_block1) if_block1.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$H(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				hasIcon: !!/*icon*/ ctx[15],
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[25],
				optionalMarker: /*optionalMarker*/ ctx[26],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				style: /*style*/ ctx[5],
				className: /*className*/ ctx[6],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$i] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*icon*/ 32768) field_changes.hasIcon = !!/*icon*/ ctx[15];
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 33554432) field_changes.requiredMarker = /*requiredMarker*/ ctx[25];
			if (dirty[0] & /*optionalMarker*/ 67108864) field_changes.optionalMarker = /*optionalMarker*/ ctx[26];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty[0] & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty[0] & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*icon, iconPosition, minlength, maxlength, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, disabled, tooltip, optional, placeholder, inputmode, pattern, ref, value, state*/ 33552527 | dirty[1] & /*$$scope*/ 16) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$H($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { iconPosition = "left" } = $$props;
	let { inputmode = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('icon' in $$props) $$invalidate(15, icon = $$props.icon);
		if ('iconPosition' in $$props) $$invalidate(16, iconPosition = $$props.iconPosition);
		if ('inputmode' in $$props) $$invalidate(17, inputmode = $$props.inputmode);
		if ('pattern' in $$props) $$invalidate(18, pattern = $$props.pattern);
		if ('autocapitalize' in $$props) $$invalidate(19, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(20, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(21, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(22, spellcheck = $$props.spellcheck);
		if ('minlength' in $$props) $$invalidate(23, minlength = $$props.minlength);
		if ('maxlength' in $$props) $$invalidate(24, maxlength = $$props.maxlength);
		if ('requiredMarker' in $$props) $$invalidate(25, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(26, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		icon,
		iconPosition,
		inputmode,
		pattern,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		minlength,
		maxlength,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class SearchInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$H,
			create_fragment$H,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				style: 5,
				className: 6,
				name: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 1,
				disabled: 13,
				tooltip: 14,
				icon: 15,
				iconPosition: 16,
				inputmode: 17,
				pattern: 18,
				autocapitalize: 19,
				autocomplete: 20,
				autocorrect: 21,
				spellcheck: 22,
				minlength: 23,
				maxlength: 24,
				requiredMarker: 25,
				optionalMarker: 26,
				state: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/LoaderOverlayScoped.svelte generated by Svelte v4.2.19 */

function create_if_block$n(ctx) {
	let div2;
	let div0;
	let div0_style_value;
	let div0_class_value;
	let t0;
	let div1;
	let t1;
	let t2;
	let div2_class_value;
	let current;
	let if_block0 = (/*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'right') && create_if_block_2$a(ctx);
	const default_slot_template = /*#slots*/ ctx[11].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);
	let if_block1 = (/*slotPosition*/ ctx[9] === 'top' || /*slotPosition*/ ctx[9] === 'left') && create_if_block_1$e(ctx);

	return {
		c() {
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			attr(div0, "style", div0_style_value = "opacity: " + /*opacity*/ ctx[4] + "; " + (/*backgroundStyle*/ ctx[8] || ''));
			attr(div0, "class", div0_class_value = "" + (null_to_empty(/*backgroundClassName*/ ctx[7]) + " svelte-1ay30ik"));
			toggle_class(div0, "uk-background-muted", /*background*/ ctx[6] === 'muted');
			toggle_class(div0, "uk-background-default", /*background*/ ctx[6] === 'default');
			toggle_class(div0, "uk-background-primary", /*background*/ ctx[6] === 'primary');
			toggle_class(div0, "uk-background-secondary", /*background*/ ctx[6] === 'secondary');
			attr(div1, "class", "uk-flex uk-flex-middle uk-flex-center uk-flex svelte-1ay30ik");
			toggle_class(div1, "uk-flex-column", /*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'top');
			attr(div2, "class", div2_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-1ay30ik"));
			attr(div2, "style", /*style*/ ctx[3]);
			toggle_class(div2, "overlay", true);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div0);
			append(div2, t0);
			append(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			/*div2_binding*/ ctx[12](div2);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*opacity, backgroundStyle*/ 272 && div0_style_value !== (div0_style_value = "opacity: " + /*opacity*/ ctx[4] + "; " + (/*backgroundStyle*/ ctx[8] || ''))) {
				attr(div0, "style", div0_style_value);
			}

			if (!current || dirty & /*backgroundClassName*/ 128 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*backgroundClassName*/ ctx[7]) + " svelte-1ay30ik"))) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-muted", /*background*/ ctx[6] === 'muted');
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-default", /*background*/ ctx[6] === 'default');
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-primary", /*background*/ ctx[6] === 'primary');
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-secondary", /*background*/ ctx[6] === 'secondary');
			}

			if (/*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'right') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*slotPosition*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$a(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[10],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
						null
					);
				}
			}

			if (/*slotPosition*/ ctx[9] === 'top' || /*slotPosition*/ ctx[9] === 'left') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*slotPosition*/ 512) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$e(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*slotPosition*/ 512) {
				toggle_class(div1, "uk-flex-column", /*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'top');
			}

			if (!current || dirty & /*className*/ 2 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-1ay30ik"))) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*style*/ 8) {
				attr(div2, "style", /*style*/ ctx[3]);
			}

			if (!current || dirty & /*className*/ 2) {
				toggle_class(div2, "overlay", true);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div2);
			}

			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			/*div2_binding*/ ctx[12](null);
		}
	};
}

// (60:8) {#if slotPosition === 'bottom' || slotPosition === 'right'}
function create_if_block_2$a(ctx) {
	let loader;
	let current;
	loader = new Loader({ props: { ratio: /*ratio*/ ctx[2] } });

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const loader_changes = {};
			if (dirty & /*ratio*/ 4) loader_changes.ratio = /*ratio*/ ctx[2];
			loader.$set(loader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

// (64:8) {#if slotPosition === 'top' || slotPosition === 'left'}
function create_if_block_1$e(ctx) {
	let loader;
	let current;
	loader = new Loader({ props: { ratio: /*ratio*/ ctx[2] } });

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const loader_changes = {};
			if (dirty & /*ratio*/ 4) loader_changes.ratio = /*ratio*/ ctx[2];
			loader.$set(loader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

function create_fragment$G(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*loading*/ ctx[5] && create_if_block$n(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*loading*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*loading*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$n(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$G($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { className = undefined } = $$props;
	let { ratio = 1 } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { opacity = 0.8 } = $$props;
	let { loading = true } = $$props;
	let { background = 'default' } = $$props;
	let { backgroundClassName = undefined } = $$props;
	let { backgroundStyle = undefined } = $$props;
	let { slotPosition = "bottom" } = $$props;

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('ratio' in $$props) $$invalidate(2, ratio = $$props.ratio);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('opacity' in $$props) $$invalidate(4, opacity = $$props.opacity);
		if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
		if ('background' in $$props) $$invalidate(6, background = $$props.background);
		if ('backgroundClassName' in $$props) $$invalidate(7, backgroundClassName = $$props.backgroundClassName);
		if ('backgroundStyle' in $$props) $$invalidate(8, backgroundStyle = $$props.backgroundStyle);
		if ('slotPosition' in $$props) $$invalidate(9, slotPosition = $$props.slotPosition);
		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
	};

	return [
		ref,
		className,
		ratio,
		style,
		opacity,
		loading,
		background,
		backgroundClassName,
		backgroundStyle,
		slotPosition,
		$$scope,
		slots,
		div2_binding
	];
}

class LoaderOverlayScoped extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$G, create_fragment$G, safe_not_equal, {
			className: 1,
			ratio: 2,
			style: 3,
			ref: 0,
			opacity: 4,
			loading: 5,
			background: 6,
			backgroundClassName: 7,
			backgroundStyle: 8,
			slotPosition: 9
		});
	}
}

/* src/components/Pagination.svelte generated by Svelte v4.2.19 */

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[16] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[18] = i;
	return child_ctx;
}

// (28:1) {:else}
function create_else_block_4(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			li.innerHTML = `<span><span uk-pagination-previous=""></span></span>`;
			attr(li, "class", "uk-disabled");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (25:1) {#if pageIndex > 0}
function create_if_block_7$2(ctx) {
	let li;
	let a;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			a = element("a");
			a.innerHTML = `<span uk-pagination-previous=""></span>`;
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);

			if (!mounted) {
				dispose = [
					listen(a, "keyup", /*keyup_handler*/ ctx[7]),
					listen(a, "click", /*click_handler*/ ctx[8])
				];

				mounted = true;
			}
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (34:2) {:else}
function create_else_block_3$1(ctx) {
	let li;
	let a;
	let mounted;
	let dispose;

	function keyup_handler_1(...args) {
		return /*keyup_handler_1*/ ctx[9](/*index*/ ctx[18], ...args);
	}

	function click_handler_1() {
		return /*click_handler_1*/ ctx[10](/*index*/ ctx[18]);
	}

	return {
		c() {
			li = element("li");
			a = element("a");
			a.textContent = `${/*index*/ ctx[18] + 1}`;
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);

			if (!mounted) {
				dispose = [listen(a, "keyup", keyup_handler_1), listen(a, "click", click_handler_1)];
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (32:2) {#if index === pageIndex}
function create_if_block_6$3(ctx) {
	let li;
	let span;

	return {
		c() {
			li = element("li");
			span = element("span");
			span.textContent = `${/*index*/ ctx[18] + 1}`;
			attr(li, "class", "uk-active");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, span);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (31:1) {#each new Array(Math.min(numbersPerSide, numberOfPages)).fill(0) as _, index}
function create_each_block_1$3(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*index*/ ctx[18] === /*pageIndex*/ ctx[3]) return create_if_block_6$3;
		return create_else_block_3$1;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_block.d(detaching);
		}
	};
}

// (39:1) {#if numberOfPages > numbersPerSide * 2}
function create_if_block_2$9(ctx) {
	let if_block_anchor;

	function select_block_type_2(ctx, dirty) {
		if (/*pageIndex*/ ctx[3] + 1 > /*numbersPerSide*/ ctx[5] && /*pageIndex*/ ctx[3] + 1 < /*numberOfPages*/ ctx[4] - /*numbersPerSide*/ ctx[5] + 1) return create_if_block_3$5;
		return create_else_block_2$1;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_block.d(detaching);
		}
	};
}

// (48:2) {:else}
function create_else_block_2$1(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			li.innerHTML = `<span>..</span>`;
			attr(li, "class", "uk-disabled");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (40:2) {#if pageIndex + 1 > numbersPerSide && pageIndex + 1 < numberOfPages - numbersPerSide + 1}
function create_if_block_3$5(ctx) {
	let t0;
	let li;
	let span;
	let t1_value = /*pageIndex*/ ctx[3] + 1 + "";
	let t1;
	let t2;
	let if_block1_anchor;
	let if_block0 = /*pageIndex*/ ctx[3] + 1 > /*numbersPerSide*/ ctx[5] + 1 && create_if_block_5$3();
	let if_block1 = /*pageIndex*/ ctx[3] + 1 < /*numberOfPages*/ ctx[4] - /*numbersPerSide*/ ctx[5] && create_if_block_4$3();

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			li = element("li");
			span = element("span");
			t1 = text(t1_value);
			t2 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(li, "class", "uk-active");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, li, anchor);
			append(li, span);
			append(span, t1);
			insert(target, t2, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*pageIndex*/ ctx[3] + 1 > /*numbersPerSide*/ ctx[5] + 1) {
				if (if_block0) ; else {
					if_block0 = create_if_block_5$3();
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*pageIndex*/ 8 && t1_value !== (t1_value = /*pageIndex*/ ctx[3] + 1 + "")) set_data(t1, t1_value);

			if (/*pageIndex*/ ctx[3] + 1 < /*numberOfPages*/ ctx[4] - /*numbersPerSide*/ ctx[5]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_4$3();
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(li);
				detach(t2);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d(detaching);
		}
	};
}

// (41:3) {#if pageIndex + 1 > numbersPerSide + 1}
function create_if_block_5$3(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			li.innerHTML = `<span>..</span>`;
			attr(li, "class", "uk-disabled");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (45:3) {#if pageIndex + 1 < numberOfPages - numbersPerSide}
function create_if_block_4$3(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			li.innerHTML = `<span>..</span>`;
			attr(li, "class", "uk-disabled");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (55:2) {:else}
function create_else_block_1$4(ctx) {
	let li;
	let a;
	let t_value = /*offset*/ ctx[16] + /*index*/ ctx[18] + 1 + "";
	let t;
	let mounted;
	let dispose;

	function keyup_handler_2(...args) {
		return /*keyup_handler_2*/ ctx[11](/*offset*/ ctx[16], /*index*/ ctx[18], ...args);
	}

	function click_handler_2() {
		return /*click_handler_2*/ ctx[12](/*offset*/ ctx[16], /*index*/ ctx[18]);
	}

	return {
		c() {
			li = element("li");
			a = element("a");
			t = text(t_value);
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			append(a, t);

			if (!mounted) {
				dispose = [listen(a, "keyup", keyup_handler_2), listen(a, "click", click_handler_2)];
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*numbersPerSide, numberOfPages*/ 48 && t_value !== (t_value = /*offset*/ ctx[16] + /*index*/ ctx[18] + 1 + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (53:2) {#if offset + index === pageIndex}
function create_if_block_1$d(ctx) {
	let li;
	let span;
	let t_value = /*offset*/ ctx[16] + /*index*/ ctx[18] + 1 + "";
	let t;

	return {
		c() {
			li = element("li");
			span = element("span");
			t = text(t_value);
			attr(li, "class", "uk-active");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, span);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*numbersPerSide, numberOfPages*/ 48 && t_value !== (t_value = /*offset*/ ctx[16] + /*index*/ ctx[18] + 1 + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (52:1) {#each new Array(Math.min(numbersPerSide, Math.max(0, numberOfPages - numbersPerSide))).fill(Math.max(numbersPerSide, numberOfPages - numbersPerSide)) as offset, index}
function create_each_block$a(ctx) {
	let if_block_anchor;

	function select_block_type_3(ctx, dirty) {
		if (/*offset*/ ctx[16] + /*index*/ ctx[18] === /*pageIndex*/ ctx[3]) return create_if_block_1$d;
		return create_else_block_1$4;
	}

	let current_block_type = select_block_type_3(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_3(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_block.d(detaching);
		}
	};
}

// (63:1) {:else}
function create_else_block$b(ctx) {
	let li;

	return {
		c() {
			li = element("li");
			li.innerHTML = `<span><span uk-pagination-next=""></span></span>`;
			attr(li, "class", "uk-disabled");
		},
		m(target, anchor) {
			insert(target, li, anchor);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (60:1) {#if pageIndex + 1 < numberOfPages}
function create_if_block$m(ctx) {
	let li;
	let a;
	let mounted;
	let dispose;

	return {
		c() {
			li = element("li");
			a = element("a");
			a.innerHTML = `<span uk-pagination-next=""></span>`;
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);

			if (!mounted) {
				dispose = [
					listen(a, "keyup", /*keyup_handler_3*/ ctx[13]),
					listen(a, "click", /*click_handler_3*/ ctx[14])
				];

				mounted = true;
			}
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$F(ctx) {
	let ul;
	let t0;
	let t1;
	let t2;
	let t3;

	function select_block_type(ctx, dirty) {
		if (/*pageIndex*/ ctx[3] > 0) return create_if_block_7$2;
		return create_else_block_4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);
	let each_value_1 = ensure_array_like(new Array(Math.min(/*numbersPerSide*/ ctx[5], /*numberOfPages*/ ctx[4])).fill(0));
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	}

	let if_block1 = /*numberOfPages*/ ctx[4] > /*numbersPerSide*/ ctx[5] * 2 && create_if_block_2$9(ctx);
	let each_value = ensure_array_like(new Array(Math.min(/*numbersPerSide*/ ctx[5], Math.max(0, /*numberOfPages*/ ctx[4] - /*numbersPerSide*/ ctx[5]))).fill(Math.max(/*numbersPerSide*/ ctx[5], /*numberOfPages*/ ctx[4] - /*numbersPerSide*/ ctx[5])));
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	}

	function select_block_type_4(ctx, dirty) {
		if (/*pageIndex*/ ctx[3] + 1 < /*numberOfPages*/ ctx[4]) return create_if_block$m;
		return create_else_block$b;
	}

	let current_block_type_1 = select_block_type_4(ctx);
	let if_block2 = current_block_type_1(ctx);

	return {
		c() {
			ul = element("ul");
			if_block0.c();
			t0 = space();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t3 = space();
			if_block2.c();
			attr(ul, "class", /*className*/ ctx[0]);
			attr(ul, "style", /*style*/ ctx[1]);
			toggle_class(ul, "uk-pagination", true);
			toggle_class(ul, "uk-margin", true);
			toggle_class(ul, "uk-flex-center", /*center*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, ul, anchor);
			if_block0.m(ul, null);
			append(ul, t0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(ul, null);
				}
			}

			append(ul, t1);
			if (if_block1) if_block1.m(ul, null);
			append(ul, t2);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			append(ul, t3);
			if_block2.m(ul, null);
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(ul, t0);
				}
			}

			if (dirty & /*pageIndex, goToIndex, numbersPerSide, numberOfPages*/ 120) {
				each_value_1 = ensure_array_like(new Array(Math.min(/*numbersPerSide*/ ctx[5], /*numberOfPages*/ ctx[4])).fill(0));
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_1$3(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(ul, t1);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_1.length;
			}

			if (/*numberOfPages*/ ctx[4] > /*numbersPerSide*/ ctx[5] * 2) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$9(ctx);
					if_block1.c();
					if_block1.m(ul, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty & /*Array, Math, numbersPerSide, numberOfPages, pageIndex, goToIndex*/ 120) {
				each_value = ensure_array_like(new Array(Math.min(/*numbersPerSide*/ ctx[5], Math.max(0, /*numberOfPages*/ ctx[4] - /*numbersPerSide*/ ctx[5]))).fill(Math.max(/*numbersPerSide*/ ctx[5], /*numberOfPages*/ ctx[4] - /*numbersPerSide*/ ctx[5])));
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$a(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$a(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, t3);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_4(ctx)) && if_block2) {
				if_block2.p(ctx, dirty);
			} else {
				if_block2.d(1);
				if_block2 = current_block_type_1(ctx);

				if (if_block2) {
					if_block2.c();
					if_block2.m(ul, null);
				}
			}

			if (dirty & /*className*/ 1) {
				attr(ul, "class", /*className*/ ctx[0]);
			}

			if (dirty & /*style*/ 2) {
				attr(ul, "style", /*style*/ ctx[1]);
			}

			if (dirty & /*className*/ 1) {
				toggle_class(ul, "uk-pagination", true);
			}

			if (dirty & /*className*/ 1) {
				toggle_class(ul, "uk-margin", true);
			}

			if (dirty & /*className, center*/ 5) {
				toggle_class(ul, "uk-flex-center", /*center*/ ctx[2]);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(ul);
			}

			if_block0.d();
			destroy_each(each_blocks_1, detaching);
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			if_block2.d();
		}
	};
}

function instance$F($$self, $$props, $$invalidate) {
	let { className = "" } = $$props;
	let { style = undefined } = $$props;
	let { center = true } = $$props;
	let { pageIndex = 0 } = $$props;
	let { numberOfPages = 0 } = $$props;
	let { numbersPerSide = 4 } = $$props;
	const dispatch = createEventDispatcher();

	function goToIndex(index) {
		dispatch('page-click', index);
	}

	const keyup_handler = e => ['Enter'].includes(e.code) && goToIndex(pageIndex - 1);
	const click_handler = () => goToIndex(pageIndex - 1);
	const keyup_handler_1 = (index, e) => ['Enter'].includes(e.code) && goToIndex(index);
	const click_handler_1 = index => goToIndex(index);
	const keyup_handler_2 = (offset, index, e) => ['Enter'].includes(e.code) && goToIndex(offset + index);
	const click_handler_2 = (offset, index) => goToIndex(offset + index);
	const keyup_handler_3 = e => ['Enter'].includes(e.code) && goToIndex(pageIndex + 1);
	const click_handler_3 = () => goToIndex(pageIndex + 1);

	$$self.$$set = $$props => {
		if ('className' in $$props) $$invalidate(0, className = $$props.className);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('center' in $$props) $$invalidate(2, center = $$props.center);
		if ('pageIndex' in $$props) $$invalidate(3, pageIndex = $$props.pageIndex);
		if ('numberOfPages' in $$props) $$invalidate(4, numberOfPages = $$props.numberOfPages);
		if ('numbersPerSide' in $$props) $$invalidate(5, numbersPerSide = $$props.numbersPerSide);
	};

	return [
		className,
		style,
		center,
		pageIndex,
		numberOfPages,
		numbersPerSide,
		goToIndex,
		keyup_handler,
		click_handler,
		keyup_handler_1,
		click_handler_1,
		keyup_handler_2,
		click_handler_2,
		keyup_handler_3,
		click_handler_3
	];
}

class Pagination extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$F, create_fragment$F, safe_not_equal, {
			className: 0,
			style: 1,
			center: 2,
			pageIndex: 3,
			numberOfPages: 4,
			numbersPerSide: 5
		});
	}
}

const sleep = (ms) => new Promise((res) => setTimeout(() => res(), ms));

/* src/components/AsyncDataTable.svelte generated by Svelte v4.2.19 */

const { window: window_1 } = globals;

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[62] = list[i];
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[65] = list[i];
	return child_ctx;
}

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[65] = list[i];
	return child_ctx;
}

// (221:0) {#if columns.some((c) => c.searchable !== false)}
function create_if_block_9(ctx) {
	let form;
	let current_block_type_index;
	let if_block;
	let t;
	let button;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block_10, create_else_block_3];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*instantSearch*/ ctx[16]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	button = new Button({
			props: {
				type: "search",
				icon: "search",
				variant: /*searchButtonVariant*/ ctx[12],
				className: "uk-padding-small uk-padding-remove-vertical uk-margin-bottom"
			}
		});

	button.$on("click", /*click_handler*/ ctx[40]);

	return {
		c() {
			form = element("form");
			if_block.c();
			t = space();
			create_component(button.$$.fragment);
			attr(form, "class", "uk-flex uk-width-1-1 custom-uk-data-table-form");
		},
		m(target, anchor) {
			insert(target, form, anchor);
			if_blocks[current_block_type_index].m(form, null);
			append(form, t);
			mount_component(button, form, null);
			current = true;

			if (!mounted) {
				dispose = listen(form, "submit", prevent_default(/*submit_handler*/ ctx[41]));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(form, t);
			}

			const button_changes = {};
			if (dirty[0] & /*searchButtonVariant*/ 4096) button_changes.variant = /*searchButtonVariant*/ ctx[12];
			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(form);
			}

			if_blocks[current_block_type_index].d();
			destroy_component(button);
			mounted = false;
			dispose();
		}
	};
}

// (247:2) {:else}
function create_else_block_3(ctx) {
	let searchinput;
	let updating_ref;
	let current;

	function searchinput_ref_binding_1(value) {
		/*searchinput_ref_binding_1*/ ctx[39](value);
	}

	let searchinput_props = {
		className: "uk-width-expand",
		placeholder: /*placeholder*/ ctx[14],
		value: /*query*/ ctx[0],
		optional: true
	};

	if (/*searchInput*/ ctx[21] !== void 0) {
		searchinput_props.ref = /*searchInput*/ ctx[21];
	}

	searchinput = new SearchInput({ props: searchinput_props });
	binding_callbacks.push(() => bind(searchinput, 'ref', searchinput_ref_binding_1));

	return {
		c() {
			create_component(searchinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(searchinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const searchinput_changes = {};
			if (dirty[0] & /*placeholder*/ 16384) searchinput_changes.placeholder = /*placeholder*/ ctx[14];
			if (dirty[0] & /*query*/ 1) searchinput_changes.value = /*query*/ ctx[0];

			if (!updating_ref && dirty[0] & /*searchInput*/ 2097152) {
				updating_ref = true;
				searchinput_changes.ref = /*searchInput*/ ctx[21];
				add_flush_callback(() => updating_ref = false);
			}

			searchinput.$set(searchinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(searchinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(searchinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(searchinput, detaching);
		}
	};
}

// (233:2) {#if instantSearch}
function create_if_block_10(ctx) {
	let searchinput;
	let updating_ref;
	let updating_value;
	let current;

	function searchinput_ref_binding(value) {
		/*searchinput_ref_binding*/ ctx[36](value);
	}

	function searchinput_value_binding(value) {
		/*searchinput_value_binding*/ ctx[37](value);
	}

	let searchinput_props = {
		className: "uk-width-expand",
		placeholder: /*placeholder*/ ctx[14],
		optional: true
	};

	if (/*searchInput*/ ctx[21] !== void 0) {
		searchinput_props.ref = /*searchInput*/ ctx[21];
	}

	if (/*query*/ ctx[0] !== void 0) {
		searchinput_props.value = /*query*/ ctx[0];
	}

	searchinput = new SearchInput({ props: searchinput_props });
	binding_callbacks.push(() => bind(searchinput, 'ref', searchinput_ref_binding));
	binding_callbacks.push(() => bind(searchinput, 'value', searchinput_value_binding));
	searchinput.$on("input", /*input_handler*/ ctx[38]);

	return {
		c() {
			create_component(searchinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(searchinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const searchinput_changes = {};
			if (dirty[0] & /*placeholder*/ 16384) searchinput_changes.placeholder = /*placeholder*/ ctx[14];

			if (!updating_ref && dirty[0] & /*searchInput*/ 2097152) {
				updating_ref = true;
				searchinput_changes.ref = /*searchInput*/ ctx[21];
				add_flush_callback(() => updating_ref = false);
			}

			if (!updating_value && dirty[0] & /*query*/ 1) {
				updating_value = true;
				searchinput_changes.value = /*query*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			searchinput.$set(searchinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(searchinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(searchinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(searchinput, detaching);
		}
	};
}

// (319:41) 
function create_if_block_8(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			set_style(span, "visibility", "hidden");
			attr(span, "class", "uk-icon");
			attr(span, "uk-icon", "icon: chevron-down");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (317:105) 
function create_if_block_7$1(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-icon");
			attr(span, "uk-icon", "icon: chevron-down");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (315:7) {#if col.orderable !== false && orderBy.find((o) => o.key === col.key)?.direction === "asc"}
function create_if_block_6$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-icon");
			attr(span, "uk-icon", "icon: chevron-up");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (285:5) {#each columns as col (col)}
function create_each_block_2(key_1, ctx) {
	let th;
	let t0_value = /*col*/ ctx[65].label + "";
	let t0;
	let t1;
	let show_if;
	let show_if_1;
	let t2;
	let mounted;
	let dispose;

	function func(...args) {
		return /*func*/ ctx[33](/*col*/ ctx[65], ...args);
	}

	function func_1(...args) {
		return /*func_1*/ ctx[34](/*col*/ ctx[65], ...args);
	}

	function select_block_type_1(ctx, dirty) {
		if (dirty[0] & /*columns, orderBy*/ 130) show_if = null;
		if (dirty[0] & /*columns, orderBy*/ 130) show_if_1 = null;
		if (show_if == null) show_if = !!(/*col*/ ctx[65].orderable !== false && /*orderBy*/ ctx[1].find(func)?.direction === "asc");
		if (show_if) return create_if_block_6$2;
		if (show_if_1 == null) show_if_1 = !!(/*col*/ ctx[65].orderable !== false && /*orderBy*/ ctx[1].find(func_1)?.direction === "desc");
		if (show_if_1) return create_if_block_7$1;
		if (/*col*/ ctx[65].orderable !== false) return create_if_block_8;
	}

	let current_block_type = select_block_type_1(ctx, [-1, -1, -1]);
	let if_block = current_block_type && current_block_type(ctx);

	function click_handler_1(...args) {
		return /*click_handler_1*/ ctx[42](/*col*/ ctx[65], ...args);
	}

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[43](/*col*/ ctx[65], ...args);
	}

	function contextmenu_handler(...args) {
		return /*contextmenu_handler*/ ctx[44](/*col*/ ctx[65], ...args);
	}

	function func_3(...args) {
		return /*func_3*/ ctx[45](/*col*/ ctx[65], ...args);
	}

	return {
		key: key_1,
		first: null,
		c() {
			th = element("th");
			t0 = text(t0_value);
			t1 = space();
			if (if_block) if_block.c();
			t2 = space();
			attr(th, "tabindex", "0");
			set_style(th, "text-align", /*col*/ ctx[65].textAlign || 'left');
			toggle_class(th, "sticky", /*stickyHeader*/ ctx[13]);
			toggle_class(th, "descending", Object.keys(/*orderBy*/ ctx[1]).some(func_3));
			toggle_class(th, "orderable", /*col*/ ctx[65].orderable !== false);
			this.first = th;
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, t0);
			append(th, t1);
			if (if_block) if_block.m(th, null);
			append(th, t2);

			if (!mounted) {
				dispose = [
					listen(th, "click", click_handler_1),
					listen(th, "keyup", keyup_handler),
					listen(th, "contextmenu", contextmenu_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*columns*/ 128 && t0_value !== (t0_value = /*col*/ ctx[65].label + "")) set_data(t0, t0_value);

			if (current_block_type !== (current_block_type = select_block_type_1(ctx, dirty))) {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(th, t2);
				}
			}

			if (dirty[0] & /*columns*/ 128) {
				set_style(th, "text-align", /*col*/ ctx[65].textAlign || 'left');
			}

			if (dirty[0] & /*stickyHeader*/ 8192) {
				toggle_class(th, "sticky", /*stickyHeader*/ ctx[13]);
			}

			if (dirty[0] & /*orderBy, columns*/ 130) {
				toggle_class(th, "descending", Object.keys(/*orderBy*/ ctx[1]).some(func_3));
			}

			if (dirty[0] & /*columns*/ 128) {
				toggle_class(th, "orderable", /*col*/ ctx[65].orderable !== false);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(th);
			}

			if (if_block) {
				if_block.d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (344:4) {:else}
function create_else_block$a(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let current;
	let each_value = ensure_array_like(/*rows*/ ctx[6]);
	const get_key = ctx => /*row*/ ctx[62];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$9(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty[0] & /*dispatch, rows, columns*/ 16777408) {
				each_value = ensure_array_like(/*rows*/ ctx[6]);
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$9, each_1_anchor, get_each_context$9);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}
		}
	};
}

// (335:48) 
function create_if_block_2$8(ctx) {
	let tr;
	let td;
	let t;
	let td_colspan_value;

	return {
		c() {
			tr = element("tr");
			td = element("td");
			t = text(/*noResultText*/ ctx[15]);
			attr(td, "colspan", td_colspan_value = /*columns*/ ctx[7].length);
			set_style(td, "font-style", "italic");
			set_style(td, "text-align", "center");
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td);
			append(td, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*noResultText*/ 32768) set_data(t, /*noResultText*/ ctx[15]);

			if (dirty[0] & /*columns*/ 128 && td_colspan_value !== (td_colspan_value = /*columns*/ ctx[7].length)) {
				attr(td, "colspan", td_colspan_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(tr);
			}
		}
	};
}

// (331:4) {#if !rows}
function create_if_block_1$c(ctx) {
	let tr;
	let td;
	let td_colspan_value;

	return {
		c() {
			tr = element("tr");
			td = element("td");
			attr(td, "colspan", td_colspan_value = /*columns*/ ctx[7].length);
			toggle_class(td, "uk-text-center", true);
		},
		m(target, anchor) {
			insert(target, tr, anchor);
			append(tr, td);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*columns*/ 128 && td_colspan_value !== (td_colspan_value = /*columns*/ ctx[7].length)) {
				attr(td, "colspan", td_colspan_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(tr);
			}
		}
	};
}

// (388:9) {:else}
function create_else_block_2(ctx) {
	let t_value = (/*col*/ ctx[65].rendered || "") + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*columns, rows*/ 192 && t_value !== (t_value = (/*col*/ ctx[65].rendered || "") + "")) set_data(t, t_value);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (360:68) 
function create_if_block_4$2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5$2, create_else_block_1$3];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*col*/ ctx[65].rendered.textContent) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_4(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (358:9) {#if !col.render}
function create_if_block_3$4(ctx) {
	let t_value = /*row*/ ctx[62][/*col*/ ctx[65].key] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rows, columns*/ 192 && t_value !== (t_value = /*row*/ ctx[62][/*col*/ ctx[65].key] + "")) set_data(t, t_value);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (375:10) {:else}
function create_else_block_1$3(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*col*/ ctx[65].rendered.props || {}];

	function click_handler_3(...args) {
		return /*click_handler_3*/ ctx[48](/*col*/ ctx[65], ...args);
	}

	var switch_value = /*col*/ ctx[65].rendered.component;

	function switch_props(ctx, dirty) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		if (dirty !== undefined && dirty[0] & /*columns, rows*/ 192) {
			switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*col*/ ctx[65].rendered.props || {})]));
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		switch_instance.$on("click", click_handler_3);
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*columns, rows*/ 192 && switch_value !== (switch_value = /*col*/ ctx[65].rendered.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
					switch_instance.$on("click", click_handler_3);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = (dirty[0] & /*columns, rows*/ 192)
				? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*col*/ ctx[65].rendered.props || {})])
				: {};

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (361:10) {#if col.rendered.textContent}
function create_if_block_5$2(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*col*/ ctx[65].rendered.props || {}];

	function click_handler_2(...args) {
		return /*click_handler_2*/ ctx[47](/*col*/ ctx[65], ...args);
	}

	var switch_value = /*col*/ ctx[65].rendered.component;

	function switch_props(ctx, dirty) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$h] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		if (dirty !== undefined && dirty[0] & /*columns, rows*/ 192) {
			switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*col*/ ctx[65].rendered.props || {})]));
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
		switch_instance.$on("click", click_handler_2);
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*columns, rows*/ 192 && switch_value !== (switch_value = /*col*/ ctx[65].rendered.component)) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
					switch_instance.$on("click", click_handler_2);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = (dirty[0] & /*columns, rows*/ 192)
				? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*col*/ ctx[65].rendered.props || {})])
				: {};

				if (dirty[0] & /*columns, rows*/ 192 | dirty[2] & /*$$scope*/ 256) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (362:11) <svelte:component             this={col.rendered.component}             {...col.rendered.props || {}}             on:click={(e) => {              const onClick = col.rendered.onClick;              if (onClick) {               e.stopPropagation();               onClick(e);              }             }}            >
function create_default_slot$h(ctx) {
	let t_value = /*col*/ ctx[65].rendered.textContent + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*columns, rows*/ 192 && t_value !== (t_value = /*col*/ ctx[65].rendered.textContent + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (353:7) {#each columns.map( (col) => ({ ...col, rendered: col.render && col.render(row[col.key], row) }) ) as col (col)}
function create_each_block_1$2(key_1, ctx) {
	let td;
	let current_block_type_index;
	let if_block;
	let td_class_value;
	let current;
	const if_block_creators = [create_if_block_3$4, create_if_block_4$2, create_else_block_2];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (!/*col*/ ctx[65].render) return 0;
		if (/*col*/ ctx[65].rendered && typeof /*col*/ ctx[65].rendered === "object") return 1;
		return 2;
	}

	current_block_type_index = select_block_type_3(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			td = element("td");
			if_block.c();
			attr(td, "class", td_class_value = /*col*/ ctx[65].className);
			set_style(td, "text-align", /*col*/ ctx[65].textAlign || 'left');
			this.first = td;
		},
		m(target, anchor) {
			insert(target, td, anchor);
			if_blocks[current_block_type_index].m(td, null);
			current = true;
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(td, null);
			}

			if (!current || dirty[0] & /*columns, rows*/ 192 && td_class_value !== (td_class_value = /*col*/ ctx[65].className)) {
				attr(td, "class", td_class_value);
			}

			if (!current || dirty[0] & /*columns, rows*/ 192) {
				set_style(td, "text-align", /*col*/ ctx[65].textAlign || 'left');
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(td);
			}

			if_blocks[current_block_type_index].d();
		}
	};
}

// (345:5) {#each rows as row (row)}
function create_each_block$9(key_1, ctx) {
	let tr;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let current;
	let mounted;
	let dispose;

	function func_4(...args) {
		return /*func_4*/ ctx[46](/*row*/ ctx[62], ...args);
	}

	let each_value_1 = ensure_array_like(/*columns*/ ctx[7].map(func_4));
	const get_key = ctx => /*col*/ ctx[65];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$2(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$2(key, child_ctx));
	}

	function keyup_handler_1(...args) {
		return /*keyup_handler_1*/ ctx[49](/*row*/ ctx[62], ...args);
	}

	function dblclick_handler() {
		return /*dblclick_handler*/ ctx[50](/*row*/ ctx[62]);
	}

	function click_handler_4() {
		return /*click_handler_4*/ ctx[51](/*row*/ ctx[62]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			attr(tr, "tabindex", "0");
			this.first = tr;
		},
		m(target, anchor) {
			insert(target, tr, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(tr, null);
				}
			}

			append(tr, t);
			current = true;

			if (!mounted) {
				dispose = [
					listen(tr, "keyup", keyup_handler_1),
					listen(tr, "dblclick", dblclick_handler),
					listen(tr, "click", click_handler_4)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*columns, rows*/ 192) {
				each_value_1 = ensure_array_like(/*columns*/ ctx[7].map(func_4));
				group_outros();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, tr, outro_and_destroy_block, create_each_block_1$2, t, get_each_context_1$2);
				check_outros();
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(tr);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (396:2) {#if loading}
function create_if_block$l(ctx) {
	let div;
	let loaderoverlayscoped;
	let div_style_value;
	let current;
	loaderoverlayscoped = new LoaderOverlayScoped({ props: { opacity: 0.2 } });

	return {
		c() {
			div = element("div");
			create_component(loaderoverlayscoped.$$.fragment);
			attr(div, "style", div_style_value = `position: absolute; left: 0; right: 0; height: ${/*loaderHeight*/ ctx[23]}px; top: ${/*loaderTop*/ ctx[22]}px; z-index: 999999`);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(loaderoverlayscoped, div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty[0] & /*loaderHeight, loaderTop*/ 12582912 && div_style_value !== (div_style_value = `position: absolute; left: 0; right: 0; height: ${/*loaderHeight*/ ctx[23]}px; top: ${/*loaderTop*/ ctx[22]}px; z-index: 999999`)) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(loaderoverlayscoped.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loaderoverlayscoped.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(loaderoverlayscoped);
		}
	};
}

function create_fragment$E(ctx) {
	let show_if = /*columns*/ ctx[7].some(func_2);
	let t0;
	let div1;
	let div0;
	let table;
	let thead;
	let tr;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t1;
	let tbody;
	let current_block_type_index;
	let if_block1;
	let tbody_resize_listener;
	let t2;
	let t3;
	let pagination;
	let current;
	let mounted;
	let dispose;
	let if_block0 = show_if && create_if_block_9(ctx);
	let each_value_2 = ensure_array_like(/*columns*/ ctx[7]);
	const get_key = ctx => /*col*/ ctx[65];

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
	}

	const if_block_creators = [create_if_block_1$c, create_if_block_2$8, create_else_block$a];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (!/*rows*/ ctx[6]) return 0;
		if (/*rows*/ ctx[6].length === 0 && /*noResultText*/ ctx[15]) return 1;
		return 2;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	let if_block2 = /*loading*/ ctx[5] && create_if_block$l(ctx);

	pagination = new Pagination({
			props: {
				center: true,
				numberOfPages: Math.ceil(/*filtered*/ ctx[4] / /*recordsPerPage*/ ctx[18]),
				pageIndex: /*pageIndex*/ ctx[2],
				numbersPerSide: /*numbersPerSide*/ ctx[19]
			}
		});

	pagination.$on("page-click", /*page_click_handler*/ ctx[54]);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			table = element("table");
			thead = element("thead");
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			tbody = element("tbody");
			if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			t3 = space();
			create_component(pagination.$$.fragment);
			add_render_callback(() => /*tbody_elementresize_handler*/ ctx[52].call(tbody));
			toggle_class(tbody, "inhibit", /*loading*/ ctx[5]);
			attr(table, "style", /*style*/ ctx[10]);
			attr(table, "class", /*className*/ ctx[9]);
			toggle_class(table, "uk-margin-remove", true);
			toggle_class(table, "uk-table", true);
			toggle_class(table, "uk-table-middle", true);
			toggle_class(table, "uk-table-hover", true);
			toggle_class(table, "uk-table-striped", /*appearance*/ ctx[11] === "striped");
			toggle_class(table, "uk-table-divider", /*appearance*/ ctx[11] === "divider");
			toggle_class(table, "uk-table-small", /*size*/ ctx[8] === "small");
			attr(div0, "class", "custom-uk-data-table-table-wrapper");
			toggle_class(div0, "table-hscroll-wrapper", /*horizontalScroll*/ ctx[17]);
			set_style(div1, "position", "relative");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, table);
			append(table, thead);
			append(thead, tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(tr, null);
				}
			}

			append(table, t1);
			append(table, tbody);
			if_blocks[current_block_type_index].m(tbody, null);
			tbody_resize_listener = add_iframe_resize_listener(tbody, /*tbody_elementresize_handler*/ ctx[52].bind(tbody));
			/*table_binding*/ ctx[53](table);
			append(div0, t2);
			if (if_block2) if_block2.m(div0, null);
			append(div1, t3);
			mount_component(pagination, div1, null);
			current = true;

			if (!mounted) {
				dispose = listen(window_1, "resize", /*resize_handler*/ ctx[35]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*columns*/ 128) show_if = /*columns*/ ctx[7].some(func_2);

			if (show_if) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*columns*/ 128) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_9(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*columns, stickyHeader, orderBy, changeOrderBy*/ 33562754) {
				each_value_2 = ensure_array_like(/*columns*/ ctx[7]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, tr, destroy_block, create_each_block_2, null, get_each_context_2);
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(tbody, null);
			}

			if (!current || dirty[0] & /*loading*/ 32) {
				toggle_class(tbody, "inhibit", /*loading*/ ctx[5]);
			}

			if (!current || dirty[0] & /*style*/ 1024) {
				attr(table, "style", /*style*/ ctx[10]);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				attr(table, "class", /*className*/ ctx[9]);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				toggle_class(table, "uk-margin-remove", true);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				toggle_class(table, "uk-table", true);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				toggle_class(table, "uk-table-middle", true);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				toggle_class(table, "uk-table-hover", true);
			}

			if (!current || dirty[0] & /*className, appearance*/ 2560) {
				toggle_class(table, "uk-table-striped", /*appearance*/ ctx[11] === "striped");
			}

			if (!current || dirty[0] & /*className, appearance*/ 2560) {
				toggle_class(table, "uk-table-divider", /*appearance*/ ctx[11] === "divider");
			}

			if (!current || dirty[0] & /*className, size*/ 768) {
				toggle_class(table, "uk-table-small", /*size*/ ctx[8] === "small");
			}

			if (/*loading*/ ctx[5]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);

					if (dirty[0] & /*loading*/ 32) {
						transition_in(if_block2, 1);
					}
				} else {
					if_block2 = create_if_block$l(ctx);
					if_block2.c();
					transition_in(if_block2, 1);
					if_block2.m(div0, null);
				}
			} else if (if_block2) {
				group_outros();

				transition_out(if_block2, 1, 1, () => {
					if_block2 = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*horizontalScroll*/ 131072) {
				toggle_class(div0, "table-hscroll-wrapper", /*horizontalScroll*/ ctx[17]);
			}

			const pagination_changes = {};
			if (dirty[0] & /*filtered, recordsPerPage*/ 262160) pagination_changes.numberOfPages = Math.ceil(/*filtered*/ ctx[4] / /*recordsPerPage*/ ctx[18]);
			if (dirty[0] & /*pageIndex*/ 4) pagination_changes.pageIndex = /*pageIndex*/ ctx[2];
			if (dirty[0] & /*numbersPerSide*/ 524288) pagination_changes.numbersPerSide = /*numbersPerSide*/ ctx[19];
			pagination.$set(pagination_changes);
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(pagination.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(pagination.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(div1);
			}

			if (if_block0) if_block0.d(detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if_blocks[current_block_type_index].d();
			tbody_resize_listener();
			/*table_binding*/ ctx[53](null);
			if (if_block2) if_block2.d();
			destroy_component(pagination);
			mounted = false;
			dispose();
		}
	};
}

const func_2 = c => c.searchable !== false;

function instance$E($$self, $$props, $$invalidate) {
	let { columns = [] } = $$props;
	let { size = undefined } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { appearance = "divider" } = $$props;
	let { searchButtonVariant = "default" } = $$props;
	let { stickyHeader = false } = $$props;
	let { placeholder = "" } = $$props;
	let { noResultText = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { instantSearch = true } = $$props;
	let { query = "" } = $$props;
	let { orderBy = [] } = $$props;
	let { horizontalScroll = true } = $$props;
	let { dataProvider } = $$props;
	let { dataProviderErrorHandler = err => console.error(err) } = $$props;
	let { recordsPerPage = 25 } = $$props;
	let { numbersPerSide = 4 } = $$props;
	let { pageIndex = 0 } = $$props;
	let { total = 0 } = $$props;
	let { filtered = 0 } = $$props;
	let { loading = false } = $$props;
	let { debounceMs = 200 } = $$props;
	let { rows = null } = $$props;
	const dispatch = createEventDispatcher();

	function changeOrderBy(key, append) {
		if (append) {
			const existingSortIndex = orderBy.findIndex(o => o.key === key);

			if (existingSortIndex > -1) {
				if (orderBy[existingSortIndex].direction === "asc") {
					$$invalidate(1, orderBy[existingSortIndex].direction = "desc", orderBy);
				} else {
					orderBy.splice(existingSortIndex, 1);
					$$invalidate(1, orderBy = [...orderBy]);
				}
			} else {
				$$invalidate(1, orderBy = [...orderBy, { key, direction: "asc" }]);
			}
		} else {
			if (orderBy.length === 0 || orderBy.length > 1 || orderBy[0].key !== key) {
				$$invalidate(1, orderBy = [{ key, direction: "asc" }]);
			} else if (orderBy[0].direction === "asc") {
				$$invalidate(1, orderBy = [{ key, direction: "desc" }]);
			} else {
				$$invalidate(1, orderBy = []);
			}
		}
	}

	let externalAssignment = true;

	function handleExternalAssignment() {
		if (debouncedReload.clear) {
			debouncedReload.clear();
		}

		debouncedReload();
	}

	let lastQuery = null;
	let lastOrderBy = null;
	let lastRecordsPerPage = null;
	let lastPageIndex = null;
	let forceUpdate = false;

	async function _reload() {
		if (!loading && (forceUpdate || query !== lastQuery || JSON.stringify(orderBy) !== JSON.stringify(lastOrderBy) || lastRecordsPerPage !== recordsPerPage || lastPageIndex !== pageIndex)) {
			$$invalidate(5, loading = true);

			try {
				let providerQuery = lastQuery;
				let providerRecordsPerPage = lastRecordsPerPage;
				let providerOrderBy = lastOrderBy;
				let providerPageIndex = lastPageIndex;
				let data;
				let debounce = false;

				function updateProviderArgs() {
					providerQuery = query;
					providerRecordsPerPage = recordsPerPage;
					providerOrderBy = orderBy.map(o => ({ ...o }));
					providerPageIndex = pageIndex;
				}

				function providerArgsChanged() {
					return providerQuery !== query || providerRecordsPerPage !== recordsPerPage || JSON.stringify(providerOrderBy) !== JSON.stringify(orderBy) || providerPageIndex !== pageIndex || forceUpdate;
				}

				do {
					do {
						if (recordsPerPage !== providerRecordsPerPage) {
							$$invalidate(2, pageIndex = Math.floor(lastPageIndex * providerRecordsPerPage / recordsPerPage));
						}

						if (query !== providerQuery) {
							$$invalidate(2, pageIndex = 0);
						}

						forceUpdate = false;
						updateProviderArgs();

						if (debounce && debounceMs > 0) {
							await sleep(debounceMs);
						}
					} while (providerArgsChanged());

					data = await dataProvider(query, orderBy, recordsPerPage, pageIndex);

					if (Math.ceil(data.filtered / recordsPerPage) < pageIndex + 1) {
						$$invalidate(2, pageIndex = Math.max(Math.ceil(data.filtered / recordsPerPage) - 1, 0));
					}

					debounce = true;
				} while (providerArgsChanged());

				$$invalidate(6, rows = data.records);
				$$invalidate(4, filtered = data.filtered);
				$$invalidate(28, total = data.total || data.filtered);
				lastQuery = query;
				lastRecordsPerPage = recordsPerPage;
				lastOrderBy = orderBy.map(o => ({ ...o }));
				lastPageIndex = pageIndex;
				$$invalidate(32, externalAssignment = false);
			} catch(err) {
				dataProviderErrorHandler(err);
			} finally {
				$$invalidate(5, loading = false);
			}
		}
	}

	function reload() {
		forceUpdate = true;
		return _reload();
	}

	const debouncedReload = debounceMs > 0 ? debounce(_reload, debounceMs) : _reload;

	/** @type {HTMLInputElement} */
	let searchInput;

	let loaderTop = 0;
	let loaderHeight = 0;

	function updateLoaderTop() {
		const th = ref && ref.querySelector("th");
		$$invalidate(22, loaderTop = th ? th.offsetHeight : 0);
	}

	onMount(() => {
		updateLoaderTop();
	});

	const func = (col, o) => o.key === col.key;
	const func_1 = (col, o) => o.key === col.key;
	const resize_handler = () => updateLoaderTop();

	function searchinput_ref_binding(value) {
		searchInput = value;
		$$invalidate(21, searchInput);
	}

	function searchinput_value_binding(value) {
		query = value;
		$$invalidate(0, query);
	}

	const input_handler = () => {
		if (debouncedReload.clear) {
			debouncedReload.clear();
		}

		debouncedReload();
	};

	function searchinput_ref_binding_1(value) {
		searchInput = value;
		$$invalidate(21, searchInput);
	}

	const click_handler = () => reload();

	const submit_handler = () => {
		if (debouncedReload.clear) {
			debouncedReload.clear();
		}

		$$invalidate(0, query = searchInput.value);
		searchInput.blur();
		debouncedReload();
	};

	const click_handler_1 = (col, e) => {
		if (col.orderable !== false) {
			changeOrderBy(col.key, e.shiftKey);
		}
	};

	const keyup_handler = (col, e) => {
		if (e.code === "Enter") {
			if (col.orderable !== false) {
				changeOrderBy(col.key, e.shiftKey);
			}
		}
	};

	const contextmenu_handler = (col, e) => {
		if (col.orderable !== false) {
			e.preventDefault();
			changeOrderBy(col.key, true);
			window.navigator.vibrate?.(50);
		}
	};

	const func_3 = (col, key) => key === col.key && orderBy[key] === -1;

	const func_4 = (row, col) => ({
		...col,
		rendered: col.render && col.render(row[col.key], row)
	});

	const click_handler_2 = (col, e) => {
		const onClick = col.rendered.onClick;

		if (onClick) {
			e.stopPropagation();
			onClick(e);
		}
	};

	const click_handler_3 = (col, e) => {
		const onClick = col.rendered.onClick;

		if (onClick) {
			e.stopPropagation();
			onClick(e);
		}
	};

	const keyup_handler_1 = (row, e) => ["Enter"].includes(e.code) && dispatch("row-click", row);
	const dblclick_handler = row => dispatch("row-dblclick", row);
	const click_handler_4 = row => dispatch("row-click", row);

	function tbody_elementresize_handler() {
		loaderHeight = this.offsetHeight;
		$$invalidate(23, loaderHeight);
	}

	function table_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(3, ref);
		});
	}

	const page_click_handler = ({ detail }) => $$invalidate(2, pageIndex = detail);

	$$self.$$set = $$props => {
		if ('columns' in $$props) $$invalidate(7, columns = $$props.columns);
		if ('size' in $$props) $$invalidate(8, size = $$props.size);
		if ('className' in $$props) $$invalidate(9, className = $$props.className);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
		if ('appearance' in $$props) $$invalidate(11, appearance = $$props.appearance);
		if ('searchButtonVariant' in $$props) $$invalidate(12, searchButtonVariant = $$props.searchButtonVariant);
		if ('stickyHeader' in $$props) $$invalidate(13, stickyHeader = $$props.stickyHeader);
		if ('placeholder' in $$props) $$invalidate(14, placeholder = $$props.placeholder);
		if ('noResultText' in $$props) $$invalidate(15, noResultText = $$props.noResultText);
		if ('ref' in $$props) $$invalidate(3, ref = $$props.ref);
		if ('instantSearch' in $$props) $$invalidate(16, instantSearch = $$props.instantSearch);
		if ('query' in $$props) $$invalidate(0, query = $$props.query);
		if ('orderBy' in $$props) $$invalidate(1, orderBy = $$props.orderBy);
		if ('horizontalScroll' in $$props) $$invalidate(17, horizontalScroll = $$props.horizontalScroll);
		if ('dataProvider' in $$props) $$invalidate(29, dataProvider = $$props.dataProvider);
		if ('dataProviderErrorHandler' in $$props) $$invalidate(30, dataProviderErrorHandler = $$props.dataProviderErrorHandler);
		if ('recordsPerPage' in $$props) $$invalidate(18, recordsPerPage = $$props.recordsPerPage);
		if ('numbersPerSide' in $$props) $$invalidate(19, numbersPerSide = $$props.numbersPerSide);
		if ('pageIndex' in $$props) $$invalidate(2, pageIndex = $$props.pageIndex);
		if ('total' in $$props) $$invalidate(28, total = $$props.total);
		if ('filtered' in $$props) $$invalidate(4, filtered = $$props.filtered);
		if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
		if ('debounceMs' in $$props) $$invalidate(31, debounceMs = $$props.debounceMs);
		if ('rows' in $$props) $$invalidate(6, rows = $$props.rows);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*query*/ 1) {
			dispatch("query", query);
		}

		if ($$self.$$.dirty[0] & /*orderBy, pageIndex, recordsPerPage*/ 262150 | $$self.$$.dirty[1] & /*externalAssignment*/ 2) {
			if (orderBy || pageIndex >= 0 || recordsPerPage >= 0) {
				if (externalAssignment) {
					handleExternalAssignment();
				}

				$$invalidate(32, externalAssignment = true);
			}
		}
	};

	return [
		query,
		orderBy,
		pageIndex,
		ref,
		filtered,
		loading,
		rows,
		columns,
		size,
		className,
		style,
		appearance,
		searchButtonVariant,
		stickyHeader,
		placeholder,
		noResultText,
		instantSearch,
		horizontalScroll,
		recordsPerPage,
		numbersPerSide,
		reload,
		searchInput,
		loaderTop,
		loaderHeight,
		dispatch,
		changeOrderBy,
		debouncedReload,
		updateLoaderTop,
		total,
		dataProvider,
		dataProviderErrorHandler,
		debounceMs,
		externalAssignment,
		func,
		func_1,
		resize_handler,
		searchinput_ref_binding,
		searchinput_value_binding,
		input_handler,
		searchinput_ref_binding_1,
		click_handler,
		submit_handler,
		click_handler_1,
		keyup_handler,
		contextmenu_handler,
		func_3,
		func_4,
		click_handler_2,
		click_handler_3,
		keyup_handler_1,
		dblclick_handler,
		click_handler_4,
		tbody_elementresize_handler,
		table_binding,
		page_click_handler
	];
}

class AsyncDataTable extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$E,
			create_fragment$E,
			safe_not_equal,
			{
				columns: 7,
				size: 8,
				className: 9,
				style: 10,
				appearance: 11,
				searchButtonVariant: 12,
				stickyHeader: 13,
				placeholder: 14,
				noResultText: 15,
				ref: 3,
				instantSearch: 16,
				query: 0,
				orderBy: 1,
				horizontalScroll: 17,
				dataProvider: 29,
				dataProviderErrorHandler: 30,
				recordsPerPage: 18,
				numbersPerSide: 19,
				pageIndex: 2,
				total: 28,
				filtered: 4,
				loading: 5,
				debounceMs: 31,
				rows: 6,
				reload: 20
			},
			null,
			[-1, -1, -1]
		);
	}

	get reload() {
		return this.$$.ctx[20];
	}
}

/* src/components/Badge.svelte generated by Svelte v4.2.19 */

function create_fragment$D(ctx) {
	let span;
	let span_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			span = element("span");
			if (default_slot) default_slot.c();

			attr(span, "class", span_class_value = /*className*/ ctx[1]
			? "uk-badge " + /*className*/ ctx[1]
			: "uk-badge");

			attr(span, "style", /*style*/ ctx[2]);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (default_slot) {
				default_slot.m(span, null);
			}

			/*span_binding*/ ctx[6](span);
			current = true;

			if (!mounted) {
				dispose = listen(span, "click", /*click_handler*/ ctx[5]);
				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*className*/ 2 && span_class_value !== (span_class_value = /*className*/ ctx[1]
			? "uk-badge " + /*className*/ ctx[1]
			: "uk-badge")) {
				attr(span, "class", span_class_value);
			}

			if (!current || dirty & /*style*/ 4) {
				attr(span, "style", /*style*/ ctx[2]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}

			if (default_slot) default_slot.d(detaching);
			/*span_binding*/ ctx[6](null);
			mounted = false;
			dispose();
		}
	};
}

function instance$D($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function span_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [ref, className, style, $$scope, slots, click_handler, span_binding];
}

class Badge extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$D, create_fragment$D, safe_not_equal, { className: 1, style: 2, ref: 0 });
	}
}

/* src/components/Breadcrumb.svelte generated by Svelte v4.2.19 */

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[5] = list[i];
	return child_ctx;
}

// (34:2) {#each path.slice(0, -1) as entry (entry)}
function create_each_block$8(key_1, ctx) {
	let li;
	let a;
	let t_value = /*entry*/ ctx[5].label + "";
	let t;
	let a_href_value;

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			a = element("a");
			t = text(t_value);
			attr(a, "href", a_href_value = /*entry*/ ctx[5].href);
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			append(a, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*path*/ 2 && t_value !== (t_value = /*entry*/ ctx[5].label + "")) set_data(t, t_value);

			if (dirty & /*path*/ 2 && a_href_value !== (a_href_value = /*entry*/ ctx[5].href)) {
				attr(a, "href", a_href_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

// (37:2) {#if path.length > 0}
function create_if_block$k(ctx) {
	let li;
	let span;
	let t_value = /*path*/ ctx[1][/*path*/ ctx[1].length - 1].label + "";
	let t;

	return {
		c() {
			li = element("li");
			span = element("span");
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, span);
			append(span, t);
		},
		p(ctx, dirty) {
			if (dirty & /*path*/ 2 && t_value !== (t_value = /*path*/ ctx[1][/*path*/ ctx[1].length - 1].label + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}
		}
	};
}

function create_fragment$C(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let t;
	let ul_class_value;
	let each_value = ensure_array_like(/*path*/ ctx[1].slice(0, -1));
	const get_key = ctx => /*entry*/ ctx[5];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$8(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
	}

	let if_block = /*path*/ ctx[1].length > 0 && create_if_block$k(ctx);

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			if (if_block) if_block.c();
			attr(ul, "style", /*style*/ ctx[3]);
			attr(ul, "class", ul_class_value = "uk-margin-small-left uk-margin-small-top uk-margin-small-bottom uk-breadcrumb " + (/*className*/ ctx[2] ? /*className*/ ctx[2] : ""));
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			append(ul, t);
			if (if_block) if_block.m(ul, null);
			/*ul_binding*/ ctx[4](ul);
		},
		p(ctx, [dirty]) {
			if (dirty & /*path*/ 2) {
				each_value = ensure_array_like(/*path*/ ctx[1].slice(0, -1));
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, destroy_block, create_each_block$8, t, get_each_context$8);
			}

			if (/*path*/ ctx[1].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$k(ctx);
					if_block.c();
					if_block.m(ul, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*style*/ 8) {
				attr(ul, "style", /*style*/ ctx[3]);
			}

			if (dirty & /*className*/ 4 && ul_class_value !== (ul_class_value = "uk-margin-small-left uk-margin-small-top uk-margin-small-bottom uk-breadcrumb " + (/*className*/ ctx[2] ? /*className*/ ctx[2] : ""))) {
				attr(ul, "class", ul_class_value);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(ul);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block) if_block.d();
			/*ul_binding*/ ctx[4](null);
		}
	};
}

function instance$C($$self, $$props, $$invalidate) {
	let { path = [] } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('path' in $$props) $$invalidate(1, path = $$props.path);
		if ('className' in $$props) $$invalidate(2, className = $$props.className);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
	};

	return [ref, path, className, style, ul_binding];
}

class Breadcrumb extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$C, create_fragment$C, safe_not_equal, { path: 1, className: 2, style: 3, ref: 0 });
	}
}

/* src/components/Card.svelte generated by Svelte v4.2.19 */
const get_footer_slot_changes$2 = dirty => ({});
const get_footer_slot_context$2 = ctx => ({});
const get_media_bottom_slot_changes = dirty => ({});
const get_media_bottom_slot_context = ctx => ({});
const get_horizontal_media_slot_changes = dirty => ({});
const get_horizontal_media_slot_context = ctx => ({});
const get_media_top_slot_changes = dirty => ({});
const get_media_top_slot_context = ctx => ({});
const get_header_slot_changes$2 = dirty => ({});
const get_header_slot_context$2 = ctx => ({});

// (67:22)     
function fallback_block_3(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[14](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding*/ ctx[14](null);
		}
	};
}

// (72:25)     
function fallback_block_2(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding_1*/ ctx[15](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding_1*/ ctx[15](null);
		}
	};
}

// (78:2) {#if title}
function create_if_block_1$b(ctx) {
	let h3;
	let t;

	return {
		c() {
			h3 = element("h3");
			t = text(/*title*/ ctx[5]);
			attr(h3, "class", "uk-card-title");
		},
		m(target, anchor) {
			insert(target, h3, anchor);
			append(h3, t);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 32) set_data(t, /*title*/ ctx[5]);
		},
		d(detaching) {
			if (detaching) {
				detach(h3);
			}
		}
	};
}

// (81:2) {#if badge}
function create_if_block$j(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text(/*badge*/ ctx[6]);
			attr(div, "class", "uk-card-badge uk-label");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty & /*badge*/ 64) set_data(t, /*badge*/ ctx[6]);
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (87:28)     
function fallback_block_1$2(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding_2*/ ctx[16](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding_2*/ ctx[16](null);
		}
	};
}

// (92:22)     
function fallback_block$4(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding_3*/ ctx[17](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding_3*/ ctx[17](null);
		}
	};
}

function create_fragment$B(ctx) {
	let div5;
	let div0;
	let t0;
	let div1;
	let t1;
	let t2;
	let div2;
	let t3;
	let t4;
	let t5;
	let div3;
	let t6;
	let div4;
	let div5_class_value;
	let current;
	const header_slot_template = /*#slots*/ ctx[13].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[12], get_header_slot_context$2);
	const header_slot_or_fallback = header_slot || fallback_block_3(ctx);
	const media_top_slot_template = /*#slots*/ ctx[13]["media-top"];
	const media_top_slot = create_slot(media_top_slot_template, ctx, /*$$scope*/ ctx[12], get_media_top_slot_context);
	const media_top_slot_or_fallback = media_top_slot || fallback_block_2(ctx);
	const horizontal_media_slot_template = /*#slots*/ ctx[13]["horizontal-media"];
	const horizontal_media_slot = create_slot(horizontal_media_slot_template, ctx, /*$$scope*/ ctx[12], get_horizontal_media_slot_context);
	let if_block0 = /*title*/ ctx[5] && create_if_block_1$b(ctx);
	let if_block1 = /*badge*/ ctx[6] && create_if_block$j(ctx);
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);
	const media_bottom_slot_template = /*#slots*/ ctx[13]["media-bottom"];
	const media_bottom_slot = create_slot(media_bottom_slot_template, ctx, /*$$scope*/ ctx[12], get_media_bottom_slot_context);
	const media_bottom_slot_or_fallback = media_bottom_slot || fallback_block_1$2(ctx);
	const footer_slot_template = /*#slots*/ ctx[13].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[12], get_footer_slot_context$2);
	const footer_slot_or_fallback = footer_slot || fallback_block$4(ctx);

	return {
		c() {
			div5 = element("div");
			div0 = element("div");
			if (header_slot_or_fallback) header_slot_or_fallback.c();
			t0 = space();
			div1 = element("div");
			if (media_top_slot_or_fallback) media_top_slot_or_fallback.c();
			t1 = space();
			if (horizontal_media_slot) horizontal_media_slot.c();
			t2 = space();
			div2 = element("div");
			if (if_block0) if_block0.c();
			t3 = space();
			if (if_block1) if_block1.c();
			t4 = space();
			if (default_slot) default_slot.c();
			t5 = space();
			div3 = element("div");
			if (media_bottom_slot_or_fallback) media_bottom_slot_or_fallback.c();
			t6 = space();
			div4 = element("div");
			if (footer_slot_or_fallback) footer_slot_or_fallback.c();
			attr(div0, "class", "uk-card-header");
			toggle_class(div0, "uk-hidden", !!/*headerDefaultSlot*/ ctx[8]);
			toggle_class(div1, "uk-card-media-top", !/*mediaTopDefaultSlot*/ ctx[10]);
			attr(div2, "class", "uk-card-body");
			toggle_class(div3, "uk-card-media-bottom", !/*mediaBottomDefaultSlot*/ ctx[11]);
			attr(div4, "class", "uk-card-footer");
			toggle_class(div4, "uk-hidden", !!/*footerDefaultSlot*/ ctx[9]);
			attr(div5, "style", /*style*/ ctx[7]);

			attr(div5, "class", div5_class_value = /*className*/ ctx[2]
			? "uk-card " + /*className*/ ctx[2]
			: "uk-card");

			toggle_class(div5, "uk-card-small", /*size*/ ctx[4] === "small");
			toggle_class(div5, "uk-card-large", /*size*/ ctx[4] === "large");
			toggle_class(div5, "uk-card-hover", /*hover*/ ctx[3]);
			toggle_class(div5, "uk-card-default", /*variant*/ ctx[1] === "default");
			toggle_class(div5, "uk-card-primary", /*variant*/ ctx[1] === "primary");
			toggle_class(div5, "uk-card-secondary", /*variant*/ ctx[1] === "secondary");
		},
		m(target, anchor) {
			insert(target, div5, anchor);
			append(div5, div0);

			if (header_slot_or_fallback) {
				header_slot_or_fallback.m(div0, null);
			}

			append(div5, t0);
			append(div5, div1);

			if (media_top_slot_or_fallback) {
				media_top_slot_or_fallback.m(div1, null);
			}

			append(div5, t1);

			if (horizontal_media_slot) {
				horizontal_media_slot.m(div5, null);
			}

			append(div5, t2);
			append(div5, div2);
			if (if_block0) if_block0.m(div2, null);
			append(div2, t3);
			if (if_block1) if_block1.m(div2, null);
			append(div2, t4);

			if (default_slot) {
				default_slot.m(div2, null);
			}

			append(div5, t5);
			append(div5, div3);

			if (media_bottom_slot_or_fallback) {
				media_bottom_slot_or_fallback.m(div3, null);
			}

			append(div5, t6);
			append(div5, div4);

			if (footer_slot_or_fallback) {
				footer_slot_or_fallback.m(div4, null);
			}

			/*div5_binding*/ ctx[18](div5);
			current = true;
		},
		p(ctx, [dirty]) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[12], dirty, get_header_slot_changes$2),
						get_header_slot_context$2
					);
				}
			} else {
				if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty & /*headerDefaultSlot*/ 256)) {
					header_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*headerDefaultSlot*/ 256) {
				toggle_class(div0, "uk-hidden", !!/*headerDefaultSlot*/ ctx[8]);
			}

			if (media_top_slot) {
				if (media_top_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						media_top_slot,
						media_top_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(media_top_slot_template, /*$$scope*/ ctx[12], dirty, get_media_top_slot_changes),
						get_media_top_slot_context
					);
				}
			} else {
				if (media_top_slot_or_fallback && media_top_slot_or_fallback.p && (!current || dirty & /*mediaTopDefaultSlot*/ 1024)) {
					media_top_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*mediaTopDefaultSlot*/ 1024) {
				toggle_class(div1, "uk-card-media-top", !/*mediaTopDefaultSlot*/ ctx[10]);
			}

			if (horizontal_media_slot) {
				if (horizontal_media_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						horizontal_media_slot,
						horizontal_media_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(horizontal_media_slot_template, /*$$scope*/ ctx[12], dirty, get_horizontal_media_slot_changes),
						get_horizontal_media_slot_context
					);
				}
			}

			if (/*title*/ ctx[5]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$b(ctx);
					if_block0.c();
					if_block0.m(div2, t3);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*badge*/ ctx[6]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$j(ctx);
					if_block1.c();
					if_block1.m(div2, t4);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (media_bottom_slot) {
				if (media_bottom_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						media_bottom_slot,
						media_bottom_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(media_bottom_slot_template, /*$$scope*/ ctx[12], dirty, get_media_bottom_slot_changes),
						get_media_bottom_slot_context
					);
				}
			} else {
				if (media_bottom_slot_or_fallback && media_bottom_slot_or_fallback.p && (!current || dirty & /*mediaBottomDefaultSlot*/ 2048)) {
					media_bottom_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*mediaBottomDefaultSlot*/ 2048) {
				toggle_class(div3, "uk-card-media-bottom", !/*mediaBottomDefaultSlot*/ ctx[11]);
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[12], dirty, get_footer_slot_changes$2),
						get_footer_slot_context$2
					);
				}
			} else {
				if (footer_slot_or_fallback && footer_slot_or_fallback.p && (!current || dirty & /*footerDefaultSlot*/ 512)) {
					footer_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*footerDefaultSlot*/ 512) {
				toggle_class(div4, "uk-hidden", !!/*footerDefaultSlot*/ ctx[9]);
			}

			if (!current || dirty & /*style*/ 128) {
				attr(div5, "style", /*style*/ ctx[7]);
			}

			if (!current || dirty & /*className*/ 4 && div5_class_value !== (div5_class_value = /*className*/ ctx[2]
			? "uk-card " + /*className*/ ctx[2]
			: "uk-card")) {
				attr(div5, "class", div5_class_value);
			}

			if (!current || dirty & /*className, size*/ 20) {
				toggle_class(div5, "uk-card-small", /*size*/ ctx[4] === "small");
			}

			if (!current || dirty & /*className, size*/ 20) {
				toggle_class(div5, "uk-card-large", /*size*/ ctx[4] === "large");
			}

			if (!current || dirty & /*className, hover*/ 12) {
				toggle_class(div5, "uk-card-hover", /*hover*/ ctx[3]);
			}

			if (!current || dirty & /*className, variant*/ 6) {
				toggle_class(div5, "uk-card-default", /*variant*/ ctx[1] === "default");
			}

			if (!current || dirty & /*className, variant*/ 6) {
				toggle_class(div5, "uk-card-primary", /*variant*/ ctx[1] === "primary");
			}

			if (!current || dirty & /*className, variant*/ 6) {
				toggle_class(div5, "uk-card-secondary", /*variant*/ ctx[1] === "secondary");
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot_or_fallback, local);
			transition_in(media_top_slot_or_fallback, local);
			transition_in(horizontal_media_slot, local);
			transition_in(default_slot, local);
			transition_in(media_bottom_slot_or_fallback, local);
			transition_in(footer_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot_or_fallback, local);
			transition_out(media_top_slot_or_fallback, local);
			transition_out(horizontal_media_slot, local);
			transition_out(default_slot, local);
			transition_out(media_bottom_slot_or_fallback, local);
			transition_out(footer_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div5);
			}

			if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
			if (media_top_slot_or_fallback) media_top_slot_or_fallback.d(detaching);
			if (horizontal_media_slot) horizontal_media_slot.d(detaching);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			if (media_bottom_slot_or_fallback) media_bottom_slot_or_fallback.d(detaching);
			if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);
			/*div5_binding*/ ctx[18](null);
		}
	};
}

function instance$B($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { variant = "default" } = $$props;
	let { className = undefined } = $$props;
	let { hover = false } = $$props;
	let { size = undefined } = $$props;
	let { title = undefined } = $$props;
	let { badge = undefined } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;
	let headerDefaultSlot = null;
	let footerDefaultSlot = null;
	let mediaTopDefaultSlot = null;
	let mediaBottomDefaultSlot = null;

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			headerDefaultSlot = $$value;
			$$invalidate(8, headerDefaultSlot);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			mediaTopDefaultSlot = $$value;
			$$invalidate(10, mediaTopDefaultSlot);
		});
	}

	function div_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			mediaBottomDefaultSlot = $$value;
			$$invalidate(11, mediaBottomDefaultSlot);
		});
	}

	function div_binding_3($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			footerDefaultSlot = $$value;
			$$invalidate(9, footerDefaultSlot);
		});
	}

	function div5_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('variant' in $$props) $$invalidate(1, variant = $$props.variant);
		if ('className' in $$props) $$invalidate(2, className = $$props.className);
		if ('hover' in $$props) $$invalidate(3, hover = $$props.hover);
		if ('size' in $$props) $$invalidate(4, size = $$props.size);
		if ('title' in $$props) $$invalidate(5, title = $$props.title);
		if ('badge' in $$props) $$invalidate(6, badge = $$props.badge);
		if ('style' in $$props) $$invalidate(7, style = $$props.style);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	return [
		ref,
		variant,
		className,
		hover,
		size,
		title,
		badge,
		style,
		headerDefaultSlot,
		footerDefaultSlot,
		mediaTopDefaultSlot,
		mediaBottomDefaultSlot,
		$$scope,
		slots,
		div_binding,
		div_binding_1,
		div_binding_2,
		div_binding_3,
		div5_binding
	];
}

class Card extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$B, create_fragment$B, safe_not_equal, {
			variant: 1,
			className: 2,
			hover: 3,
			size: 4,
			title: 5,
			badge: 6,
			style: 7,
			ref: 0
		});
	}
}

/* src/components/Comment.svelte generated by Svelte v4.2.19 */
const get_comment_body_slot_changes = dirty => ({});
const get_comment_body_slot_context = ctx => ({});
const get_comment_meta_slot_changes = dirty => ({});
const get_comment_meta_slot_context = ctx => ({});
const get_comment_header_slot_changes = dirty => ({});
const get_comment_header_slot_context = ctx => ({});

// (51:4) {#if avatarSource}
function create_if_block$i(ctx) {
	let div;
	let img;
	let img_src_value;

	return {
		c() {
			div = element("div");
			img = element("img");
			attr(img, "class", "uk-comment-avatar");
			if (!src_url_equal(img.src, img_src_value = /*avatarSource*/ ctx[1])) attr(img, "src", img_src_value);
			attr(img, "width", /*avatarSize*/ ctx[2]);
			attr(img, "height", /*avatarSize*/ ctx[2]);
			attr(img, "alt", /*avatarAlt*/ ctx[3]);
			attr(div, "class", "uk-width-auto");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, img);
		},
		p(ctx, dirty) {
			if (dirty & /*avatarSource*/ 2 && !src_url_equal(img.src, img_src_value = /*avatarSource*/ ctx[1])) {
				attr(img, "src", img_src_value);
			}

			if (dirty & /*avatarSize*/ 4) {
				attr(img, "width", /*avatarSize*/ ctx[2]);
			}

			if (dirty & /*avatarSize*/ 4) {
				attr(img, "height", /*avatarSize*/ ctx[2]);
			}

			if (dirty & /*avatarAlt*/ 8) {
				attr(img, "alt", /*avatarAlt*/ ctx[3]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (49:30)     
function fallback_block$3(ctx) {
	let div1;
	let t0;
	let div0;
	let h4;
	let t1;
	let ul;
	let current;
	let if_block = /*avatarSource*/ ctx[1] && create_if_block$i(ctx);
	const comment_meta_slot_template = /*#slots*/ ctx[9]["comment-meta"];
	const comment_meta_slot = create_slot(comment_meta_slot_template, ctx, /*$$scope*/ ctx[8], get_comment_meta_slot_context);

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div0 = element("div");
			h4 = element("h4");
			t1 = space();
			ul = element("ul");
			if (comment_meta_slot) comment_meta_slot.c();
			attr(h4, "class", "uk-comment-title uk-margin-remove");
			attr(ul, "class", "uk-comment-meta uk-subnav uk-subnav-divider uk-margin-remove-top");
			attr(div0, "class", "uk-width-expand");
			attr(div1, "class", "uk-grid-medium uk-flex-middle");
			attr(div1, "uk-grid", "");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t0);
			append(div1, div0);
			append(div0, h4);
			h4.innerHTML = /*commentTitleAsHtml*/ ctx[4];
			append(div0, t1);
			append(div0, ul);

			if (comment_meta_slot) {
				comment_meta_slot.m(ul, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*avatarSource*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$i(ctx);
					if_block.c();
					if_block.m(div1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*commentTitleAsHtml*/ 16) h4.innerHTML = /*commentTitleAsHtml*/ ctx[4];
			if (comment_meta_slot) {
				if (comment_meta_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						comment_meta_slot,
						comment_meta_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(comment_meta_slot_template, /*$$scope*/ ctx[8], dirty, get_comment_meta_slot_changes),
						get_comment_meta_slot_context
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(comment_meta_slot, local);
			current = true;
		},
		o(local) {
			transition_out(comment_meta_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (if_block) if_block.d();
			if (comment_meta_slot) comment_meta_slot.d(detaching);
		}
	};
}

function create_fragment$A(ctx) {
	let article;
	let header;
	let t;
	let div;
	let article_class_value;
	let current;
	const comment_header_slot_template = /*#slots*/ ctx[9]["comment-header"];
	const comment_header_slot = create_slot(comment_header_slot_template, ctx, /*$$scope*/ ctx[8], get_comment_header_slot_context);
	const comment_header_slot_or_fallback = comment_header_slot || fallback_block$3(ctx);
	const comment_body_slot_template = /*#slots*/ ctx[9]["comment-body"];
	const comment_body_slot = create_slot(comment_body_slot_template, ctx, /*$$scope*/ ctx[8], get_comment_body_slot_context);

	return {
		c() {
			article = element("article");
			header = element("header");
			if (comment_header_slot_or_fallback) comment_header_slot_or_fallback.c();
			t = space();
			div = element("div");
			if (comment_body_slot) comment_body_slot.c();
			attr(header, "class", "uk-comment-header");
			attr(div, "class", "uk-comment-body");

			attr(article, "class", article_class_value = /*className*/ ctx[7]
			? "uk-comment " + /*className*/ ctx[7]
			: "uk-comment");

			attr(article, "style", /*style*/ ctx[6]);
			toggle_class(article, "uk-comment-primary", /*primary*/ ctx[5]);
		},
		m(target, anchor) {
			insert(target, article, anchor);
			append(article, header);

			if (comment_header_slot_or_fallback) {
				comment_header_slot_or_fallback.m(header, null);
			}

			append(article, t);
			append(article, div);

			if (comment_body_slot) {
				comment_body_slot.m(div, null);
			}

			/*article_binding*/ ctx[10](article);
			current = true;
		},
		p(ctx, [dirty]) {
			if (comment_header_slot) {
				if (comment_header_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						comment_header_slot,
						comment_header_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(comment_header_slot_template, /*$$scope*/ ctx[8], dirty, get_comment_header_slot_changes),
						get_comment_header_slot_context
					);
				}
			} else {
				if (comment_header_slot_or_fallback && comment_header_slot_or_fallback.p && (!current || dirty & /*$$scope, commentTitleAsHtml, avatarSource, avatarSize, avatarAlt*/ 286)) {
					comment_header_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (comment_body_slot) {
				if (comment_body_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						comment_body_slot,
						comment_body_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(comment_body_slot_template, /*$$scope*/ ctx[8], dirty, get_comment_body_slot_changes),
						get_comment_body_slot_context
					);
				}
			}

			if (!current || dirty & /*className*/ 128 && article_class_value !== (article_class_value = /*className*/ ctx[7]
			? "uk-comment " + /*className*/ ctx[7]
			: "uk-comment")) {
				attr(article, "class", article_class_value);
			}

			if (!current || dirty & /*style*/ 64) {
				attr(article, "style", /*style*/ ctx[6]);
			}

			if (!current || dirty & /*className, primary*/ 160) {
				toggle_class(article, "uk-comment-primary", /*primary*/ ctx[5]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(comment_header_slot_or_fallback, local);
			transition_in(comment_body_slot, local);
			current = true;
		},
		o(local) {
			transition_out(comment_header_slot_or_fallback, local);
			transition_out(comment_body_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(article);
			}

			if (comment_header_slot_or_fallback) comment_header_slot_or_fallback.d(detaching);
			if (comment_body_slot) comment_body_slot.d(detaching);
			/*article_binding*/ ctx[10](null);
		}
	};
}

function instance$A($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { avatarSource = undefined } = $$props;
	let { avatarSize = 80 } = $$props;
	let { avatarAlt = "" } = $$props;
	let { commentTitleAsHtml = "" } = $$props;
	let { primary = false } = $$props;
	let { ref = undefined } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;

	function article_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('avatarSource' in $$props) $$invalidate(1, avatarSource = $$props.avatarSource);
		if ('avatarSize' in $$props) $$invalidate(2, avatarSize = $$props.avatarSize);
		if ('avatarAlt' in $$props) $$invalidate(3, avatarAlt = $$props.avatarAlt);
		if ('commentTitleAsHtml' in $$props) $$invalidate(4, commentTitleAsHtml = $$props.commentTitleAsHtml);
		if ('primary' in $$props) $$invalidate(5, primary = $$props.primary);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('className' in $$props) $$invalidate(7, className = $$props.className);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		ref,
		avatarSource,
		avatarSize,
		avatarAlt,
		commentTitleAsHtml,
		primary,
		style,
		className,
		$$scope,
		slots,
		article_binding
	];
}

class Comment extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$A, create_fragment$A, safe_not_equal, {
			avatarSource: 1,
			avatarSize: 2,
			avatarAlt: 3,
			commentTitleAsHtml: 4,
			primary: 5,
			ref: 0,
			style: 6,
			className: 7
		});
	}
}

const noop = () => undefined;

/* src/components/DataTable.svelte generated by Svelte v4.2.19 */

function create_fragment$z(ctx) {
	let asyncdatatable;
	let updating_filtered;
	let updating_orderBy;
	let updating_pageIndex;
	let updating_query;
	let updating_ref;
	let updating_rows;
	let updating_total;
	let current;

	function asyncdatatable_filtered_binding(value) {
		/*asyncdatatable_filtered_binding*/ ctx[24](value);
	}

	function asyncdatatable_orderBy_binding(value) {
		/*asyncdatatable_orderBy_binding*/ ctx[25](value);
	}

	function asyncdatatable_pageIndex_binding(value) {
		/*asyncdatatable_pageIndex_binding*/ ctx[26](value);
	}

	function asyncdatatable_query_binding(value) {
		/*asyncdatatable_query_binding*/ ctx[27](value);
	}

	function asyncdatatable_ref_binding(value) {
		/*asyncdatatable_ref_binding*/ ctx[28](value);
	}

	function asyncdatatable_rows_binding(value) {
		/*asyncdatatable_rows_binding*/ ctx[29](value);
	}

	function asyncdatatable_total_binding(value) {
		/*asyncdatatable_total_binding*/ ctx[30](value);
	}

	let asyncdatatable_props = {
		appearance: /*appearance*/ ctx[11],
		className: /*className*/ ctx[9],
		columns: /*columns*/ ctx[7],
		dataProvider: /*dataProvider*/ ctx[21],
		debounceMs: 0,
		horizontalScroll: /*horizontalScroll*/ ctx[17],
		instantSearch: /*instantSearch*/ ctx[16],
		dataProviderErrorHandler: noop,
		noResultText: /*noResultText*/ ctx[15],
		numbersPerSide: /*numbersPerSide*/ ctx[19],
		placeholder: /*placeholder*/ ctx[14],
		recordsPerPage: /*recordsPerPage*/ ctx[18],
		searchButtonVariant: /*searchButtonVariant*/ ctx[12],
		size: /*size*/ ctx[8],
		stickyHeader: /*stickyHeader*/ ctx[13],
		style: /*style*/ ctx[10]
	};

	if (/*filtered*/ ctx[6] !== void 0) {
		asyncdatatable_props.filtered = /*filtered*/ ctx[6];
	}

	if (/*orderBy*/ ctx[0] !== void 0) {
		asyncdatatable_props.orderBy = /*orderBy*/ ctx[0];
	}

	if (/*pageIndex*/ ctx[4] !== void 0) {
		asyncdatatable_props.pageIndex = /*pageIndex*/ ctx[4];
	}

	if (/*query*/ ctx[3] !== void 0) {
		asyncdatatable_props.query = /*query*/ ctx[3];
	}

	if (/*ref*/ ctx[2] !== void 0) {
		asyncdatatable_props.ref = /*ref*/ ctx[2];
	}

	if (/*visibleRows*/ ctx[1] !== void 0) {
		asyncdatatable_props.rows = /*visibleRows*/ ctx[1];
	}

	if (/*total*/ ctx[5] !== void 0) {
		asyncdatatable_props.total = /*total*/ ctx[5];
	}

	asyncdatatable = new AsyncDataTable({ props: asyncdatatable_props });
	binding_callbacks.push(() => bind(asyncdatatable, 'filtered', asyncdatatable_filtered_binding));
	binding_callbacks.push(() => bind(asyncdatatable, 'orderBy', asyncdatatable_orderBy_binding));
	binding_callbacks.push(() => bind(asyncdatatable, 'pageIndex', asyncdatatable_pageIndex_binding));
	binding_callbacks.push(() => bind(asyncdatatable, 'query', asyncdatatable_query_binding));
	binding_callbacks.push(() => bind(asyncdatatable, 'ref', asyncdatatable_ref_binding));
	binding_callbacks.push(() => bind(asyncdatatable, 'rows', asyncdatatable_rows_binding));
	binding_callbacks.push(() => bind(asyncdatatable, 'total', asyncdatatable_total_binding));
	/*asyncdatatable_binding*/ ctx[31](asyncdatatable);
	asyncdatatable.$on("query", /*query_handler*/ ctx[32]);
	asyncdatatable.$on("row-click", /*row_click_handler*/ ctx[33]);
	asyncdatatable.$on("row-dblclick", /*row_dblclick_handler*/ ctx[34]);

	return {
		c() {
			create_component(asyncdatatable.$$.fragment);
		},
		m(target, anchor) {
			mount_component(asyncdatatable, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const asyncdatatable_changes = {};
			if (dirty[0] & /*appearance*/ 2048) asyncdatatable_changes.appearance = /*appearance*/ ctx[11];
			if (dirty[0] & /*className*/ 512) asyncdatatable_changes.className = /*className*/ ctx[9];
			if (dirty[0] & /*columns*/ 128) asyncdatatable_changes.columns = /*columns*/ ctx[7];
			if (dirty[0] & /*horizontalScroll*/ 131072) asyncdatatable_changes.horizontalScroll = /*horizontalScroll*/ ctx[17];
			if (dirty[0] & /*instantSearch*/ 65536) asyncdatatable_changes.instantSearch = /*instantSearch*/ ctx[16];
			if (dirty[0] & /*noResultText*/ 32768) asyncdatatable_changes.noResultText = /*noResultText*/ ctx[15];
			if (dirty[0] & /*numbersPerSide*/ 524288) asyncdatatable_changes.numbersPerSide = /*numbersPerSide*/ ctx[19];
			if (dirty[0] & /*placeholder*/ 16384) asyncdatatable_changes.placeholder = /*placeholder*/ ctx[14];
			if (dirty[0] & /*recordsPerPage*/ 262144) asyncdatatable_changes.recordsPerPage = /*recordsPerPage*/ ctx[18];
			if (dirty[0] & /*searchButtonVariant*/ 4096) asyncdatatable_changes.searchButtonVariant = /*searchButtonVariant*/ ctx[12];
			if (dirty[0] & /*size*/ 256) asyncdatatable_changes.size = /*size*/ ctx[8];
			if (dirty[0] & /*stickyHeader*/ 8192) asyncdatatable_changes.stickyHeader = /*stickyHeader*/ ctx[13];
			if (dirty[0] & /*style*/ 1024) asyncdatatable_changes.style = /*style*/ ctx[10];

			if (!updating_filtered && dirty[0] & /*filtered*/ 64) {
				updating_filtered = true;
				asyncdatatable_changes.filtered = /*filtered*/ ctx[6];
				add_flush_callback(() => updating_filtered = false);
			}

			if (!updating_orderBy && dirty[0] & /*orderBy*/ 1) {
				updating_orderBy = true;
				asyncdatatable_changes.orderBy = /*orderBy*/ ctx[0];
				add_flush_callback(() => updating_orderBy = false);
			}

			if (!updating_pageIndex && dirty[0] & /*pageIndex*/ 16) {
				updating_pageIndex = true;
				asyncdatatable_changes.pageIndex = /*pageIndex*/ ctx[4];
				add_flush_callback(() => updating_pageIndex = false);
			}

			if (!updating_query && dirty[0] & /*query*/ 8) {
				updating_query = true;
				asyncdatatable_changes.query = /*query*/ ctx[3];
				add_flush_callback(() => updating_query = false);
			}

			if (!updating_ref && dirty[0] & /*ref*/ 4) {
				updating_ref = true;
				asyncdatatable_changes.ref = /*ref*/ ctx[2];
				add_flush_callback(() => updating_ref = false);
			}

			if (!updating_rows && dirty[0] & /*visibleRows*/ 2) {
				updating_rows = true;
				asyncdatatable_changes.rows = /*visibleRows*/ ctx[1];
				add_flush_callback(() => updating_rows = false);
			}

			if (!updating_total && dirty[0] & /*total*/ 32) {
				updating_total = true;
				asyncdatatable_changes.total = /*total*/ ctx[5];
				add_flush_callback(() => updating_total = false);
			}

			asyncdatatable.$set(asyncdatatable_changes);
		},
		i(local) {
			if (current) return;
			transition_in(asyncdatatable.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(asyncdatatable.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			/*asyncdatatable_binding*/ ctx[31](null);
			destroy_component(asyncdatatable, detaching);
		}
	};
}

function fallbackComparator(a, b) {
	if (a < b) {
		return -1;
	}

	if (a > b) {
		return 1;
	}

	return 0;
}

function instance$z($$self, $$props, $$invalidate) {
	let { columns = [] } = $$props;
	let { rows = [] } = $$props;
	let { visibleRows = [] } = $$props;
	let { size = undefined } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { appearance = "divider" } = $$props;
	let { searchButtonVariant = "default" } = $$props;
	let { stickyHeader = false } = $$props;
	let { placeholder = "" } = $$props;
	let { noResultText = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { instantSearch = true } = $$props;
	let { query = "" } = $$props;
	let { orderBy = [] } = $$props;
	let { horizontalScroll = true } = $$props;
	let { recordsPerPage = 25 } = $$props;
	let { numbersPerSide = 4 } = $$props;
	let { pageIndex = 0 } = $$props;
	let { total = 0 } = $$props;
	let { filtered = 0 } = $$props;
	const dispatch = createEventDispatcher();

	function dataProvider(query, orderBy, recordsPerPage, pageIndex) {
		const filteredRows = rows.filter(row => columns.some(col => {
			if (col.searchable === false) {
				return query.length === 0;
			}

			if (typeof col.searchable === "function") {
				return col.searchable(query, row[col.key], row);
			}

			if (!col.render) {
				return String(row[col.key]).toLowerCase().includes(query.toLowerCase());
			}

			const output = col.render(row[col.key], row);

			if (typeof output === "string") {
				return output.toLowerCase().includes(query.toLowerCase());
			}

			return false;
		}));

		if (orderBy.length > 0) {
			const columnsByKey = columns.reduce(
				(a, c) => {
					a[c.key] = c;
					return a;
				},
				{}
			);

			filteredRows.sort((r1, r2) => {
				for (const columnSort of orderBy) {
					let comparison = 0;

					if (typeof columnsByKey[columnSort.key].orderable === "function") {
						comparison = columnsByKey[columnSort.key].orderable(r1[columnSort.key], r2[columnSort.key]) * (columnSort.direction === "asc" ? 1 : -1);
					} else {
						comparison = fallbackComparator(r1[columnSort.key], r2[columnSort.key]) * (columnSort.direction === "asc" ? 1 : -1);
					}

					if (comparison !== 0) {
						return comparison;
					}
				}

				return 0;
			});
		}

		return {
			total: rows.length,
			filtered: filteredRows.length,
			records: filteredRows.slice(pageIndex * recordsPerPage, (pageIndex + 1) * recordsPerPage)
		};
	}

	let asyncDataTable;

	async function reload() {
		if (!asyncDataTable) {
			return;
		}

		return asyncDataTable.reload();
	}

	function asyncdatatable_filtered_binding(value) {
		filtered = value;
		$$invalidate(6, filtered);
	}

	function asyncdatatable_orderBy_binding(value) {
		orderBy = value;
		$$invalidate(0, orderBy);
	}

	function asyncdatatable_pageIndex_binding(value) {
		pageIndex = value;
		$$invalidate(4, pageIndex);
	}

	function asyncdatatable_query_binding(value) {
		query = value;
		$$invalidate(3, query);
	}

	function asyncdatatable_ref_binding(value) {
		ref = value;
		$$invalidate(2, ref);
	}

	function asyncdatatable_rows_binding(value) {
		visibleRows = value;
		$$invalidate(1, visibleRows);
	}

	function asyncdatatable_total_binding(value) {
		total = value;
		$$invalidate(5, total);
	}

	function asyncdatatable_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			asyncDataTable = $$value;
			$$invalidate(20, asyncDataTable);
		});
	}

	function query_handler(event) {
		bubble.call(this, $$self, event);
	}

	function row_click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function row_dblclick_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('columns' in $$props) $$invalidate(7, columns = $$props.columns);
		if ('rows' in $$props) $$invalidate(22, rows = $$props.rows);
		if ('visibleRows' in $$props) $$invalidate(1, visibleRows = $$props.visibleRows);
		if ('size' in $$props) $$invalidate(8, size = $$props.size);
		if ('className' in $$props) $$invalidate(9, className = $$props.className);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
		if ('appearance' in $$props) $$invalidate(11, appearance = $$props.appearance);
		if ('searchButtonVariant' in $$props) $$invalidate(12, searchButtonVariant = $$props.searchButtonVariant);
		if ('stickyHeader' in $$props) $$invalidate(13, stickyHeader = $$props.stickyHeader);
		if ('placeholder' in $$props) $$invalidate(14, placeholder = $$props.placeholder);
		if ('noResultText' in $$props) $$invalidate(15, noResultText = $$props.noResultText);
		if ('ref' in $$props) $$invalidate(2, ref = $$props.ref);
		if ('instantSearch' in $$props) $$invalidate(16, instantSearch = $$props.instantSearch);
		if ('query' in $$props) $$invalidate(3, query = $$props.query);
		if ('orderBy' in $$props) $$invalidate(0, orderBy = $$props.orderBy);
		if ('horizontalScroll' in $$props) $$invalidate(17, horizontalScroll = $$props.horizontalScroll);
		if ('recordsPerPage' in $$props) $$invalidate(18, recordsPerPage = $$props.recordsPerPage);
		if ('numbersPerSide' in $$props) $$invalidate(19, numbersPerSide = $$props.numbersPerSide);
		if ('pageIndex' in $$props) $$invalidate(4, pageIndex = $$props.pageIndex);
		if ('total' in $$props) $$invalidate(5, total = $$props.total);
		if ('filtered' in $$props) $$invalidate(6, filtered = $$props.filtered);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*orderBy*/ 1) {
			if (orderBy) {
				dispatch("sort", orderBy);
			}
		}

		if ($$self.$$.dirty[0] & /*rows*/ 4194304) {
			(reload());
		}
	};

	return [
		orderBy,
		visibleRows,
		ref,
		query,
		pageIndex,
		total,
		filtered,
		columns,
		size,
		className,
		style,
		appearance,
		searchButtonVariant,
		stickyHeader,
		placeholder,
		noResultText,
		instantSearch,
		horizontalScroll,
		recordsPerPage,
		numbersPerSide,
		asyncDataTable,
		dataProvider,
		rows,
		reload,
		asyncdatatable_filtered_binding,
		asyncdatatable_orderBy_binding,
		asyncdatatable_pageIndex_binding,
		asyncdatatable_query_binding,
		asyncdatatable_ref_binding,
		asyncdatatable_rows_binding,
		asyncdatatable_total_binding,
		asyncdatatable_binding,
		query_handler,
		row_click_handler,
		row_dblclick_handler
	];
}

class DataTable extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$z,
			create_fragment$z,
			safe_not_equal,
			{
				columns: 7,
				rows: 22,
				visibleRows: 1,
				size: 8,
				className: 9,
				style: 10,
				appearance: 11,
				searchButtonVariant: 12,
				stickyHeader: 13,
				placeholder: 14,
				noResultText: 15,
				ref: 2,
				instantSearch: 16,
				query: 3,
				orderBy: 0,
				horizontalScroll: 17,
				recordsPerPage: 18,
				numbersPerSide: 19,
				pageIndex: 4,
				total: 5,
				filtered: 6,
				reload: 23
			},
			null,
			[-1, -1]
		);
	}

	get reload() {
		return this.$$.ctx[23];
	}
}

/* src/components/DescriptionList.svelte generated by Svelte v4.2.19 */

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[10] = list[i];
	return child_ctx;
}

// (44:4) {:else}
function create_else_block_1$2(ctx) {
	let t_value = /*item*/ ctx[10].term + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*list*/ 64 && t_value !== (t_value = /*item*/ ctx[10].term + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (42:4) {#if termsAreHtml}
function create_if_block_1$a(ctx) {
	let html_tag;
	let raw_value = /*item*/ ctx[10].term + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*list*/ 64 && raw_value !== (raw_value = /*item*/ ctx[10].term + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

// (51:4) {:else}
function create_else_block$9(ctx) {
	let t_value = /*item*/ ctx[10].details + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*list*/ 64 && t_value !== (t_value = /*item*/ ctx[10].details + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (49:4) {#if detailsAreHtml}
function create_if_block$h(ctx) {
	let html_tag;
	let raw_value = /*item*/ ctx[10].details + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*list*/ 64 && raw_value !== (raw_value = /*item*/ ctx[10].details + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

// (40:2) {#each list as item (item)}
function create_each_block$7(key_1, ctx) {
	let dt;
	let t0;
	let dd;
	let t1;

	function select_block_type(ctx, dirty) {
		if (/*termsAreHtml*/ ctx[4]) return create_if_block_1$a;
		return create_else_block_1$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*detailsAreHtml*/ ctx[5]) return create_if_block$h;
		return create_else_block$9;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1(ctx);

	return {
		key: key_1,
		first: null,
		c() {
			dt = element("dt");
			if_block0.c();
			t0 = space();
			dd = element("dd");
			if_block1.c();
			t1 = space();
			this.first = dt;
		},
		m(target, anchor) {
			insert(target, dt, anchor);
			if_block0.m(dt, null);
			append(dt, t0);
			insert(target, dd, anchor);
			if_block1.m(dd, null);
			append(dd, t1);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(dt, t0);
				}
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(dd, t1);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(dt);
				detach(dd);
			}

			if_block0.d();
			if_block1.d();
		}
	};
}

// (39:7)    
function fallback_block$2(ctx) {
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let each_value = ensure_array_like(/*list*/ ctx[6]);
	const get_key = ctx => /*item*/ ctx[10];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$7(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
	}

	return {
		c() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		m(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*list, detailsAreHtml, termsAreHtml*/ 112) {
				each_value = ensure_array_like(/*list*/ ctx[6]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$7, each_1_anchor, get_each_context$7);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(each_1_anchor);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}
		}
	};
}

function create_fragment$y(ctx) {
	let dl;
	let dl_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[8].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);
	const default_slot_or_fallback = default_slot || fallback_block$2(ctx);

	return {
		c() {
			dl = element("dl");
			if (default_slot_or_fallback) default_slot_or_fallback.c();
			attr(dl, "style", /*style*/ ctx[3]);

			attr(dl, "class", dl_class_value = /*className*/ ctx[2]
			? "uk-description-list " + /*className*/ ctx[2]
			: "uk-description-list");

			toggle_class(dl, "uk-description-list-divider", /*showDivider*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, dl, anchor);

			if (default_slot_or_fallback) {
				default_slot_or_fallback.m(dl, null);
			}

			/*dl_binding*/ ctx[9](dl);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 128)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[7],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[7])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[7], dirty, null),
						null
					);
				}
			} else {
				if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & /*list, detailsAreHtml, termsAreHtml*/ 112)) {
					default_slot_or_fallback.p(ctx, !current ? -1 : dirty);
				}
			}

			if (!current || dirty & /*style*/ 8) {
				attr(dl, "style", /*style*/ ctx[3]);
			}

			if (!current || dirty & /*className*/ 4 && dl_class_value !== (dl_class_value = /*className*/ ctx[2]
			? "uk-description-list " + /*className*/ ctx[2]
			: "uk-description-list")) {
				attr(dl, "class", dl_class_value);
			}

			if (!current || dirty & /*className, showDivider*/ 6) {
				toggle_class(dl, "uk-description-list-divider", /*showDivider*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(dl);
			}

			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
			/*dl_binding*/ ctx[9](null);
		}
	};
}

function instance$y($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { showDivider = false } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { termsAreHtml = false } = $$props;
	let { detailsAreHtml = false } = $$props;
	let { list = [] } = $$props;

	function dl_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('showDivider' in $$props) $$invalidate(1, showDivider = $$props.showDivider);
		if ('className' in $$props) $$invalidate(2, className = $$props.className);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('termsAreHtml' in $$props) $$invalidate(4, termsAreHtml = $$props.termsAreHtml);
		if ('detailsAreHtml' in $$props) $$invalidate(5, detailsAreHtml = $$props.detailsAreHtml);
		if ('list' in $$props) $$invalidate(6, list = $$props.list);
		if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
	};

	return [
		ref,
		showDivider,
		className,
		style,
		termsAreHtml,
		detailsAreHtml,
		list,
		$$scope,
		slots,
		dl_binding
	];
}

class DescriptionList extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
			showDivider: 1,
			className: 2,
			style: 3,
			ref: 0,
			termsAreHtml: 4,
			detailsAreHtml: 5,
			list: 6
		});
	}
}

/* src/components/Divider.svelte generated by Svelte v4.2.19 */

function create_fragment$x(ctx) {
	let hr;

	return {
		c() {
			hr = element("hr");
			attr(hr, "style", /*style*/ ctx[4]);
			attr(hr, "class", /*className*/ ctx[5]);
			toggle_class(hr, "uk-divider-icon", /*withIcon*/ ctx[1]);
			toggle_class(hr, "uk-divider-small", /*small*/ ctx[2]);
			toggle_class(hr, "uk-divider-vertical", /*vertical*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, hr, anchor);
			/*hr_binding*/ ctx[6](hr);
		},
		p(ctx, [dirty]) {
			if (dirty & /*style*/ 16) {
				attr(hr, "style", /*style*/ ctx[4]);
			}

			if (dirty & /*className*/ 32) {
				attr(hr, "class", /*className*/ ctx[5]);
			}

			if (dirty & /*className, withIcon*/ 34) {
				toggle_class(hr, "uk-divider-icon", /*withIcon*/ ctx[1]);
			}

			if (dirty & /*className, small*/ 36) {
				toggle_class(hr, "uk-divider-small", /*small*/ ctx[2]);
			}

			if (dirty & /*className, vertical*/ 40) {
				toggle_class(hr, "uk-divider-vertical", /*vertical*/ ctx[3]);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(hr);
			}

			/*hr_binding*/ ctx[6](null);
		}
	};
}

function instance$x($$self, $$props, $$invalidate) {
	let { withIcon = false } = $$props;
	let { small = false } = $$props;
	let { vertical = false } = $$props;
	let { ref = undefined } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;

	function hr_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('withIcon' in $$props) $$invalidate(1, withIcon = $$props.withIcon);
		if ('small' in $$props) $$invalidate(2, small = $$props.small);
		if ('vertical' in $$props) $$invalidate(3, vertical = $$props.vertical);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('className' in $$props) $$invalidate(5, className = $$props.className);
	};

	return [ref, withIcon, small, vertical, style, className, hr_binding];
}

class Divider extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
			withIcon: 1,
			small: 2,
			vertical: 3,
			ref: 0,
			style: 4,
			className: 5
		});
	}
}

/* src/components/Dropdown.svelte generated by Svelte v4.2.19 */

function create_if_block$g(ctx) {
	let button;
	let current;

	button = new Button({
			props: {
				type: "button",
				variant: /*variant*/ ctx[6],
				$$slots: { default: [create_default_slot$g] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(button.$$.fragment);
		},
		m(target, anchor) {
			mount_component(button, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const button_changes = {};
			if (dirty & /*variant*/ 64) button_changes.variant = /*variant*/ ctx[6];

			if (dirty & /*$$scope, label, isLabelHtml*/ 131120) {
				button_changes.$$scope = { dirty, ctx };
			}

			button.$set(button_changes);
		},
		i(local) {
			if (current) return;
			transition_in(button.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(button.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(button, detaching);
		}
	};
}

// (28:4) {:else}
function create_else_block$8(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[4]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 16) set_data(t, /*label*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (26:4) {#if isLabelHtml}
function create_if_block_1$9(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*label*/ ctx[4], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 16) html_tag.p(/*label*/ ctx[4]);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

// (25:2) <Button type="button" {variant}>
function create_default_slot$g(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*isLabelHtml*/ ctx[5]) return create_if_block_1$9;
		return create_else_block$8;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_block.d(detaching);
		}
	};
}

function create_fragment$w(ctx) {
	let t;
	let div;
	let div_uk_dropdown_value;
	let current;
	let mounted;
	let dispose;
	let if_block = /*variant*/ ctx[6] && create_if_block$g(ctx);
	const default_slot_template = /*#slots*/ ctx[7].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "style", /*style*/ ctx[1]);
			attr(div, "class", /*className*/ ctx[2]);
			attr(div, "uk-dropdown", div_uk_dropdown_value = `mode: ${/*mode*/ ctx[3]}`);
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*div_binding*/ ctx[16](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "toggle", stop_propagation(/*toggle_handler*/ ctx[8])),
					listen(div, "beforeshow", stop_propagation(/*beforeshow_handler*/ ctx[9])),
					listen(div, "show", stop_propagation(/*show_handler*/ ctx[10])),
					listen(div, "shown", stop_propagation(/*shown_handler*/ ctx[11])),
					listen(div, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[12])),
					listen(div, "hide", stop_propagation(/*hide_handler*/ ctx[13])),
					listen(div, "hidden", stop_propagation(/*hidden_handler*/ ctx[14])),
					listen(div, "stack", stop_propagation(/*stack_handler*/ ctx[15]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (/*variant*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*variant*/ 64) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$g(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 131072)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[17],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[17])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[17], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*style*/ 2) {
				attr(div, "style", /*style*/ ctx[1]);
			}

			if (!current || dirty & /*className*/ 4) {
				attr(div, "class", /*className*/ ctx[2]);
			}

			if (!current || dirty & /*mode*/ 8 && div_uk_dropdown_value !== (div_uk_dropdown_value = `mode: ${/*mode*/ ctx[3]}`)) {
				attr(div, "uk-dropdown", div_uk_dropdown_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(div);
			}

			if (if_block) if_block.d(detaching);
			if (default_slot) default_slot.d(detaching);
			/*div_binding*/ ctx[16](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$w($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { mode = "hover" } = $$props;
	let { label = "" } = $$props;
	let { isLabelHtml = false } = $$props;
	let { variant = "default" } = $$props;
	let { ref = undefined } = $$props;

	function toggle_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeshow_handler(event) {
		bubble.call(this, $$self, event);
	}

	function show_handler(event) {
		bubble.call(this, $$self, event);
	}

	function shown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hidden_handler(event) {
		bubble.call(this, $$self, event);
	}

	function stack_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('className' in $$props) $$invalidate(2, className = $$props.className);
		if ('mode' in $$props) $$invalidate(3, mode = $$props.mode);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('isLabelHtml' in $$props) $$invalidate(5, isLabelHtml = $$props.isLabelHtml);
		if ('variant' in $$props) $$invalidate(6, variant = $$props.variant);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('$$scope' in $$props) $$invalidate(17, $$scope = $$props.$$scope);
	};

	return [
		ref,
		style,
		className,
		mode,
		label,
		isLabelHtml,
		variant,
		slots,
		toggle_handler,
		beforeshow_handler,
		show_handler,
		shown_handler,
		beforehide_handler,
		hide_handler,
		hidden_handler,
		stack_handler,
		div_binding,
		$$scope
	];
}

class Dropdown extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
			style: 1,
			className: 2,
			mode: 3,
			label: 4,
			isLabelHtml: 5,
			variant: 6,
			ref: 0
		});
	}
}

/* src/components/Form.svelte generated by Svelte v4.2.19 */

function create_fragment$v(ctx) {
	let form;
	let form_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			form = element("form");
			if (default_slot) default_slot.c();
			attr(form, "style", /*style*/ ctx[4]);
			attr(form, "class", form_class_value = "" + (null_to_empty(/*className*/ ctx[5]) + " svelte-1hejssf"));
			toggle_class(form, "uk-form-horizontal", /*variant*/ ctx[6] === 'horizontal');
			toggle_class(form, "uk-form-stacked", /*variant*/ ctx[6] === 'stacked');
			toggle_class(form, "disabled", /*state*/ ctx[1] === 'loading' || /*disabled*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, form, anchor);

			if (default_slot) {
				default_slot.m(form, null);
			}

			/*form_binding*/ ctx[14](form);
			current = true;

			if (!mounted) {
				dispose = [
					listen(form, "change", /*change_handler*/ ctx[15]),
					listen(form, "submit", prevent_default(/*handleSubmit*/ ctx[7]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*style*/ 16) {
				attr(form, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*className*/ 32 && form_class_value !== (form_class_value = "" + (null_to_empty(/*className*/ ctx[5]) + " svelte-1hejssf"))) {
				attr(form, "class", form_class_value);
			}

			if (!current || dirty & /*className, variant*/ 96) {
				toggle_class(form, "uk-form-horizontal", /*variant*/ ctx[6] === 'horizontal');
			}

			if (!current || dirty & /*className, variant*/ 96) {
				toggle_class(form, "uk-form-stacked", /*variant*/ ctx[6] === 'stacked');
			}

			if (!current || dirty & /*className, state, disabled*/ 42) {
				toggle_class(form, "disabled", /*state*/ ctx[1] === 'loading' || /*disabled*/ ctx[3]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(form);
			}

			if (default_slot) default_slot.d(detaching);
			/*form_binding*/ ctx[14](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$v($$self, $$props, $$invalidate) {
	let $stateStore;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { submitAsync } = $$props;
	let { disabled = false } = $$props;
	let { state = "initial" } = $$props;
	let { valid = true } = $$props;
	let { ref = undefined } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { variant = "stacked" } = $$props;

	async function handleSubmit() {
		if (submitAsync) {
			setState("loading");

			try {
				await submitAsync();
				setState("success");
			} catch(err) {
				setState("error");
				throw err;
			}
		}
	}

	let setState = noop;

	/** @type {Readable<'initial'|'invalid'|'valid'|'loading'|'error'|'success'>} */
	let stateStore = readable("initial", set => {
		$$invalidate(10, setState = state => {
			set(state);
		});

		return () => {
			$$invalidate(10, setState = noop);
		};
	});

	component_subscribe($$self, stateStore, value => $$invalidate(11, $stateStore = value));
	setContext("form", stateStore);

	function form_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(2, ref);
		});
	}

	const change_handler = () => $$invalidate(0, valid = ref.checkValidity());

	$$self.$$set = $$props => {
		if ('submitAsync' in $$props) $$invalidate(9, submitAsync = $$props.submitAsync);
		if ('disabled' in $$props) $$invalidate(3, disabled = $$props.disabled);
		if ('state' in $$props) $$invalidate(1, state = $$props.state);
		if ('valid' in $$props) $$invalidate(0, valid = $$props.valid);
		if ('ref' in $$props) $$invalidate(2, ref = $$props.ref);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('className' in $$props) $$invalidate(5, className = $$props.className);
		if ('variant' in $$props) $$invalidate(6, variant = $$props.variant);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$stateStore*/ 2048) {
			{
				$$invalidate(1, state = $stateStore);
			}
		}

		if ($$self.$$.dirty & /*valid, setState*/ 1025) {
			if (!valid) {
				setState("invalid");
			} else {
				setState("valid");
			}
		}
	};

	return [
		valid,
		state,
		ref,
		disabled,
		style,
		className,
		variant,
		handleSubmit,
		stateStore,
		submitAsync,
		setState,
		$stateStore,
		$$scope,
		slots,
		form_binding,
		change_handler
	];
}

class Form extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
			submitAsync: 9,
			disabled: 3,
			state: 1,
			valid: 0,
			ref: 2,
			style: 4,
			className: 5,
			variant: 6
		});
	}
}

function dispatchCustomEvent(element, eventName, detail) {
	element.dispatchEvent(new CustomEvent(eventName, {
		bubbles: true,
		cancelable: true,
		composed: true,
		detail: detail,
	}));
}

/* src/components/FormModal.svelte generated by Svelte v4.2.19 */
const get_footer_slot_changes$1 = dirty => ({});
const get_footer_slot_context$1 = ctx => ({});
const get_header_slot_changes$1 = dirty => ({});
const get_header_slot_context$1 = ctx => ({});

// (160:4) {#if closeable && closeButton}
function create_if_block_2$7(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			attr(button, "type", "button");
			attr(button, "uk-close", "");
			toggle_class(button, "uk-modal-close-default", /*closeButton*/ ctx[12] === 'default');
			toggle_class(button, "uk-modal-close-outside", /*closeButton*/ ctx[12] === 'outside');
			toggle_class(button, "uk-modal-close-full", /*fullScreen*/ ctx[10]);
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*closeButton*/ 4096) {
				toggle_class(button, "uk-modal-close-default", /*closeButton*/ ctx[12] === 'default');
			}

			if (dirty[0] & /*closeButton*/ 4096) {
				toggle_class(button, "uk-modal-close-outside", /*closeButton*/ ctx[12] === 'outside');
			}

			if (dirty[0] & /*fullScreen*/ 1024) {
				toggle_class(button, "uk-modal-close-full", /*fullScreen*/ ctx[10]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}
		}
	};
}

// (172:4) {:else}
function create_else_block_1$1(ctx) {
	let div;
	let div_style_value;
	let current;
	const header_slot_template = /*#slots*/ ctx[29].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[44], get_header_slot_context$1);
	const header_slot_or_fallback = header_slot || fallback_block_1$1(ctx);

	return {
		c() {
			div = element("div");
			if (header_slot_or_fallback) header_slot_or_fallback.c();
			attr(div, "class", "uk-modal-header");
			attr(div, "style", div_style_value = /*noHeader*/ ctx[20] ? 'display: none' : '');
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (header_slot_or_fallback) {
				header_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[44], dirty, get_header_slot_changes$1),
						get_header_slot_context$1
					);
				}
			} else {
				if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty[0] & /*noHeader*/ 1048576)) {
					header_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}

			if (!current || dirty[0] & /*noHeader*/ 1048576 && div_style_value !== (div_style_value = /*noHeader*/ ctx[20] ? 'display: none' : '')) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
		}
	};
}

// (168:4) {#if title}
function create_if_block_1$8(ctx) {
	let div;
	let h2;
	let t;

	return {
		c() {
			div = element("div");
			h2 = element("h2");
			t = text(/*title*/ ctx[8]);
			attr(h2, "class", "uk-modal-title");
			attr(div, "class", "uk-modal-header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, h2);
			append(h2, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 256) set_data(t, /*title*/ ctx[8]);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (174:28)            
function fallback_block_1$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[36](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding*/ ctx[36](null);
		}
	};
}

// (183:4) {:else}
function create_else_block$7(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[29].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[44], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "uk-modal-body");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[44], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (179:4) {#if !fullScreen}
function create_if_block$f(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[29].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[44], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "uk-modal-body");
			attr(div, "uk-overflow-auto", "");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[44], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (189:26)          
function fallback_block$1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding_1*/ ctx[37](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding_1*/ ctx[37](null);
		}
	};
}

// (139:2) <Form     submitAsync={async () => {       try {         await formSubmitAsync();       } finally {         if (show === false) {           if (ref && ref.classList.contains('uk-open')) {             forceHide = true;             UIkit.modal(ref).hide();             forceHide = false;           }         }       }     }}     disabled={formDisabled}     bind:state={formState}     bind:valid={formValid}     bind:ref={formRef}     style={formStyle}     className="uk-modal-dialog {expand ? 'uk-modal-container' : ''} {verticallyCentered ? 'uk-margin-auto-vertical' : ''} {fullScreen ? 'fullscreen-dialog-6554ef564e5f4e5r4g6er4ger4g8ergwe65r' : ''} {formClassName}"     variant={formVariant}>
function create_default_slot$f(ctx) {
	let t0;
	let current_block_type_index;
	let if_block1;
	let t1;
	let current_block_type_index_1;
	let if_block2;
	let t2;
	let div;
	let div_style_value;
	let current;
	let if_block0 = /*closeable*/ ctx[11] && /*closeButton*/ ctx[12] && create_if_block_2$7(ctx);
	const if_block_creators = [create_if_block_1$8, create_else_block_1$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[8]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const if_block_creators_1 = [create_if_block$f, create_else_block$7];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (!/*fullScreen*/ ctx[10]) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	const footer_slot_template = /*#slots*/ ctx[29].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[44], get_footer_slot_context$1);
	const footer_slot_or_fallback = footer_slot || fallback_block$1(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			if_block1.c();
			t1 = space();
			if_block2.c();
			t2 = space();
			div = element("div");
			if (footer_slot_or_fallback) footer_slot_or_fallback.c();
			attr(div, "class", "uk-modal-footer svelte-1ieu9br");
			attr(div, "style", div_style_value = /*noFooter*/ ctx[21] ? 'display: none' : '');
			toggle_class(div, "fullscreen-footer", /*fullScreen*/ ctx[10]);
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, t1, anchor);
			if_blocks_1[current_block_type_index_1].m(target, anchor);
			insert(target, t2, anchor);
			insert(target, div, anchor);

			if (footer_slot_or_fallback) {
				footer_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (/*closeable*/ ctx[11] && /*closeButton*/ ctx[12]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$7(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(t1.parentNode, t1);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block2 = if_blocks_1[current_block_type_index_1];

				if (!if_block2) {
					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(t2.parentNode, t2);
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[1] & /*$$scope*/ 8192)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[44],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[44])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[44], dirty, get_footer_slot_changes$1),
						get_footer_slot_context$1
					);
				}
			} else {
				if (footer_slot_or_fallback && footer_slot_or_fallback.p && (!current || dirty[0] & /*noFooter*/ 2097152)) {
					footer_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}

			if (!current || dirty[0] & /*noFooter*/ 2097152 && div_style_value !== (div_style_value = /*noFooter*/ ctx[21] ? 'display: none' : '')) {
				attr(div, "style", div_style_value);
			}

			if (!current || dirty[0] & /*fullScreen*/ 1024) {
				toggle_class(div, "fullscreen-footer", /*fullScreen*/ ctx[10]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(footer_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(footer_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(t1);
				detach(t2);
				detach(div);
			}

			if (if_block0) if_block0.d(detaching);
			if_blocks[current_block_type_index].d(detaching);
			if_blocks_1[current_block_type_index_1].d(detaching);
			if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);
		}
	};
}

function create_fragment$u(ctx) {
	let div;
	let form;
	let updating_state;
	let updating_valid;
	let updating_ref;
	let div_class_value;
	let div_uk_modal_value;
	let current;
	let mounted;
	let dispose;

	function form_state_binding(value) {
		/*form_state_binding*/ ctx[39](value);
	}

	function form_valid_binding(value) {
		/*form_valid_binding*/ ctx[40](value);
	}

	function form_ref_binding(value) {
		/*form_ref_binding*/ ctx[41](value);
	}

	let form_props = {
		submitAsync: /*func*/ ctx[38],
		disabled: /*formDisabled*/ ctx[16],
		style: /*formStyle*/ ctx[17],
		className: "uk-modal-dialog " + (/*expand*/ ctx[9] ? 'uk-modal-container' : '') + " " + (/*verticallyCentered*/ ctx[13]
		? 'uk-margin-auto-vertical'
		: '') + " " + (/*fullScreen*/ ctx[10]
		? 'fullscreen-dialog-6554ef564e5f4e5r4g6er4ger4g8ergwe65r'
		: '') + " " + /*formClassName*/ ctx[18],
		variant: /*formVariant*/ ctx[19],
		$$slots: { default: [create_default_slot$f] },
		$$scope: { ctx }
	};

	if (/*formState*/ ctx[2] !== void 0) {
		form_props.state = /*formState*/ ctx[2];
	}

	if (/*formValid*/ ctx[3] !== void 0) {
		form_props.valid = /*formValid*/ ctx[3];
	}

	if (/*formRef*/ ctx[4] !== void 0) {
		form_props.ref = /*formRef*/ ctx[4];
	}

	form = new Form({ props: form_props });
	binding_callbacks.push(() => bind(form, 'state', form_state_binding));
	binding_callbacks.push(() => bind(form, 'valid', form_valid_binding));
	binding_callbacks.push(() => bind(form, 'ref', form_ref_binding));

	return {
		c() {
			div = element("div");
			create_component(form.$$.fragment);
			attr(div, "tabindex", "0");
			attr(div, "class", div_class_value = "" + (null_to_empty(/*className*/ ctx[7]) + " svelte-1ieu9br"));
			attr(div, "style", /*style*/ ctx[6]);
			attr(div, "id", /*id*/ ctx[5]);
			attr(div, "uk-modal", div_uk_modal_value = `esc-close: ${/*closeable*/ ctx[11]}; bg-close: ${/*closeable*/ ctx[11]}; stack: ${/*stack*/ ctx[14]}`);
			toggle_class(div, "uk-modal-full", /*fullScreen*/ ctx[10]);
			toggle_class(div, "uk-flex-top", /*verticallyCentered*/ ctx[13]);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(form, div, null);
			/*div_binding_2*/ ctx[43](div);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div, "show", /*handleShow*/ ctx[23]),
					listen(div, "hide", /*handleHide*/ ctx[24]),
					listen(div, "beforehide", /*beforehide_handler_1*/ ctx[42]),
					listen(div, "shown", /*handleShown*/ ctx[25]),
					listen(div, "hidden", /*handleHidden*/ ctx[26]),
					listen(div, "show", stop_propagation(/*show_handler*/ ctx[30])),
					listen(div, "hide", stop_propagation(/*hide_handler*/ ctx[31])),
					listen(div, "shown", stop_propagation(/*shown_handler*/ ctx[32])),
					listen(div, "hidden", stop_propagation(/*hidden_handler*/ ctx[33])),
					listen(div, "beforeshow", stop_propagation(/*beforeshow_handler*/ ctx[34])),
					listen(div, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[35]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			const form_changes = {};
			if (dirty[0] & /*formSubmitAsync, show, ref, forceHide*/ 4227075) form_changes.submitAsync = /*func*/ ctx[38];
			if (dirty[0] & /*formDisabled*/ 65536) form_changes.disabled = /*formDisabled*/ ctx[16];
			if (dirty[0] & /*formStyle*/ 131072) form_changes.style = /*formStyle*/ ctx[17];

			if (dirty[0] & /*expand, verticallyCentered, fullScreen, formClassName*/ 271872) form_changes.className = "uk-modal-dialog " + (/*expand*/ ctx[9] ? 'uk-modal-container' : '') + " " + (/*verticallyCentered*/ ctx[13]
			? 'uk-margin-auto-vertical'
			: '') + " " + (/*fullScreen*/ ctx[10]
			? 'fullscreen-dialog-6554ef564e5f4e5r4g6er4ger4g8ergwe65r'
			: '') + " " + /*formClassName*/ ctx[18];

			if (dirty[0] & /*formVariant*/ 524288) form_changes.variant = /*formVariant*/ ctx[19];

			if (dirty[0] & /*noFooter, fullScreen, title, noHeader, closeButton, closeable*/ 3153152 | dirty[1] & /*$$scope*/ 8192) {
				form_changes.$$scope = { dirty, ctx };
			}

			if (!updating_state && dirty[0] & /*formState*/ 4) {
				updating_state = true;
				form_changes.state = /*formState*/ ctx[2];
				add_flush_callback(() => updating_state = false);
			}

			if (!updating_valid && dirty[0] & /*formValid*/ 8) {
				updating_valid = true;
				form_changes.valid = /*formValid*/ ctx[3];
				add_flush_callback(() => updating_valid = false);
			}

			if (!updating_ref && dirty[0] & /*formRef*/ 16) {
				updating_ref = true;
				form_changes.ref = /*formRef*/ ctx[4];
				add_flush_callback(() => updating_ref = false);
			}

			form.$set(form_changes);

			if (!current || dirty[0] & /*className*/ 128 && div_class_value !== (div_class_value = "" + (null_to_empty(/*className*/ ctx[7]) + " svelte-1ieu9br"))) {
				attr(div, "class", div_class_value);
			}

			if (!current || dirty[0] & /*style*/ 64) {
				attr(div, "style", /*style*/ ctx[6]);
			}

			if (!current || dirty[0] & /*id*/ 32) {
				attr(div, "id", /*id*/ ctx[5]);
			}

			if (!current || dirty[0] & /*closeable, stack*/ 18432 && div_uk_modal_value !== (div_uk_modal_value = `esc-close: ${/*closeable*/ ctx[11]}; bg-close: ${/*closeable*/ ctx[11]}; stack: ${/*stack*/ ctx[14]}`)) {
				attr(div, "uk-modal", div_uk_modal_value);
			}

			if (!current || dirty[0] & /*className, fullScreen*/ 1152) {
				toggle_class(div, "uk-modal-full", /*fullScreen*/ ctx[10]);
			}

			if (!current || dirty[0] & /*className, verticallyCentered*/ 8320) {
				toggle_class(div, "uk-flex-top", /*verticallyCentered*/ ctx[13]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(form.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(form.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(form);
			/*div_binding_2*/ ctx[43](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$u($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id = undefined } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { expand = false } = $$props;
	let { fullScreen = false } = $$props;
	let { closeable = true } = $$props;
	let { closeButton = "default" } = $$props;
	let { verticallyCentered = true } = $$props;
	let { ref = undefined } = $$props;
	let { show = false } = $$props;
	let { shown = false } = $$props;
	let { stack = true } = $$props;
	let { formSubmitAsync } = $$props;
	let { formDisabled = false } = $$props;
	let { formState = "initial" } = $$props;
	let { formValid = true } = $$props;
	let { formRef = undefined } = $$props;
	let { formStyle = undefined } = $$props;
	let { formClassName = '' } = $$props;
	let { formVariant = "stacked" } = $$props;
	let externalAssignment = true;

	onDestroy(() => {
		if (show) {
			dispatchCustomEvent(ref, 'hide');
		}

		if (shown) {
			dispatchCustomEvent(ref, 'hidden');
		}
	});

	function handleShow() {
		$$invalidate(28, externalAssignment = false);
		$$invalidate(1, show = true);
	}

	function handleHide() {
		$$invalidate(28, externalAssignment = false);
		$$invalidate(1, show = false);
	}

	let previouslyFocusedRef;

	function handleShown() {
		$$invalidate(27, shown = true);
		previouslyFocusedRef = document.activeElement;
		ref && ref.focus();
	}

	async function handleHidden() {
		$$invalidate(27, shown = false);
		await tick();
		previouslyFocusedRef && previouslyFocusedRef.focus();
	}

	let noHeader;
	let noFooter;
	let forceHide = false;

	function show_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function shown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hidden_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeshow_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			noHeader = $$value;
			$$invalidate(20, noHeader);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			noFooter = $$value;
			$$invalidate(21, noFooter);
		});
	}

	const func = async () => {
		try {
			await formSubmitAsync();
		} finally {
			if (show === false) {
				if (ref && ref.classList.contains('uk-open')) {
					$$invalidate(22, forceHide = true);
					UIkit.modal(ref).hide();
					$$invalidate(22, forceHide = false);
				}
			}
		}
	};

	function form_state_binding(value) {
		formState = value;
		$$invalidate(2, formState);
	}

	function form_valid_binding(value) {
		formValid = value;
		$$invalidate(3, formValid);
	}

	function form_ref_binding(value) {
		formRef = value;
		$$invalidate(4, formRef);
	}

	const beforehide_handler_1 = e => {
		if (!forceHide && formState === 'loading') {
			e.preventDefault();
		}
	};

	function div_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('className' in $$props) $$invalidate(7, className = $$props.className);
		if ('title' in $$props) $$invalidate(8, title = $$props.title);
		if ('expand' in $$props) $$invalidate(9, expand = $$props.expand);
		if ('fullScreen' in $$props) $$invalidate(10, fullScreen = $$props.fullScreen);
		if ('closeable' in $$props) $$invalidate(11, closeable = $$props.closeable);
		if ('closeButton' in $$props) $$invalidate(12, closeButton = $$props.closeButton);
		if ('verticallyCentered' in $$props) $$invalidate(13, verticallyCentered = $$props.verticallyCentered);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('show' in $$props) $$invalidate(1, show = $$props.show);
		if ('shown' in $$props) $$invalidate(27, shown = $$props.shown);
		if ('stack' in $$props) $$invalidate(14, stack = $$props.stack);
		if ('formSubmitAsync' in $$props) $$invalidate(15, formSubmitAsync = $$props.formSubmitAsync);
		if ('formDisabled' in $$props) $$invalidate(16, formDisabled = $$props.formDisabled);
		if ('formState' in $$props) $$invalidate(2, formState = $$props.formState);
		if ('formValid' in $$props) $$invalidate(3, formValid = $$props.formValid);
		if ('formRef' in $$props) $$invalidate(4, formRef = $$props.formRef);
		if ('formStyle' in $$props) $$invalidate(17, formStyle = $$props.formStyle);
		if ('formClassName' in $$props) $$invalidate(18, formClassName = $$props.formClassName);
		if ('formVariant' in $$props) $$invalidate(19, formVariant = $$props.formVariant);
		if ('$$scope' in $$props) $$invalidate(44, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*ref, externalAssignment, show*/ 268435459) {
			if (ref) {
				if (externalAssignment) {
					if (show && !ref.classList.contains('uk-open')) {
						UIkit.modal(ref).show();
					} else if (!show && ref.classList.contains('uk-open')) {
						UIkit.modal(ref).hide();
					}
				}

				$$invalidate(28, externalAssignment = true);
			}
		}
	};

	return [
		ref,
		show,
		formState,
		formValid,
		formRef,
		id,
		style,
		className,
		title,
		expand,
		fullScreen,
		closeable,
		closeButton,
		verticallyCentered,
		stack,
		formSubmitAsync,
		formDisabled,
		formStyle,
		formClassName,
		formVariant,
		noHeader,
		noFooter,
		forceHide,
		handleShow,
		handleHide,
		handleShown,
		handleHidden,
		shown,
		externalAssignment,
		slots,
		show_handler,
		hide_handler,
		shown_handler,
		hidden_handler,
		beforeshow_handler,
		beforehide_handler,
		div_binding,
		div_binding_1,
		func,
		form_state_binding,
		form_valid_binding,
		form_ref_binding,
		beforehide_handler_1,
		div_binding_2,
		$$scope
	];
}

class FormModal extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$u,
			create_fragment$u,
			safe_not_equal,
			{
				id: 5,
				style: 6,
				className: 7,
				title: 8,
				expand: 9,
				fullScreen: 10,
				closeable: 11,
				closeButton: 12,
				verticallyCentered: 13,
				ref: 0,
				show: 1,
				shown: 27,
				stack: 14,
				formSubmitAsync: 15,
				formDisabled: 16,
				formState: 2,
				formValid: 3,
				formRef: 4,
				formStyle: 17,
				formClassName: 18,
				formVariant: 19
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/LoaderOverlay.svelte generated by Svelte v4.2.19 */

function create_if_block$e(ctx) {
	let div3;
	let div2;
	let div0;
	let div0_style_value;
	let div0_class_value;
	let t0;
	let div1;
	let t1;
	let t2;
	let div2_class_value;
	let current;
	let if_block0 = (/*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'right') && create_if_block_2$6(ctx);
	const default_slot_template = /*#slots*/ ctx[12].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[11], null);
	let if_block1 = (/*slotPosition*/ ctx[9] === 'top' || /*slotPosition*/ ctx[9] === 'left') && create_if_block_1$7(ctx);

	return {
		c() {
			div3 = element("div");
			div2 = element("div");
			div0 = element("div");
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			if (default_slot) default_slot.c();
			t2 = space();
			if (if_block1) if_block1.c();
			attr(div0, "style", div0_style_value = "opacity: " + /*opacity*/ ctx[4] + "; " + (/*backgroundStyle*/ ctx[8] || ''));
			attr(div0, "class", div0_class_value = "" + (null_to_empty(/*backgroundClassName*/ ctx[7]) + " svelte-idkgsp"));
			toggle_class(div0, "uk-background-muted", /*background*/ ctx[6] === 'muted');
			toggle_class(div0, "uk-background-default", /*background*/ ctx[6] === 'default');
			toggle_class(div0, "uk-background-primary", /*background*/ ctx[6] === 'primary');
			toggle_class(div0, "uk-background-secondary", /*background*/ ctx[6] === 'secondary');
			attr(div1, "class", "uk-flex uk-flex-middle uk-flex-center svelte-idkgsp");
			toggle_class(div1, "uk-flex-column", /*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'top');
			attr(div2, "class", div2_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-idkgsp"));
			attr(div2, "style", /*style*/ ctx[3]);
			toggle_class(div2, "overlay", true);
		},
		m(target, anchor) {
			insert(target, div3, anchor);
			append(div3, div2);
			append(div2, div0);
			append(div2, t0);
			append(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);

			if (default_slot) {
				default_slot.m(div1, null);
			}

			append(div1, t2);
			if (if_block1) if_block1.m(div1, null);
			/*div2_binding*/ ctx[13](div2);
			/*div3_binding*/ ctx[14](div3);
			current = true;
		},
		p(ctx, dirty) {
			if (!current || dirty & /*opacity, backgroundStyle*/ 272 && div0_style_value !== (div0_style_value = "opacity: " + /*opacity*/ ctx[4] + "; " + (/*backgroundStyle*/ ctx[8] || ''))) {
				attr(div0, "style", div0_style_value);
			}

			if (!current || dirty & /*backgroundClassName*/ 128 && div0_class_value !== (div0_class_value = "" + (null_to_empty(/*backgroundClassName*/ ctx[7]) + " svelte-idkgsp"))) {
				attr(div0, "class", div0_class_value);
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-muted", /*background*/ ctx[6] === 'muted');
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-default", /*background*/ ctx[6] === 'default');
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-primary", /*background*/ ctx[6] === 'primary');
			}

			if (!current || dirty & /*backgroundClassName, background*/ 192) {
				toggle_class(div0, "uk-background-secondary", /*background*/ ctx[6] === 'secondary');
			}

			if (/*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'right') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*slotPosition*/ 512) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$6(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2048)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[11],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[11])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[11], dirty, null),
						null
					);
				}
			}

			if (/*slotPosition*/ ctx[9] === 'top' || /*slotPosition*/ ctx[9] === 'left') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*slotPosition*/ 512) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*slotPosition*/ 512) {
				toggle_class(div1, "uk-flex-column", /*slotPosition*/ ctx[9] === 'bottom' || /*slotPosition*/ ctx[9] === 'top');
			}

			if (!current || dirty & /*className*/ 2 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*className*/ ctx[1]) + " svelte-idkgsp"))) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty & /*style*/ 8) {
				attr(div2, "style", /*style*/ ctx[3]);
			}

			if (!current || dirty & /*className*/ 2) {
				toggle_class(div2, "overlay", true);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(default_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(default_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div3);
			}

			if (if_block0) if_block0.d();
			if (default_slot) default_slot.d(detaching);
			if (if_block1) if_block1.d();
			/*div2_binding*/ ctx[13](null);
			/*div3_binding*/ ctx[14](null);
		}
	};
}

// (76:8) {#if slotPosition === 'bottom' || slotPosition === 'right'}
function create_if_block_2$6(ctx) {
	let loader;
	let current;
	loader = new Loader({ props: { ratio: /*ratio*/ ctx[2] } });

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const loader_changes = {};
			if (dirty & /*ratio*/ 4) loader_changes.ratio = /*ratio*/ ctx[2];
			loader.$set(loader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

// (80:8) {#if slotPosition === 'top' || slotPosition === 'left'}
function create_if_block_1$7(ctx) {
	let loader;
	let current;
	loader = new Loader({ props: { ratio: /*ratio*/ ctx[2] } });

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const loader_changes = {};
			if (dirty & /*ratio*/ 4) loader_changes.ratio = /*ratio*/ ctx[2];
			loader.$set(loader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

function create_fragment$t(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*loading*/ ctx[5] && create_if_block$e(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*loading*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*loading*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$e(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$t($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { className = undefined } = $$props;
	let { ratio = 1 } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { opacity = 0.8 } = $$props;
	let { loading = true } = $$props;
	let { background = "default" } = $$props;
	let { backgroundClassName = undefined } = $$props;
	let { backgroundStyle = undefined } = $$props;
	let { slotPosition = "bottom" } = $$props;
	let originalWrapperRef;

	onDestroy(() => {
		if (ref && ref.parentElement === document.body) {
			document.body.removeChild(ref);
			originalWrapperRef.appendChild(ref);
		}
	});

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	function div3_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			originalWrapperRef = $$value;
			$$invalidate(10, originalWrapperRef);
		});
	}

	$$self.$$set = $$props => {
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('ratio' in $$props) $$invalidate(2, ratio = $$props.ratio);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('opacity' in $$props) $$invalidate(4, opacity = $$props.opacity);
		if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
		if ('background' in $$props) $$invalidate(6, background = $$props.background);
		if ('backgroundClassName' in $$props) $$invalidate(7, backgroundClassName = $$props.backgroundClassName);
		if ('backgroundStyle' in $$props) $$invalidate(8, backgroundStyle = $$props.backgroundStyle);
		if ('slotPosition' in $$props) $$invalidate(9, slotPosition = $$props.slotPosition);
		if ('$$scope' in $$props) $$invalidate(11, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*originalWrapperRef, loading, ref*/ 1057) {
			if (originalWrapperRef) {
				if (loading) {
					originalWrapperRef.removeChild(ref);
					document.body.appendChild(ref);
				} else {
					document.body.removeChild(ref);
					originalWrapperRef.appendChild(ref);
				}
			}
		}
	};

	return [
		ref,
		className,
		ratio,
		style,
		opacity,
		loading,
		background,
		backgroundClassName,
		backgroundStyle,
		slotPosition,
		originalWrapperRef,
		$$scope,
		slots,
		div2_binding,
		div3_binding
	];
}

class LoaderOverlay extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
			className: 1,
			ratio: 2,
			style: 3,
			ref: 0,
			opacity: 4,
			loading: 5,
			background: 6,
			backgroundClassName: 7,
			backgroundStyle: 8,
			slotPosition: 9
		});
	}
}

/* src/components/LoaderWrapper.svelte generated by Svelte v4.2.19 */
const get_loading_slot_changes = dirty => ({});
const get_loading_slot_context = ctx => ({});

// (37:0) {:else}
function create_else_block$6(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (24:0) {#if loading}
function create_if_block$d(ctx) {
	let div;
	let t0;
	let t1;
	let current;
	let if_block0 = (/*slotPosition*/ ctx[5] === 'bottom' || /*slotPosition*/ ctx[5] === 'right') && create_if_block_2$5(ctx);
	const loading_slot_template = /*#slots*/ ctx[10].loading;
	const loading_slot = create_slot(loading_slot_template, ctx, /*$$scope*/ ctx[9], get_loading_slot_context);
	let if_block1 = (/*slotPosition*/ ctx[5] === 'top' || /*slotPosition*/ ctx[5] === 'left') && create_if_block_1$6(ctx);

	return {
		c() {
			div = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if (loading_slot) loading_slot.c();
			t1 = space();
			if (if_block1) if_block1.c();
			toggle_class(div, "uk-flex", /*center*/ ctx[4]);
			toggle_class(div, "uk-flex-middle", /*center*/ ctx[4]);
			toggle_class(div, "uk-flex-center", /*center*/ ctx[4]);
			toggle_class(div, "uk-flex-column", /*slotPosition*/ ctx[5] === 'bottom' || /*slotPosition*/ ctx[5] === 'top');
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append(div, t0);

			if (loading_slot) {
				loading_slot.m(div, null);
			}

			append(div, t1);
			if (if_block1) if_block1.m(div, null);
			current = true;
		},
		p(ctx, dirty) {
			if (/*slotPosition*/ ctx[5] === 'bottom' || /*slotPosition*/ ctx[5] === 'right') {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*slotPosition*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_2$5(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (loading_slot) {
				if (loading_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						loading_slot,
						loading_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(loading_slot_template, /*$$scope*/ ctx[9], dirty, get_loading_slot_changes),
						get_loading_slot_context
					);
				}
			}

			if (/*slotPosition*/ ctx[5] === 'top' || /*slotPosition*/ ctx[5] === 'left') {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*slotPosition*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$6(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(div, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*center*/ 16) {
				toggle_class(div, "uk-flex", /*center*/ ctx[4]);
			}

			if (!current || dirty & /*center*/ 16) {
				toggle_class(div, "uk-flex-middle", /*center*/ ctx[4]);
			}

			if (!current || dirty & /*center*/ 16) {
				toggle_class(div, "uk-flex-center", /*center*/ ctx[4]);
			}

			if (!current || dirty & /*slotPosition*/ 32) {
				toggle_class(div, "uk-flex-column", /*slotPosition*/ ctx[5] === 'bottom' || /*slotPosition*/ ctx[5] === 'top');
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(loading_slot, local);
			transition_in(if_block1);
			current = true;
		},
		o(local) {
			transition_out(if_block0);
			transition_out(loading_slot, local);
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (if_block0) if_block0.d();
			if (loading_slot) loading_slot.d(detaching);
			if (if_block1) if_block1.d();
		}
	};
}

// (29:4) {#if slotPosition === 'bottom' || slotPosition === 'right'}
function create_if_block_2$5(ctx) {
	let loader;
	let updating_ref;
	let current;

	function loader_ref_binding(value) {
		/*loader_ref_binding*/ ctx[11](value);
	}

	let loader_props = {
		className: /*className*/ ctx[1],
		ratio: /*ratio*/ ctx[2],
		style: /*style*/ ctx[3]
	};

	if (/*refTopLeft*/ ctx[6] !== void 0) {
		loader_props.ref = /*refTopLeft*/ ctx[6];
	}

	loader = new Loader({ props: loader_props });
	binding_callbacks.push(() => bind(loader, 'ref', loader_ref_binding));

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const loader_changes = {};
			if (dirty & /*className*/ 2) loader_changes.className = /*className*/ ctx[1];
			if (dirty & /*ratio*/ 4) loader_changes.ratio = /*ratio*/ ctx[2];
			if (dirty & /*style*/ 8) loader_changes.style = /*style*/ ctx[3];

			if (!updating_ref && dirty & /*refTopLeft*/ 64) {
				updating_ref = true;
				loader_changes.ref = /*refTopLeft*/ ctx[6];
				add_flush_callback(() => updating_ref = false);
			}

			loader.$set(loader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

// (33:4) {#if slotPosition === 'top' || slotPosition === 'left'}
function create_if_block_1$6(ctx) {
	let loader;
	let updating_ref;
	let current;

	function loader_ref_binding_1(value) {
		/*loader_ref_binding_1*/ ctx[12](value);
	}

	let loader_props = {
		className: /*className*/ ctx[1],
		ratio: /*ratio*/ ctx[2],
		style: /*style*/ ctx[3]
	};

	if (/*refBottomRight*/ ctx[7] !== void 0) {
		loader_props.ref = /*refBottomRight*/ ctx[7];
	}

	loader = new Loader({ props: loader_props });
	binding_callbacks.push(() => bind(loader, 'ref', loader_ref_binding_1));

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const loader_changes = {};
			if (dirty & /*className*/ 2) loader_changes.className = /*className*/ ctx[1];
			if (dirty & /*ratio*/ 4) loader_changes.ratio = /*ratio*/ ctx[2];
			if (dirty & /*style*/ 8) loader_changes.style = /*style*/ ctx[3];

			if (!updating_ref && dirty & /*refBottomRight*/ 128) {
				updating_ref = true;
				loader_changes.ref = /*refBottomRight*/ ctx[7];
				add_flush_callback(() => updating_ref = false);
			}

			loader.$set(loader_changes);
		},
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

function create_fragment$s(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$d, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*loading*/ ctx[0]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

function instance$s($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { loading = true } = $$props;
	let { className = undefined } = $$props;
	let { ratio = 1 } = $$props;
	let { style = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { center = true } = $$props;
	let { slotPosition = "bottom" } = $$props;
	let refTopLeft;
	let refBottomRight;

	function loader_ref_binding(value) {
		refTopLeft = value;
		$$invalidate(6, refTopLeft);
	}

	function loader_ref_binding_1(value) {
		refBottomRight = value;
		$$invalidate(7, refBottomRight);
	}

	$$self.$$set = $$props => {
		if ('loading' in $$props) $$invalidate(0, loading = $$props.loading);
		if ('className' in $$props) $$invalidate(1, className = $$props.className);
		if ('ratio' in $$props) $$invalidate(2, ratio = $$props.ratio);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
		if ('ref' in $$props) $$invalidate(8, ref = $$props.ref);
		if ('center' in $$props) $$invalidate(4, center = $$props.center);
		if ('slotPosition' in $$props) $$invalidate(5, slotPosition = $$props.slotPosition);
		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*refTopLeft, refBottomRight*/ 192) {
			$$invalidate(8, ref = refTopLeft || refBottomRight);
		}
	};

	return [
		loading,
		className,
		ratio,
		style,
		center,
		slotPosition,
		refTopLeft,
		refBottomRight,
		ref,
		$$scope,
		slots,
		loader_ref_binding,
		loader_ref_binding_1
	];
}

class LoaderWrapper extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
			loading: 0,
			className: 1,
			ratio: 2,
			style: 3,
			ref: 8,
			center: 4,
			slotPosition: 5
		});
	}
}

/* src/components/Modal.svelte generated by Svelte v4.2.19 */
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

// (118:4) {#if closeable && closeButton}
function create_if_block_2$4(ctx) {
	let button;

	return {
		c() {
			button = element("button");
			attr(button, "type", "button");
			attr(button, "uk-close", "");
			toggle_class(button, "uk-modal-close-default", /*closeButton*/ ctx[8] === 'default');
			toggle_class(button, "uk-modal-close-outside", /*closeButton*/ ctx[8] === 'outside');
			toggle_class(button, "uk-modal-close-full", /*fullScreen*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, button, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*closeButton*/ 256) {
				toggle_class(button, "uk-modal-close-default", /*closeButton*/ ctx[8] === 'default');
			}

			if (dirty[0] & /*closeButton*/ 256) {
				toggle_class(button, "uk-modal-close-outside", /*closeButton*/ ctx[8] === 'outside');
			}

			if (dirty[0] & /*fullScreen*/ 64) {
				toggle_class(button, "uk-modal-close-full", /*fullScreen*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}
		}
	};
}

// (130:4) {:else}
function create_else_block_1(ctx) {
	let div;
	let div_style_value;
	let current;
	const header_slot_template = /*#slots*/ ctx[21].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[20], get_header_slot_context);
	const header_slot_or_fallback = header_slot || fallback_block_1(ctx);

	return {
		c() {
			div = element("div");
			if (header_slot_or_fallback) header_slot_or_fallback.c();
			attr(div, "class", "uk-modal-header");
			attr(div, "style", div_style_value = /*noHeader*/ ctx[11] ? 'display: none' : '');
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (header_slot_or_fallback) {
				header_slot_or_fallback.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[20], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			} else {
				if (header_slot_or_fallback && header_slot_or_fallback.p && (!current || dirty[0] & /*noHeader*/ 2048)) {
					header_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}

			if (!current || dirty[0] & /*noHeader*/ 2048 && div_style_value !== (div_style_value = /*noHeader*/ ctx[11] ? 'display: none' : '')) {
				attr(div, "style", div_style_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(header_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(header_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (header_slot_or_fallback) header_slot_or_fallback.d(detaching);
		}
	};
}

// (126:4) {#if title}
function create_if_block_1$5(ctx) {
	let div;
	let h2;
	let t;

	return {
		c() {
			div = element("div");
			h2 = element("h2");
			t = text(/*title*/ ctx[4]);
			attr(h2, "class", "uk-modal-title");
			attr(div, "class", "uk-modal-header");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, h2);
			append(h2, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*title*/ 16) set_data(t, /*title*/ ctx[4]);
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (132:28)            
function fallback_block_1(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[28](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding*/ ctx[28](null);
		}
	};
}

// (141:4) {:else}
function create_else_block$5(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "uk-modal-body");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (137:4) {#if !fullScreen}
function create_if_block$c(ctx) {
	let div;
	let current;
	const default_slot_template = /*#slots*/ ctx[21].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);

	return {
		c() {
			div = element("div");
			if (default_slot) default_slot.c();
			attr(div, "class", "uk-modal-body");
			attr(div, "uk-overflow-auto", "");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (147:26)          
function fallback_block(ctx) {
	let div;

	return {
		c() {
			div = element("div");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding_1*/ ctx[29](div);
		},
		p: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			/*div_binding_1*/ ctx[29](null);
		}
	};
}

function create_fragment$r(ctx) {
	let div2;
	let div1;
	let t0;
	let current_block_type_index;
	let if_block1;
	let t1;
	let current_block_type_index_1;
	let if_block2;
	let t2;
	let div0;
	let div0_style_value;
	let div2_class_value;
	let div2_uk_modal_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*closeable*/ ctx[7] && /*closeButton*/ ctx[8] && create_if_block_2$4(ctx);
	const if_block_creators = [create_if_block_1$5, create_else_block_1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*title*/ ctx[4]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	const if_block_creators_1 = [create_if_block$c, create_else_block$5];
	const if_blocks_1 = [];

	function select_block_type_1(ctx, dirty) {
		if (!/*fullScreen*/ ctx[6]) return 0;
		return 1;
	}

	current_block_type_index_1 = select_block_type_1(ctx);
	if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
	const footer_slot_template = /*#slots*/ ctx[21].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[20], get_footer_slot_context);
	const footer_slot_or_fallback = footer_slot || fallback_block(ctx);

	return {
		c() {
			div2 = element("div");
			div1 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			if_block1.c();
			t1 = space();
			if_block2.c();
			t2 = space();
			div0 = element("div");
			if (footer_slot_or_fallback) footer_slot_or_fallback.c();
			attr(div0, "class", "uk-modal-footer svelte-xn439w");
			attr(div0, "style", div0_style_value = /*noFooter*/ ctx[12] ? 'display: none' : '');
			toggle_class(div0, "fullscreen-footer", /*fullScreen*/ ctx[6]);
			attr(div1, "class", "uk-modal-dialog svelte-xn439w");
			toggle_class(div1, "fullscreen-dialog", /*fullScreen*/ ctx[6]);
			toggle_class(div1, "uk-modal-container", /*expand*/ ctx[5]);
			toggle_class(div1, "uk-margin-auto-vertical", /*verticallyCentered*/ ctx[9]);
			attr(div2, "tabindex", "0");
			attr(div2, "class", div2_class_value = "" + (null_to_empty(/*className*/ ctx[3]) + " svelte-xn439w"));
			attr(div2, "style", /*style*/ ctx[2]);
			attr(div2, "id", /*id*/ ctx[1]);
			attr(div2, "uk-modal", div2_uk_modal_value = `esc-close: ${/*closeable*/ ctx[7]}; bg-close: ${/*closeable*/ ctx[7]}; stack: ${/*stack*/ ctx[10]}`);
			toggle_class(div2, "uk-modal-full", /*fullScreen*/ ctx[6]);
			toggle_class(div2, "uk-flex-top", /*verticallyCentered*/ ctx[9]);
		},
		m(target, anchor) {
			insert(target, div2, anchor);
			append(div2, div1);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t0);
			if_blocks[current_block_type_index].m(div1, null);
			append(div1, t1);
			if_blocks_1[current_block_type_index_1].m(div1, null);
			append(div1, t2);
			append(div1, div0);

			if (footer_slot_or_fallback) {
				footer_slot_or_fallback.m(div0, null);
			}

			/*div2_binding*/ ctx[30](div2);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div2, "show", /*handleShow*/ ctx[13]),
					listen(div2, "hide", /*handleHide*/ ctx[14]),
					listen(div2, "shown", /*handleShown*/ ctx[15]),
					listen(div2, "hidden", /*handleHidden*/ ctx[16]),
					listen(div2, "show", stop_propagation(/*show_handler*/ ctx[22])),
					listen(div2, "hide", stop_propagation(/*hide_handler*/ ctx[23])),
					listen(div2, "shown", stop_propagation(/*shown_handler*/ ctx[24])),
					listen(div2, "hidden", stop_propagation(/*hidden_handler*/ ctx[25])),
					listen(div2, "beforeshow", stop_propagation(/*beforeshow_handler*/ ctx[26])),
					listen(div2, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[27]))
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*closeable*/ ctx[7] && /*closeButton*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$4(ctx);
					if_block0.c();
					if_block0.m(div1, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in(if_block1, 1);
				if_block1.m(div1, t1);
			}

			let previous_block_index_1 = current_block_type_index_1;
			current_block_type_index_1 = select_block_type_1(ctx);

			if (current_block_type_index_1 === previous_block_index_1) {
				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
					if_blocks_1[previous_block_index_1] = null;
				});

				check_outros();
				if_block2 = if_blocks_1[current_block_type_index_1];

				if (!if_block2) {
					if_block2 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div1, t2);
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty[0] & /*$$scope*/ 1048576)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[20],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[20])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[20], dirty, get_footer_slot_changes),
						get_footer_slot_context
					);
				}
			} else {
				if (footer_slot_or_fallback && footer_slot_or_fallback.p && (!current || dirty[0] & /*noFooter*/ 4096)) {
					footer_slot_or_fallback.p(ctx, !current ? [-1, -1] : dirty);
				}
			}

			if (!current || dirty[0] & /*noFooter*/ 4096 && div0_style_value !== (div0_style_value = /*noFooter*/ ctx[12] ? 'display: none' : '')) {
				attr(div0, "style", div0_style_value);
			}

			if (!current || dirty[0] & /*fullScreen*/ 64) {
				toggle_class(div0, "fullscreen-footer", /*fullScreen*/ ctx[6]);
			}

			if (!current || dirty[0] & /*fullScreen*/ 64) {
				toggle_class(div1, "fullscreen-dialog", /*fullScreen*/ ctx[6]);
			}

			if (!current || dirty[0] & /*expand*/ 32) {
				toggle_class(div1, "uk-modal-container", /*expand*/ ctx[5]);
			}

			if (!current || dirty[0] & /*verticallyCentered*/ 512) {
				toggle_class(div1, "uk-margin-auto-vertical", /*verticallyCentered*/ ctx[9]);
			}

			if (!current || dirty[0] & /*className*/ 8 && div2_class_value !== (div2_class_value = "" + (null_to_empty(/*className*/ ctx[3]) + " svelte-xn439w"))) {
				attr(div2, "class", div2_class_value);
			}

			if (!current || dirty[0] & /*style*/ 4) {
				attr(div2, "style", /*style*/ ctx[2]);
			}

			if (!current || dirty[0] & /*id*/ 2) {
				attr(div2, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty[0] & /*closeable, stack*/ 1152 && div2_uk_modal_value !== (div2_uk_modal_value = `esc-close: ${/*closeable*/ ctx[7]}; bg-close: ${/*closeable*/ ctx[7]}; stack: ${/*stack*/ ctx[10]}`)) {
				attr(div2, "uk-modal", div2_uk_modal_value);
			}

			if (!current || dirty[0] & /*className, fullScreen*/ 72) {
				toggle_class(div2, "uk-modal-full", /*fullScreen*/ ctx[6]);
			}

			if (!current || dirty[0] & /*className, verticallyCentered*/ 520) {
				toggle_class(div2, "uk-flex-top", /*verticallyCentered*/ ctx[9]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(if_block2);
			transition_in(footer_slot_or_fallback, local);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			transition_out(if_block2);
			transition_out(footer_slot_or_fallback, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div2);
			}

			if (if_block0) if_block0.d();
			if_blocks[current_block_type_index].d();
			if_blocks_1[current_block_type_index_1].d();
			if (footer_slot_or_fallback) footer_slot_or_fallback.d(detaching);
			/*div2_binding*/ ctx[30](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$r($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id = undefined } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { title = undefined } = $$props;
	let { expand = false } = $$props;
	let { fullScreen = false } = $$props;
	let { closeable = true } = $$props;
	let { closeButton = "default" } = $$props;
	let { verticallyCentered = true } = $$props;
	let { ref = undefined } = $$props;
	let { show = false } = $$props;
	let { shown = false } = $$props;
	let { stack = true } = $$props;
	let externalAssignment = true;

	onDestroy(() => {
		if (show) {
			dispatchCustomEvent(ref, 'hide');
		}

		if (shown) {
			dispatchCustomEvent(ref, 'hidden');
		}
	});

	function handleShow() {
		$$invalidate(19, externalAssignment = false);
		$$invalidate(17, show = true);
	}

	function handleHide() {
		$$invalidate(19, externalAssignment = false);
		$$invalidate(17, show = false);
	}

	let previouslyFocusedRef;

	function handleShown() {
		$$invalidate(18, shown = true);
		previouslyFocusedRef = document.activeElement;
		ref && ref.focus();
	}

	async function handleHidden() {
		$$invalidate(18, shown = false);
		await tick();
		previouslyFocusedRef && previouslyFocusedRef.focus();
	}

	let noHeader;
	let noFooter;

	function show_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function shown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hidden_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeshow_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			noHeader = $$value;
			$$invalidate(11, noHeader);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			noFooter = $$value;
			$$invalidate(12, noFooter);
		});
	}

	function div2_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('className' in $$props) $$invalidate(3, className = $$props.className);
		if ('title' in $$props) $$invalidate(4, title = $$props.title);
		if ('expand' in $$props) $$invalidate(5, expand = $$props.expand);
		if ('fullScreen' in $$props) $$invalidate(6, fullScreen = $$props.fullScreen);
		if ('closeable' in $$props) $$invalidate(7, closeable = $$props.closeable);
		if ('closeButton' in $$props) $$invalidate(8, closeButton = $$props.closeButton);
		if ('verticallyCentered' in $$props) $$invalidate(9, verticallyCentered = $$props.verticallyCentered);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('show' in $$props) $$invalidate(17, show = $$props.show);
		if ('shown' in $$props) $$invalidate(18, shown = $$props.shown);
		if ('stack' in $$props) $$invalidate(10, stack = $$props.stack);
		if ('$$scope' in $$props) $$invalidate(20, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*ref, externalAssignment, show*/ 655361) {
			if (ref) {
				if (externalAssignment) {
					if (show && !ref.classList.contains('uk-open')) {
						UIkit.modal(ref).show();
					} else if (!show && ref.classList.contains('uk-open')) {
						UIkit.modal(ref).hide();

						if (document.querySelectorAll('.uk-modal.uk-open').length <= 1) {
							document.documentElement.classList.remove('uk-modal-page');
						}
					}
				}

				$$invalidate(19, externalAssignment = true);
			}
		}
	};

	return [
		ref,
		id,
		style,
		className,
		title,
		expand,
		fullScreen,
		closeable,
		closeButton,
		verticallyCentered,
		stack,
		noHeader,
		noFooter,
		handleShow,
		handleHide,
		handleShown,
		handleHidden,
		show,
		shown,
		externalAssignment,
		$$scope,
		slots,
		show_handler,
		hide_handler,
		shown_handler,
		hidden_handler,
		beforeshow_handler,
		beforehide_handler,
		div_binding,
		div_binding_1,
		div2_binding
	];
}

class Modal extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$r,
			create_fragment$r,
			safe_not_equal,
			{
				id: 1,
				style: 2,
				className: 3,
				title: 4,
				expand: 5,
				fullScreen: 6,
				closeable: 7,
				closeButton: 8,
				verticallyCentered: 9,
				ref: 0,
				show: 17,
				shown: 18,
				stack: 10
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/Nav.svelte generated by Svelte v4.2.19 */

function create_fragment$q(ctx) {
	let nav;
	let nav_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			nav = element("nav");
			if (default_slot) default_slot.c();
			attr(nav, "class", nav_class_value = "uk-navbar-container " + (/*className*/ ctx[2] || ''));
			attr(nav, "uk-navbar", "");
			attr(nav, "style", /*style*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, nav, anchor);

			if (default_slot) {
				default_slot.m(nav, null);
			}

			/*nav_binding*/ ctx[5](nav);
			current = true;
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*className*/ 4 && nav_class_value !== (nav_class_value = "uk-navbar-container " + (/*className*/ ctx[2] || ''))) {
				attr(nav, "class", nav_class_value);
			}

			if (!current || dirty & /*style*/ 2) {
				attr(nav, "style", /*style*/ ctx[1]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(nav);
			}

			if (default_slot) default_slot.d(detaching);
			/*nav_binding*/ ctx[5](null);
		}
	};
}

function instance$q($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { ref = undefined } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;

	function nav_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('style' in $$props) $$invalidate(1, style = $$props.style);
		if ('className' in $$props) $$invalidate(2, className = $$props.className);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [ref, style, className, $$scope, slots, nav_binding];
}

class Nav extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$q, create_fragment$q, safe_not_equal, { ref: 0, style: 1, className: 2 });
	}
}

/* src/components/Offcanvas.svelte generated by Svelte v4.2.19 */

function create_fragment$p(ctx) {
	let div1;
	let div0;
	let button;
	let t;
	let div1_uk_offcanvas_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			div1 = element("div");
			div0 = element("div");
			button = element("button");
			t = space();
			if (default_slot) default_slot.c();
			attr(button, "class", "uk-offcanvas-close");
			attr(button, "type", "button");
			attr(button, "uk-close", "");
			attr(div0, "class", "uk-offcanvas-bar");
			attr(div1, "tabindex", "0");
			attr(div1, "id", /*id*/ ctx[1]);
			attr(div1, "uk-offcanvas", div1_uk_offcanvas_value = "overlay: true; flip: " + (/*side*/ ctx[2] === 'left' ? 'false' : 'true') + "; mode: slide");
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			append(div1, div0);
			append(div0, button);
			append(div0, t);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			/*div1_binding*/ ctx[21](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(div0, "click", /*click_handler*/ ctx[20]),
					listen(div1, "show", /*handleShow*/ ctx[4]),
					listen(div1, "hide", /*handleHide*/ ctx[5]),
					listen(div1, "shown", /*handleShown*/ ctx[6]),
					listen(div1, "hidden", /*handleHidden*/ ctx[7]),
					listen(div1, "show", stop_propagation(/*show_handler*/ ctx[14])),
					listen(div1, "hide", stop_propagation(/*hide_handler*/ ctx[15])),
					listen(div1, "shown", stop_propagation(/*shown_handler*/ ctx[16])),
					listen(div1, "hidden", stop_propagation(/*hidden_handler*/ ctx[17])),
					listen(div1, "beforeshow", stop_propagation(/*beforeshow_handler*/ ctx[18])),
					listen(div1, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[19])),
					listen(div1, "click", /*closeOnOuterClick*/ ctx[8])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*id*/ 2) {
				attr(div1, "id", /*id*/ ctx[1]);
			}

			if (!current || dirty & /*side*/ 4 && div1_uk_offcanvas_value !== (div1_uk_offcanvas_value = "overlay: true; flip: " + (/*side*/ ctx[2] === 'left' ? 'false' : 'true') + "; mode: slide")) {
				attr(div1, "uk-offcanvas", div1_uk_offcanvas_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (default_slot) default_slot.d(detaching);
			/*div1_binding*/ ctx[21](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { id = generateId() } = $$props;
	let { show = false } = $$props;
	let { shown = false } = $$props;
	let { ref = undefined } = $$props;
	let { side = "left" } = $$props;
	let externalAssignment = true;

	function handleShow() {
		$$invalidate(11, externalAssignment = false);
		$$invalidate(9, show = true);
	}

	function handleHide() {
		$$invalidate(11, externalAssignment = false);
		$$invalidate(9, show = false);
	}

	let previouslyFocusedRef;

	function handleShown() {
		$$invalidate(10, shown = true);
		previouslyFocusedRef = document.activeElement;
		ref && ref.focus();
	}

	async function handleHidden() {
		$$invalidate(10, shown = false);
		await tick();
		previouslyFocusedRef && previouslyFocusedRef.focus();
	}

	onDestroy(() => {
		if (show) {
			dispatchCustomEvent(ref, 'hide');
		}

		if (shown) {
			dispatchCustomEvent(ref, 'hidden');
		}
	});

	let innerClick = false;

	function closeOnOuterClick() {
		if (!innerClick && show) {
			$$invalidate(9, show = false);
		}

		$$invalidate(3, innerClick = false);
	}

	function show_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function shown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hidden_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeshow_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler = () => $$invalidate(3, innerClick = true);

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(1, id = $$props.id);
		if ('show' in $$props) $$invalidate(9, show = $$props.show);
		if ('shown' in $$props) $$invalidate(10, shown = $$props.shown);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('side' in $$props) $$invalidate(2, side = $$props.side);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ref, externalAssignment, show*/ 2561) {
			if (ref) {
				if (externalAssignment) {
					if (show && !ref.classList.contains('uk-open')) {
						UIkit.offcanvas(ref).show();
					} else if (!show && ref.classList.contains('uk-open')) {
						UIkit.offcanvas(ref).hide();
					}
				}

				$$invalidate(11, externalAssignment = true);
			}
		}
	};

	return [
		ref,
		id,
		side,
		innerClick,
		handleShow,
		handleHide,
		handleShown,
		handleHidden,
		closeOnOuterClick,
		show,
		shown,
		externalAssignment,
		$$scope,
		slots,
		show_handler,
		hide_handler,
		shown_handler,
		hidden_handler,
		beforeshow_handler,
		beforehide_handler,
		click_handler,
		div1_binding
	];
}

class Offcanvas extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
			id: 1,
			show: 9,
			shown: 10,
			ref: 0,
			side: 2
		});
	}
}

/* src/components/OrderableList.svelte generated by Svelte v4.2.19 */

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[26] = list[i];
	child_ctx[28] = i;
	return child_ctx;
}

// (108:5) {#if moveToBoundaries}
function create_if_block_6$1(ctx) {
	let span;
	let span_disabled_value;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[12](/*index*/ ctx[28]);
	}

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[13](/*index*/ ctx[28], ...args);
	}

	return {
		c() {
			span = element("span");
			attr(span, "uk-icon", "icon: chevron-double-up; ratio: 1.2");
			attr(span, "role", "button");
			attr(span, "tabindex", "0");
			attr(span, "disabled", span_disabled_value = /*index*/ ctx[28] === 0);
			attr(span, "class", "svelte-1ievbgr");
			toggle_class(span, "cursor-pointer", /*index*/ ctx[28] > 0);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (!mounted) {
				dispose = [
					listen(span, "click", click_handler),
					listen(span, "keyup", keyup_handler)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*items*/ 1 && span_disabled_value !== (span_disabled_value = /*index*/ ctx[28] === 0)) {
				attr(span, "disabled", span_disabled_value);
			}

			if (dirty & /*items*/ 1) {
				toggle_class(span, "cursor-pointer", /*index*/ ctx[28] > 0);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (136:5) {#if moveToBoundaries}
function create_if_block_5$1(ctx) {
	let span;
	let span_disabled_value;
	let mounted;
	let dispose;

	function click_handler_3() {
		return /*click_handler_3*/ ctx[18](/*index*/ ctx[28]);
	}

	function keyup_handler_3(...args) {
		return /*keyup_handler_3*/ ctx[19](/*index*/ ctx[28], ...args);
	}

	return {
		c() {
			span = element("span");
			attr(span, "uk-icon", "icon: chevron-double-down; ratio: 1.2");
			attr(span, "role", "button");
			attr(span, "tabindex", "0");
			attr(span, "disabled", span_disabled_value = /*index*/ ctx[28] >= /*items*/ ctx[0].length - 1);
			attr(span, "class", "svelte-1ievbgr");
			toggle_class(span, "cursor-pointer", /*index*/ ctx[28] < /*items*/ ctx[0].length - 1);
		},
		m(target, anchor) {
			insert(target, span, anchor);

			if (!mounted) {
				dispose = [
					listen(span, "click", click_handler_3),
					listen(span, "keyup", keyup_handler_3)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*items*/ 1 && span_disabled_value !== (span_disabled_value = /*index*/ ctx[28] >= /*items*/ ctx[0].length - 1)) {
				attr(span, "disabled", span_disabled_value);
			}

			if (dirty & /*items*/ 1) {
				toggle_class(span, "cursor-pointer", /*index*/ ctx[28] < /*items*/ ctx[0].length - 1);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (167:5) {:else}
function create_else_block$4(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*item*/ ctx[26].props || {}];
	var switch_value = /*item*/ ctx[26].component || /*component*/ ctx[2];

	function switch_props(ctx, dirty) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		if (dirty !== undefined && dirty & /*items*/ 1) {
			switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[26].props || {})]));
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*items, component*/ 5 && switch_value !== (switch_value = /*item*/ ctx[26].component || /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = (dirty & /*items*/ 1)
				? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[26].props || {})])
				: {};

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (161:25) 
function create_if_block_4$1(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*item*/ ctx[26].props || {}];
	var switch_value = /*item*/ ctx[26].component || /*component*/ ctx[2];

	function switch_props(ctx, dirty) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot_1] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		if (dirty !== undefined && dirty & /*items*/ 1) {
			switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[26].props || {})]));
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*items, component*/ 5 && switch_value !== (switch_value = /*item*/ ctx[26].component || /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = (dirty & /*items*/ 1)
				? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[26].props || {})])
				: {};

				if (dirty & /*$$scope, items*/ 536870913) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (155:25) 
function create_if_block_3$3(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*item*/ ctx[26].props || {}];
	var switch_value = /*item*/ ctx[26].component || /*component*/ ctx[2];

	function switch_props(ctx, dirty) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot$e] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		if (dirty !== undefined && dirty & /*items*/ 1) {
			switch_instance_props = assign(switch_instance_props, get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[26].props || {})]));
		}

		return { props: switch_instance_props };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
	}

	return {
		c() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		m(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert(target, switch_instance_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			if (dirty & /*items, component*/ 5 && switch_value !== (switch_value = /*item*/ ctx[26].component || /*component*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component(switch_value, switch_props(ctx, dirty));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				const switch_instance_changes = (dirty & /*items*/ 1)
				? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*item*/ ctx[26].props || {})])
				: {};

				if (dirty & /*$$scope, items*/ 536870913) {
					switch_instance_changes.$$scope = { dirty, ctx };
				}

				switch_instance.$set(switch_instance_changes);
			}
		},
		i(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(switch_instance_anchor);
			}

			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};
}

// (151:5) {#if !component && !item.component}
function create_if_block$b(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*item*/ ctx[26].html) return create_if_block_1$4;
		if (/*item*/ ctx[26].text) return create_if_block_2$3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) {
				if_block.d(detaching);
			}
		}
	};
}

// (162:6) <svelte:component        this={item.component || component}        {...item.props || {}}>
function create_default_slot_1(ctx) {
	let html_tag;
	let raw_value = /*item*/ ctx[26].html + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*items*/ 1 && raw_value !== (raw_value = /*item*/ ctx[26].html + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

// (156:6) <svelte:component        this={item.component || component}        {...item.props || {}}>
function create_default_slot$e(ctx) {
	let t_value = /*item*/ ctx[26].text + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[26].text + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (154:26) 
function create_if_block_2$3(ctx) {
	let t_value = /*item*/ ctx[26].text + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*items*/ 1 && t_value !== (t_value = /*item*/ ctx[26].text + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (152:6) {#if item.html}
function create_if_block_1$4(ctx) {
	let html_tag;
	let raw_value = /*item*/ ctx[26].html + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*items*/ 1 && raw_value !== (raw_value = /*item*/ ctx[26].html + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

// (101:1) {#each items as item, index (item)}
function create_each_block$6(key_1, ctx) {
	let li;
	let div3;
	let div0;
	let t0;
	let span0;
	let span0_disabled_value;
	let t1;
	let span1;
	let span1_disabled_value;
	let t2;
	let t3;
	let div1;
	let t4;
	let div2;
	let current_block_type_index;
	let if_block2;
	let t5;
	let rect;
	let stop_animation = noop$1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*moveToBoundaries*/ ctx[3] && create_if_block_6$1(ctx);

	function click_handler_1() {
		return /*click_handler_1*/ ctx[14](/*index*/ ctx[28]);
	}

	function keyup_handler_1(...args) {
		return /*keyup_handler_1*/ ctx[15](/*index*/ ctx[28], ...args);
	}

	function click_handler_2() {
		return /*click_handler_2*/ ctx[16](/*index*/ ctx[28]);
	}

	function keyup_handler_2(...args) {
		return /*keyup_handler_2*/ ctx[17](/*index*/ ctx[28], ...args);
	}

	let if_block1 = /*moveToBoundaries*/ ctx[3] && create_if_block_5$1(ctx);
	const if_block_creators = [create_if_block$b, create_if_block_3$3, create_if_block_4$1, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (!/*component*/ ctx[2] && !/*item*/ ctx[26].component) return 0;
		if (/*item*/ ctx[26].text) return 1;
		if (/*item*/ ctx[26].html) return 2;
		return 3;
	}

	current_block_type_index = select_block_type(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			div3 = element("div");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space();
			span0 = element("span");
			t1 = space();
			span1 = element("span");
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			div1 = element("div");
			div1.innerHTML = `<hr class="uk-divider-vertical uk-height-1-1"/>`;
			t4 = space();
			div2 = element("div");
			if_block2.c();
			t5 = space();
			attr(span0, "uk-icon", "icon: chevron-up; ratio: 1.2");
			attr(span0, "role", "button");
			attr(span0, "tabindex", "0");
			attr(span0, "disabled", span0_disabled_value = /*index*/ ctx[28] === 0);
			attr(span0, "class", "svelte-1ievbgr");
			toggle_class(span0, "cursor-pointer", /*index*/ ctx[28] > 0);
			attr(span1, "uk-icon", "icon: chevron-down; ratio: 1.2");
			attr(span1, "role", "button");
			attr(span1, "tabindex", "0");
			attr(span1, "disabled", span1_disabled_value = /*index*/ ctx[28] >= /*items*/ ctx[0].length - 1);
			attr(span1, "class", "svelte-1ievbgr");
			toggle_class(span1, "cursor-pointer", /*index*/ ctx[28] < /*items*/ ctx[0].length - 1);
			attr(div0, "class", "uk-flex uk-flex-column uk-flex-center uk-margin-small-right");
			attr(div1, "class", "uk-margin-small-right");
			attr(div2, "class", "uk-width-expand");
			attr(div3, "class", "uk-flex");
			attr(li, "class", "uk-box-shadow-medium uk-padding-small uk-background-default ");
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, div3);
			append(div3, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);
			append(div0, span0);
			append(div0, t1);
			append(div0, span1);
			append(div0, t2);
			if (if_block1) if_block1.m(div0, null);
			append(div3, t3);
			append(div3, div1);
			append(div3, t4);
			append(div3, div2);
			if_blocks[current_block_type_index].m(div2, null);
			append(li, t5);
			current = true;

			if (!mounted) {
				dispose = [
					listen(span0, "click", click_handler_1),
					listen(span0, "keyup", keyup_handler_1),
					listen(span1, "click", click_handler_2),
					listen(span1, "keyup", keyup_handler_2)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (/*moveToBoundaries*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_6$1(ctx);
					if_block0.c();
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty & /*items*/ 1 && span0_disabled_value !== (span0_disabled_value = /*index*/ ctx[28] === 0)) {
				attr(span0, "disabled", span0_disabled_value);
			}

			if (!current || dirty & /*items*/ 1) {
				toggle_class(span0, "cursor-pointer", /*index*/ ctx[28] > 0);
			}

			if (!current || dirty & /*items*/ 1 && span1_disabled_value !== (span1_disabled_value = /*index*/ ctx[28] >= /*items*/ ctx[0].length - 1)) {
				attr(span1, "disabled", span1_disabled_value);
			}

			if (!current || dirty & /*items*/ 1) {
				toggle_class(span1, "cursor-pointer", /*index*/ ctx[28] < /*items*/ ctx[0].length - 1);
			}

			if (/*moveToBoundaries*/ ctx[3]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_5$1(ctx);
					if_block1.c();
					if_block1.m(div0, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div2, null);
			}
		},
		r() {
			rect = li.getBoundingClientRect();
		},
		f() {
			fix_position(li);
			stop_animation();
		},
		a() {
			stop_animation();
			stop_animation = create_animation(li, rect, /*animation*/ ctx[10], {});
		},
		i(local) {
			if (current) return;
			transition_in(if_block2);
			current = true;
		},
		o(local) {
			transition_out(if_block2);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if_blocks[current_block_type_index].d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$o(ctx) {
	let ul;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let ul_class_value;
	let current;
	let each_value = ensure_array_like(/*items*/ ctx[0]);
	const get_key = ctx => /*item*/ ctx[26];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$6(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
	}

	return {
		c() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(ul, "class", ul_class_value = "" + (null_to_empty(/*className*/ ctx[5]) + " svelte-1ievbgr"));
			attr(ul, "style", /*style*/ ctx[4]);
			toggle_class(ul, "uk-list", true);
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			/*ul_binding*/ ctx[20](ul);
			current = true;
		},
		p(ctx, [dirty]) {
			if (dirty & /*items, component, moveBottom, moveToBoundaries, moveDown, moveUp, moveTop*/ 973) {
				each_value = ensure_array_like(/*items*/ ctx[0]);
				group_outros();
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block$6, null, get_each_context$6);
				for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
				check_outros();
			}

			if (!current || dirty & /*className*/ 32 && ul_class_value !== (ul_class_value = "" + (null_to_empty(/*className*/ ctx[5]) + " svelte-1ievbgr"))) {
				attr(ul, "class", ul_class_value);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(ul, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*className*/ 32) {
				toggle_class(ul, "uk-list", true);
			}
		},
		i(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o(local) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(ul);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*ul_binding*/ ctx[20](null);
		}
	};
}

function instance$o($$self, $$props, $$invalidate) {
	let { items = [] } = $$props;
	let { component = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { animationDuration = 200 } = $$props;
	let { moveToBoundaries = false } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	const dispatch = createEventDispatcher();
	let foregroundElement = null;
	let focusOnMoved = null;
	let lastEventDetails = null;

	function move(prevIndex, newIndex) {
		foregroundElement = ref.children[prevIndex];
		focusOnMoved = document.activeElement;
		const subject = items.splice(prevIndex, 1)[0];
		items.splice(newIndex, 0, subject);
		$$invalidate(0, items = [...items]);
		lastEventDetails = { old: prevIndex, new: newIndex };
		dispatch("move", lastEventDetails);
	}

	function moveUp(index) {
		move(index, index - 1);
	}

	function moveDown(index) {
		move(index, index + 1);
	}

	function moveTop(index) {
		move(index, 0);
	}

	function moveBottom(index) {
		move(index, items.length - 1);
	}

	function animation(node, { from, to }) {
		const dx = from.left - to.left;
		const dy = from.top - to.top;
		const isForeground = node === foregroundElement;

		return {
			delay: 0,
			duration: animationDuration,
			easing: cubicInOut,
			css: (t, u) => {
				const ratio = 1 + (isForeground
				? (0.5 - Math.abs(t - 0.5)) / 25
				: -(0.5 - Math.abs(u - 0.5)) / 25);

				return `
					position: relative;
					transform: translate(${u * dx}px, ${u * dy}px) scale(${ratio});
					z-index: ${isForeground ? "1" : "0"};
				`;
			},
			tick: t => {
				if (t === 1 && isForeground) {
					dispatch("moved", lastEventDetails);

					tick().then(() => {
						focusOnMoved && focusOnMoved.focus();
					});
				}
			}
		};
	}

	const click_handler = index => index > 0 && moveTop(index);
	const keyup_handler = (index, e) => ['Enter'].includes(e.code) && index > 0 && moveTop(index);
	const click_handler_1 = index => index > 0 && moveUp(index);
	const keyup_handler_1 = (index, e) => ['Enter'].includes(e.code) && index > 0 && moveUp(index);
	const click_handler_2 = index => index < items.length - 1 && moveDown(index);
	const keyup_handler_2 = (index, e) => ['Enter'].includes(e.code) && index < items.length - 1 && moveDown(index);
	const click_handler_3 = index => index < items.length - 1 && moveBottom(index);
	const keyup_handler_3 = (index, e) => ['Enter'].includes(e.code) && index < items.length - 1 && moveBottom(index);

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('items' in $$props) $$invalidate(0, items = $$props.items);
		if ('component' in $$props) $$invalidate(2, component = $$props.component);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('animationDuration' in $$props) $$invalidate(11, animationDuration = $$props.animationDuration);
		if ('moveToBoundaries' in $$props) $$invalidate(3, moveToBoundaries = $$props.moveToBoundaries);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('className' in $$props) $$invalidate(5, className = $$props.className);
	};

	return [
		items,
		ref,
		component,
		moveToBoundaries,
		style,
		className,
		moveUp,
		moveDown,
		moveTop,
		moveBottom,
		animation,
		animationDuration,
		click_handler,
		keyup_handler,
		click_handler_1,
		keyup_handler_1,
		click_handler_2,
		keyup_handler_2,
		click_handler_3,
		keyup_handler_3,
		ul_binding
	];
}

class OrderableList extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
			items: 0,
			component: 2,
			ref: 1,
			animationDuration: 11,
			moveToBoundaries: 3,
			style: 4,
			className: 5
		});
	}
}

const windowSize = readable({
	width: window.innerWidth,
	height: window.innerHeight,
}, (set) => {
	let previousWidth = null;
	let previousHeight = null;
	let timeout = 0;
	function update() {
		if (timeout) {
			cancelAnimationFrame(timeout);
		}
		timeout = requestAnimationFrame(() => {
			if (previousWidth !== window.innerWidth || previousHeight !== window.innerHeight) {
				previousWidth = window.innerWidth;
				previousHeight = window.innerHeight;
				set({
					width: window.innerWidth,
					height: window.innerHeight,
				});
			}
		});
	}
	window.addEventListener('resize', update);
	return () => {
		window.removeEventListener('resize', update);
	};
});

const innerWidth = derived(windowSize, ($windowSize) => $windowSize.width);

derived(windowSize, ($windowSize) => $windowSize.height);

const windowScroll = readable({
	x: window.scrollX,
	y: window.scrollY,
}, (set) => {
	let previousX = null;
	let previousY = null;
	let timeout = 0;
	function update() {
		if (timeout) {
			cancelAnimationFrame(timeout);
		}
		timeout = requestAnimationFrame(() => {
			if (previousX !== window.scrollX || previousY !== window.scrollY) {
				previousX = window.scrollX;
				previousY = window.scrollY;
				set({
					x: window.scrollX,
					y: window.scrollY,
				});
			}
		});
	}
	window.addEventListener('scroll', update);
	return () => {
		window.removeEventListener('scroll', update);
	};
});

derived(windowScroll, ($windowScroll) => $windowScroll.x);

const scrollY = derived(windowScroll, ($windowScroll) => $windowScroll.y);

const Size = {
	xs: 0,
	s: 1,
	m: 2,
	l: 3,
	xl: 4,
};

function getBreakpoints() {
	const documentComputedStyle = getComputedStyle(document.documentElement);
	return {
		[Size.xs]: 0,
		[Size.s]: Number(documentComputedStyle
			.getPropertyValue('--uk-breakpoint-s').slice(0, -2)),
		[Size.m]: Number(documentComputedStyle
			.getPropertyValue('--uk-breakpoint-m').slice(0, -2)),
		[Size.l]: Number(documentComputedStyle
			.getPropertyValue('--uk-breakpoint-l').slice(0, -2)),
		[Size.xl]: Number(documentComputedStyle
			.getPropertyValue('--uk-breakpoint-xl').slice(0, -2)),
	};
}

const breakpoints = readable(getBreakpoints(), (set) => {
	function update() {
		set(getBreakpoints());
	}

	window.addEventListener('load', update);

	return () => {
		window.removeEventListener('load', update);
	};
});

derived([innerWidth, breakpoints], ([$innerWidth, $breakpoints]) => {
	if ($innerWidth >= $breakpoints[Size.xl]) {
		return Size.xl;
	}
	if ($innerWidth >= $breakpoints[Size.l]) {
		return Size.l;
	}
	if ($innerWidth >= $breakpoints[Size.m]) {
		return Size.m;
	}
	if ($innerWidth >= $breakpoints[Size.s]) {
		return Size.s;
	}
	return Size.xs;
});

/* src/components/ScrollableNav.svelte generated by Svelte v4.2.19 */

function create_default_slot$d(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

	return {
		c() {
			if (default_slot) default_slot.c();
		},
		m(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};
}

// (100:0) {#if spacer}
function create_if_block$a(ctx) {
	let div;

	return {
		c() {
			div = element("div");
			set_style(div, "height", /*height*/ ctx[1] + "px");
			set_style(div, "width", "100%");
		},
		m(target, anchor) {
			insert(target, div, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*height*/ 2) {
				set_style(div, "height", /*height*/ ctx[1] + "px");
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

function create_fragment$n(ctx) {
	let div;
	let nav;
	let updating_ref;
	let div_style_value;
	let t;
	let if_block_anchor;
	let current;

	function nav_ref_binding(value) {
		/*nav_ref_binding*/ ctx[11](value);
	}

	let nav_props = {
		style: /*navStyle*/ ctx[4],
		className: /*navClassName*/ ctx[5],
		$$slots: { default: [create_default_slot$d] },
		$$scope: { ctx }
	};

	if (/*scrollableNav*/ ctx[7] !== void 0) {
		nav_props.ref = /*scrollableNav*/ ctx[7];
	}

	nav = new Nav({ props: nav_props });
	binding_callbacks.push(() => bind(nav, 'ref', nav_ref_binding));
	let if_block = /*spacer*/ ctx[6] && create_if_block$a(ctx);

	return {
		c() {
			div = element("div");
			create_component(nav.$$.fragment);
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			attr(div, "class", /*className*/ ctx[3]);
			attr(div, "style", div_style_value = "position:absolute;top:0;left:0;width:100%;z-index:980;" + (/*style*/ ctx[2] || ''));
		},
		m(target, anchor) {
			insert(target, div, anchor);
			mount_component(nav, div, null);
			/*div_binding*/ ctx[12](div);
			insert(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const nav_changes = {};
			if (dirty & /*navStyle*/ 16) nav_changes.style = /*navStyle*/ ctx[4];
			if (dirty & /*navClassName*/ 32) nav_changes.className = /*navClassName*/ ctx[5];

			if (dirty & /*$$scope*/ 8192) {
				nav_changes.$$scope = { dirty, ctx };
			}

			if (!updating_ref && dirty & /*scrollableNav*/ 128) {
				updating_ref = true;
				nav_changes.ref = /*scrollableNav*/ ctx[7];
				add_flush_callback(() => updating_ref = false);
			}

			nav.$set(nav_changes);

			if (!current || dirty & /*className*/ 8) {
				attr(div, "class", /*className*/ ctx[3]);
			}

			if (!current || dirty & /*style*/ 4 && div_style_value !== (div_style_value = "position:absolute;top:0;left:0;width:100%;z-index:980;" + (/*style*/ ctx[2] || ''))) {
				attr(div, "style", div_style_value);
			}

			if (/*spacer*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$a(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(nav.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(nav.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
				detach(t);
				detach(if_block_anchor);
			}

			destroy_component(nav);
			/*div_binding*/ ctx[12](null);
			if (if_block) if_block.d(detaching);
		}
	};
}

function instance$n($$self, $$props, $$invalidate) {
	let ready;
	let $scrollY;
	component_subscribe($$self, scrollY, $$value => $$invalidate(9, $scrollY = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { navStyle = undefined } = $$props;
	let { navClassName = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { height = 0 } = $$props;
	let { spacer = true } = $$props;
	let scrollableNav;
	let animationFrameId = null;
	let oldY = $scrollY;
	let accumulatorY = 0;

	function updateNavbar() {
		if (animationFrameId) {
			window.cancelAnimationFrame(animationFrameId);
		}

		const newY = $scrollY;

		animationFrameId = window.requestAnimationFrame(() => {
			accumulatorY = Math.min(0, Math.max(-ref.offsetHeight, accumulatorY - (newY - oldY)));

			if (newY < 0) {
				accumulatorY = 0;
			}

			if (accumulatorY === 0) {
				$$invalidate(0, ref.style.position = "fixed", ref);
				$$invalidate(0, ref.style.top = "0", ref);
			} else {
				$$invalidate(0, ref.style.position = "absolute", ref);
				$$invalidate(0, ref.style.top = accumulatorY + newY + "px", ref);
			}

			oldY = newY;
		});
	}

	/** @type {ResizeObserver} */
	let observer = null;

	onMount(() => {
		if (window.ResizeObserver) {
			observer = new ResizeObserver(() => {
					if (ref) {
						$$invalidate(1, height = ref.offsetHeight);
					}
				});

			observer.observe(ref);
		}
	});

	onDestroy(() => {
		if (observer) {
			observer.disconnect();
			observer = null;
		}
	});

	function nav_ref_binding(value) {
		scrollableNav = value;
		$$invalidate(7, scrollableNav);
	}

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('style' in $$props) $$invalidate(2, style = $$props.style);
		if ('className' in $$props) $$invalidate(3, className = $$props.className);
		if ('navStyle' in $$props) $$invalidate(4, navStyle = $$props.navStyle);
		if ('navClassName' in $$props) $$invalidate(5, navClassName = $$props.navClassName);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('height' in $$props) $$invalidate(1, height = $$props.height);
		if ('spacer' in $$props) $$invalidate(6, spacer = $$props.spacer);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ref*/ 1) {
			$$invalidate(8, ready = Boolean(ref));
		}

		if ($$self.$$.dirty & /*$scrollY, ready*/ 768) {
			(ready && updateNavbar());
		}
	};

	return [
		ref,
		height,
		style,
		className,
		navStyle,
		navClassName,
		spacer,
		scrollableNav,
		ready,
		$scrollY,
		slots,
		nav_ref_binding,
		div_binding,
		$$scope
	];
}

class ScrollableNav extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
			style: 2,
			className: 3,
			navStyle: 4,
			navClassName: 5,
			ref: 0,
			height: 1,
			spacer: 6
		});
	}
}

/* src/components/Switcher.svelte generated by Svelte v4.2.19 */

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i];
	child_ctx[27] = i;
	return child_ctx;
}

// (59:8) {:else}
function create_else_block$3(ctx) {
	let t_value = /*title*/ ctx[25] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*titles*/ 512 && t_value !== (t_value = /*title*/ ctx[25] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (57:8) {#if htmlTitle}
function create_if_block$9(ctx) {
	let html_tag;
	let raw_value = /*title*/ ctx[25] + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*titles*/ 512 && raw_value !== (raw_value = /*title*/ ctx[25] + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

// (53:2) {#each titles as title, i (title)}
function create_each_block$5(key_1, ctx) {
	let li;
	let a;
	let t;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*htmlTitle*/ ctx[10]) return create_if_block$9;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[22](/*i*/ ctx[27], ...args);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			a = element("a");
			if_block.c();
			t = space();
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			if_block.m(a, null);
			append(li, t);

			if (!mounted) {
				dispose = listen(a, "keyup", keyup_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(a, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$m(ctx) {
	let ul0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let ul0_uk_switcher_value;
	let t;
	let ul1;
	let current;
	let mounted;
	let dispose;
	let each_value = ensure_array_like(/*titles*/ ctx[9]);
	const get_key = ctx => /*title*/ ctx[25];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$5(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
	}

	const default_slot_template = /*#slots*/ ctx[15].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

	return {
		c() {
			ul0 = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			ul1 = element("ul");
			if (default_slot) default_slot.c();
			attr(ul0, "style", /*style*/ ctx[7]);
			attr(ul0, "class", /*className*/ ctx[8]);
			attr(ul0, "uk-switcher", ul0_uk_switcher_value = `connect: ${/*connect*/ ctx[2]}; toggle: ${/*toggle*/ ctx[3]}; animation: ${/*animation*/ ctx[4]}; duration: ${/*duration*/ ctx[5]}; swiping: ${/*swiping*/ ctx[6]}`);
			toggle_class(ul0, "uk-subnav", true);
			toggle_class(ul0, "uk-subnav-pill", true);
			attr(ul1, "class", "uk-switcher");
		},
		m(target, anchor) {
			insert(target, ul0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul0, null);
				}
			}

			/*ul0_binding*/ ctx[23](ul0);
			insert(target, t, anchor);
			insert(target, ul1, anchor);

			if (default_slot) {
				default_slot.m(ul1, null);
			}

			/*ul1_binding*/ ctx[24](ul1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(ul1, "show", /*handleShow*/ ctx[13]),
					listen(ul1, "show", stop_propagation(/*show_handler*/ ctx[16])),
					listen(ul1, "hide", stop_propagation(/*hide_handler*/ ctx[17])),
					listen(ul1, "shown", stop_propagation(/*shown_handler*/ ctx[18])),
					listen(ul1, "hidden", stop_propagation(/*hidden_handler*/ ctx[19])),
					listen(ul1, "beforeshow", stop_propagation(/*beforeshow_handler*/ ctx[20])),
					listen(ul1, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[21]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*externalAssignment, index, titles, ref, htmlTitle*/ 3587) {
				each_value = ensure_array_like(/*titles*/ ctx[9]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul0, destroy_block, create_each_block$5, null, get_each_context$5);
			}

			if (!current || dirty & /*style*/ 128) {
				attr(ul0, "style", /*style*/ ctx[7]);
			}

			if (!current || dirty & /*className*/ 256) {
				attr(ul0, "class", /*className*/ ctx[8]);
			}

			if (!current || dirty & /*connect, toggle, animation, duration, swiping*/ 124 && ul0_uk_switcher_value !== (ul0_uk_switcher_value = `connect: ${/*connect*/ ctx[2]}; toggle: ${/*toggle*/ ctx[3]}; animation: ${/*animation*/ ctx[4]}; duration: ${/*duration*/ ctx[5]}; swiping: ${/*swiping*/ ctx[6]}`)) {
				attr(ul0, "uk-switcher", ul0_uk_switcher_value);
			}

			if (!current || dirty & /*className*/ 256) {
				toggle_class(ul0, "uk-subnav", true);
			}

			if (!current || dirty & /*className*/ 256) {
				toggle_class(ul0, "uk-subnav-pill", true);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 16384)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[14],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[14])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[14], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(ul0);
				detach(t);
				detach(ul1);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*ul0_binding*/ ctx[23](null);
			if (default_slot) default_slot.d(detaching);
			/*ul1_binding*/ ctx[24](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$m($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { connect = "~.uk-switcher" } = $$props;
	let { toggle = "> * > :first-child" } = $$props;
	let { animation = false } = $$props;
	let { duration = 200 } = $$props;
	let { swiping = true } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { titles = [] } = $$props;
	let { htmlTitle = false } = $$props;
	let { ref = undefined } = $$props;
	let { index = 0 } = $$props;
	let switcherRef = undefined;
	let externalAssignment = true;

	function handleShow(e) {
		$$invalidate(11, externalAssignment = false);
		$$invalidate(1, index = [...switcherRef.children].indexOf(e.target));
	}

	function show_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function shown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hidden_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeshow_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	const keyup_handler = (i, e) => ['Enter'].includes(e.code) && ($$invalidate(11, externalAssignment = false), $$invalidate(1, index = i), UIkit.switcher(ref).show(index));

	function ul0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	function ul1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			switcherRef = $$value;
			$$invalidate(12, switcherRef);
		});
	}

	$$self.$$set = $$props => {
		if ('connect' in $$props) $$invalidate(2, connect = $$props.connect);
		if ('toggle' in $$props) $$invalidate(3, toggle = $$props.toggle);
		if ('animation' in $$props) $$invalidate(4, animation = $$props.animation);
		if ('duration' in $$props) $$invalidate(5, duration = $$props.duration);
		if ('swiping' in $$props) $$invalidate(6, swiping = $$props.swiping);
		if ('style' in $$props) $$invalidate(7, style = $$props.style);
		if ('className' in $$props) $$invalidate(8, className = $$props.className);
		if ('titles' in $$props) $$invalidate(9, titles = $$props.titles);
		if ('htmlTitle' in $$props) $$invalidate(10, htmlTitle = $$props.htmlTitle);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('index' in $$props) $$invalidate(1, index = $$props.index);
		if ('$$scope' in $$props) $$invalidate(14, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ref, externalAssignment, index*/ 2051) {
			if (ref) {
				if (externalAssignment) {
					UIkit.switcher(ref).show(index);
				}

				$$invalidate(11, externalAssignment = true);
			}
		}
	};

	return [
		ref,
		index,
		connect,
		toggle,
		animation,
		duration,
		swiping,
		style,
		className,
		titles,
		htmlTitle,
		externalAssignment,
		switcherRef,
		handleShow,
		$$scope,
		slots,
		show_handler,
		hide_handler,
		shown_handler,
		hidden_handler,
		beforeshow_handler,
		beforehide_handler,
		keyup_handler,
		ul0_binding,
		ul1_binding
	];
}

class Switcher extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
			connect: 2,
			toggle: 3,
			animation: 4,
			duration: 5,
			swiping: 6,
			style: 7,
			className: 8,
			titles: 9,
			htmlTitle: 10,
			ref: 0,
			index: 1
		});
	}
}

/* src/components/Tab.svelte generated by Svelte v4.2.19 */

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i];
	child_ctx[29] = i;
	return child_ctx;
}

// (59:8) {:else}
function create_else_block$2(ctx) {
	let t_value = /*title*/ ctx[27] + "";
	let t;

	return {
		c() {
			t = text(t_value);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*titles*/ 1024 && t_value !== (t_value = /*title*/ ctx[27] + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (57:8) {#if htmlTitle}
function create_if_block$8(ctx) {
	let html_tag;
	let raw_value = /*title*/ ctx[27] + "";
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(raw_value, target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*titles*/ 1024 && raw_value !== (raw_value = /*title*/ ctx[27] + "")) html_tag.p(raw_value);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

// (53:2) {#each titles as title, i (title)}
function create_each_block$4(key_1, ctx) {
	let li;
	let a;
	let t;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*htmlTitle*/ ctx[11]) return create_if_block$8;
		return create_else_block$2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	function keyup_handler(...args) {
		return /*keyup_handler*/ ctx[23](/*i*/ ctx[29], ...args);
	}

	return {
		key: key_1,
		first: null,
		c() {
			li = element("li");
			a = element("a");
			if_block.c();
			t = space();
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
			this.first = li;
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			if_block.m(a, null);
			append(li, t);

			if (!mounted) {
				dispose = listen(a, "keyup", keyup_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(a, null);
				}
			}
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			if_block.d();
			mounted = false;
			dispose();
		}
	};
}

function create_fragment$l(ctx) {
	let ul0;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let ul0_uk_tab_value;
	let t;
	let ul1;
	let current;
	let mounted;
	let dispose;
	let each_value = ensure_array_like(/*titles*/ ctx[10]);
	const get_key = ctx => /*title*/ ctx[27];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$4(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$4(key, child_ctx));
	}

	const default_slot_template = /*#slots*/ ctx[16].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

	return {
		c() {
			ul0 = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t = space();
			ul1 = element("ul");
			if (default_slot) default_slot.c();
			attr(ul0, "style", /*style*/ ctx[8]);
			attr(ul0, "class", /*className*/ ctx[9]);
			attr(ul0, "uk-tab", ul0_uk_tab_value = `connect: ${/*connect*/ ctx[2]}; toggle: ${/*toggle*/ ctx[3]}; animation: ${/*animation*/ ctx[4]}; duration: ${/*duration*/ ctx[5]}; swiping: ${/*swiping*/ ctx[6]}; media: ${/*media*/ ctx[7]}`);
			attr(ul1, "class", "uk-switcher");
		},
		m(target, anchor) {
			insert(target, ul0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul0, null);
				}
			}

			/*ul0_binding*/ ctx[24](ul0);
			insert(target, t, anchor);
			insert(target, ul1, anchor);

			if (default_slot) {
				default_slot.m(ul1, null);
			}

			/*ul1_binding*/ ctx[25](ul1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(ul1, "show", /*handleShow*/ ctx[14]),
					listen(ul1, "show", stop_propagation(/*show_handler*/ ctx[17])),
					listen(ul1, "hide", stop_propagation(/*hide_handler*/ ctx[18])),
					listen(ul1, "shown", stop_propagation(/*shown_handler*/ ctx[19])),
					listen(ul1, "hidden", stop_propagation(/*hidden_handler*/ ctx[20])),
					listen(ul1, "beforeshow", stop_propagation(/*beforeshow_handler*/ ctx[21])),
					listen(ul1, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[22]))
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (dirty & /*externalAssignment, index, titles, ref, htmlTitle*/ 7171) {
				each_value = ensure_array_like(/*titles*/ ctx[10]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul0, destroy_block, create_each_block$4, null, get_each_context$4);
			}

			if (!current || dirty & /*style*/ 256) {
				attr(ul0, "style", /*style*/ ctx[8]);
			}

			if (!current || dirty & /*className*/ 512) {
				attr(ul0, "class", /*className*/ ctx[9]);
			}

			if (!current || dirty & /*connect, toggle, animation, duration, swiping, media*/ 252 && ul0_uk_tab_value !== (ul0_uk_tab_value = `connect: ${/*connect*/ ctx[2]}; toggle: ${/*toggle*/ ctx[3]}; animation: ${/*animation*/ ctx[4]}; duration: ${/*duration*/ ctx[5]}; swiping: ${/*swiping*/ ctx[6]}; media: ${/*media*/ ctx[7]}`)) {
				attr(ul0, "uk-tab", ul0_uk_tab_value);
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 32768)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[15],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[15])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(ul0);
				detach(t);
				detach(ul1);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*ul0_binding*/ ctx[24](null);
			if (default_slot) default_slot.d(detaching);
			/*ul1_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$l($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { connect = "~.uk-switcher" } = $$props;
	let { toggle = "> *" } = $$props;
	let { animation = false } = $$props;
	let { duration = 200 } = $$props;
	let { swiping = true } = $$props;
	let { media = 200 } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { titles = [] } = $$props;
	let { htmlTitle = false } = $$props;
	let { ref = undefined } = $$props;
	let { index = 0 } = $$props;
	let switcherRef = undefined;
	let externalAssignment = true;
	createEventDispatcher();

	function handleShow(e) {
		$$invalidate(12, externalAssignment = false);
		$$invalidate(1, index = [...switcherRef.children].indexOf(e.target));
	}

	function show_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function shown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hidden_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeshow_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	const keyup_handler = (i, e) => ['Enter'].includes(e.code) && ($$invalidate(12, externalAssignment = false), $$invalidate(1, index = i), UIkit.switcher(ref).show(index));

	function ul0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	function ul1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			switcherRef = $$value;
			$$invalidate(13, switcherRef);
		});
	}

	$$self.$$set = $$props => {
		if ('connect' in $$props) $$invalidate(2, connect = $$props.connect);
		if ('toggle' in $$props) $$invalidate(3, toggle = $$props.toggle);
		if ('animation' in $$props) $$invalidate(4, animation = $$props.animation);
		if ('duration' in $$props) $$invalidate(5, duration = $$props.duration);
		if ('swiping' in $$props) $$invalidate(6, swiping = $$props.swiping);
		if ('media' in $$props) $$invalidate(7, media = $$props.media);
		if ('style' in $$props) $$invalidate(8, style = $$props.style);
		if ('className' in $$props) $$invalidate(9, className = $$props.className);
		if ('titles' in $$props) $$invalidate(10, titles = $$props.titles);
		if ('htmlTitle' in $$props) $$invalidate(11, htmlTitle = $$props.htmlTitle);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('index' in $$props) $$invalidate(1, index = $$props.index);
		if ('$$scope' in $$props) $$invalidate(15, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ref, externalAssignment, index*/ 4099) {
			if (ref) {
				if (externalAssignment) {
					UIkit.tab(ref).show(index);
				}

				$$invalidate(12, externalAssignment = true);
			}
		}
	};

	return [
		ref,
		index,
		connect,
		toggle,
		animation,
		duration,
		swiping,
		media,
		style,
		className,
		titles,
		htmlTitle,
		externalAssignment,
		switcherRef,
		handleShow,
		$$scope,
		slots,
		show_handler,
		hide_handler,
		shown_handler,
		hidden_handler,
		beforeshow_handler,
		beforehide_handler,
		keyup_handler,
		ul0_binding,
		ul1_binding
	];
}

class Tab extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
			connect: 2,
			toggle: 3,
			animation: 4,
			duration: 5,
			swiping: 6,
			media: 7,
			style: 8,
			className: 9,
			titles: 10,
			htmlTitle: 11,
			ref: 0,
			index: 1
		});
	}
}

/* src/components/Table.svelte generated by Svelte v4.2.19 */

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i];
	return child_ctx;
}

// (39:2) {#if caption}
function create_if_block_1$3(ctx) {
	let caption_1;
	let t;

	return {
		c() {
			caption_1 = element("caption");
			t = text(/*caption*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, caption_1, anchor);
			append(caption_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*caption*/ 128) set_data(t, /*caption*/ ctx[7]);
		},
		d(detaching) {
			if (detaching) {
				detach(caption_1);
			}
		}
	};
}

// (42:2) {#if heading && heading.length > 0}
function create_if_block$7(ctx) {
	let thead;
	let tr;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value = ensure_array_like(/*heading*/ ctx[1]);
	const get_key = ctx => /*col*/ ctx[11];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$3(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$3(key, child_ctx));
	}

	return {
		c() {
			thead = element("thead");
			tr = element("tr");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}
		},
		m(target, anchor) {
			insert(target, thead, anchor);
			append(thead, tr);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(tr, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty & /*heading, undefined, stickyHeader*/ 66) {
				each_value = ensure_array_like(/*heading*/ ctx[1]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, tr, destroy_block, create_each_block$3, null, get_each_context$3);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(thead);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

// (45:8) {#each heading as col (col)}
function create_each_block$3(key_1, ctx) {
	let th;

	let t_value = (typeof /*col*/ ctx[11] === 'object'
	? /*col*/ ctx[11].label
	: /*col*/ ctx[11]) + "";

	let t;
	let th_class_value;

	return {
		key: key_1,
		first: null,
		c() {
			th = element("th");
			t = text(t_value);

			attr(th, "class", th_class_value = "" + (null_to_empty(typeof /*col*/ ctx[11] === 'object'
			? /*col*/ ctx[11].className
			: undefined) + " svelte-lvds73"));

			set_style(th, "text-align", typeof /*col*/ ctx[11] === 'object'
			? /*col*/ ctx[11].textAlign || 'left'
			: 'left');

			toggle_class(th, "sticky", /*stickyHeader*/ ctx[6]);
			this.first = th;
		},
		m(target, anchor) {
			insert(target, th, anchor);
			append(th, t);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty & /*heading*/ 2 && t_value !== (t_value = (typeof /*col*/ ctx[11] === 'object'
			? /*col*/ ctx[11].label
			: /*col*/ ctx[11]) + "")) set_data(t, t_value);

			if (dirty & /*heading*/ 2 && th_class_value !== (th_class_value = "" + (null_to_empty(typeof /*col*/ ctx[11] === 'object'
			? /*col*/ ctx[11].className
			: undefined) + " svelte-lvds73"))) {
				attr(th, "class", th_class_value);
			}

			if (dirty & /*heading*/ 2) {
				set_style(th, "text-align", typeof /*col*/ ctx[11] === 'object'
				? /*col*/ ctx[11].textAlign || 'left'
				: 'left');
			}

			if (dirty & /*heading, stickyHeader*/ 66) {
				toggle_class(th, "sticky", /*stickyHeader*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(th);
			}
		}
	};
}

function create_fragment$k(ctx) {
	let table;
	let t0;
	let t1;
	let tbody;
	let current;
	let if_block0 = /*caption*/ ctx[7] && create_if_block_1$3(ctx);
	let if_block1 = /*heading*/ ctx[1] && /*heading*/ ctx[1].length > 0 && create_if_block$7(ctx);
	const default_slot_template = /*#slots*/ ctx[9].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

	return {
		c() {
			table = element("table");
			if (if_block0) if_block0.c();
			t0 = space();
			if (if_block1) if_block1.c();
			t1 = space();
			tbody = element("tbody");
			if (default_slot) default_slot.c();
			attr(table, "class", /*className*/ ctx[3]);
			attr(table, "style", /*style*/ ctx[4]);
			toggle_class(table, "uk-table", true);
			toggle_class(table, "uk-table-middle", true);
			toggle_class(table, "uk-table-striped", /*appearance*/ ctx[5] === 'striped');
			toggle_class(table, "uk-table-divider", /*appearance*/ ctx[5] === 'divider');
			toggle_class(table, "uk-table-small", /*size*/ ctx[2] === 'small');
		},
		m(target, anchor) {
			insert(target, table, anchor);
			if (if_block0) if_block0.m(table, null);
			append(table, t0);
			if (if_block1) if_block1.m(table, null);
			append(table, t1);
			append(table, tbody);

			if (default_slot) {
				default_slot.m(tbody, null);
			}

			/*table_binding*/ ctx[10](table);
			current = true;
		},
		p(ctx, [dirty]) {
			if (/*caption*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$3(ctx);
					if_block0.c();
					if_block0.m(table, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*heading*/ ctx[1] && /*heading*/ ctx[1].length > 0) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$7(ctx);
					if_block1.c();
					if_block1.m(table, t1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 256)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[8],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*className*/ 8) {
				attr(table, "class", /*className*/ ctx[3]);
			}

			if (!current || dirty & /*style*/ 16) {
				attr(table, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*className*/ 8) {
				toggle_class(table, "uk-table", true);
			}

			if (!current || dirty & /*className*/ 8) {
				toggle_class(table, "uk-table-middle", true);
			}

			if (!current || dirty & /*className, appearance*/ 40) {
				toggle_class(table, "uk-table-striped", /*appearance*/ ctx[5] === 'striped');
			}

			if (!current || dirty & /*className, appearance*/ 40) {
				toggle_class(table, "uk-table-divider", /*appearance*/ ctx[5] === 'divider');
			}

			if (!current || dirty & /*className, size*/ 12) {
				toggle_class(table, "uk-table-small", /*size*/ ctx[2] === 'small');
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(table);
			}

			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			if (default_slot) default_slot.d(detaching);
			/*table_binding*/ ctx[10](null);
		}
	};
}

function instance$k($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { heading = [] } = $$props;
	let { size = undefined } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { appearance = undefined } = $$props;
	let { stickyHeader = false } = $$props;
	let { ref = undefined } = $$props;
	let { caption = undefined } = $$props;

	function table_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('heading' in $$props) $$invalidate(1, heading = $$props.heading);
		if ('size' in $$props) $$invalidate(2, size = $$props.size);
		if ('className' in $$props) $$invalidate(3, className = $$props.className);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('appearance' in $$props) $$invalidate(5, appearance = $$props.appearance);
		if ('stickyHeader' in $$props) $$invalidate(6, stickyHeader = $$props.stickyHeader);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('caption' in $$props) $$invalidate(7, caption = $$props.caption);
		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
	};

	return [
		ref,
		heading,
		size,
		className,
		style,
		appearance,
		stickyHeader,
		caption,
		$$scope,
		slots,
		table_binding
	];
}

class Table extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
			heading: 1,
			size: 2,
			className: 3,
			style: 4,
			appearance: 5,
			stickyHeader: 6,
			ref: 0,
			caption: 7
		});
	}
}

/* src/components/accordion/Accordion.svelte generated by Svelte v4.2.19 */

function create_fragment$j(ctx) {
	let ul;
	let ul_uk_accordion_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[13].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], null);

	return {
		c() {
			ul = element("ul");
			if (default_slot) default_slot.c();
			attr(ul, "class", /*className*/ ctx[6]);
			attr(ul, "style", /*style*/ ctx[7]);
			attr(ul, "uk-accordion", ul_uk_accordion_value = "multiple: " + /*multi*/ ctx[4] + "; collapsible: " + /*collapsible*/ ctx[2] + "; duration: " + /*duration*/ ctx[3] + "; transition: " + /*transition*/ ctx[5] + "; animation: " + /*animation*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, ul, anchor);

			if (default_slot) {
				default_slot.m(ul, null);
			}

			/*ul_binding*/ ctx[21](ul);
			current = true;

			if (!mounted) {
				dispose = [
					listen(ul, "show", /*handleToggle*/ ctx[8]),
					listen(ul, "hide", /*handleToggle*/ ctx[8]),
					listen(ul, "hide", stop_propagation(/*hide_handler*/ ctx[14])),
					listen(ul, "show", stop_propagation(/*show_handler*/ ctx[15])),
					listen(ul, "hidden", stop_propagation(/*hidden_handler*/ ctx[16])),
					listen(ul, "shown", stop_propagation(/*shown_handler*/ ctx[17])),
					listen(ul, "beforehide", stop_propagation(/*beforehide_handler*/ ctx[18])),
					listen(ul, "beforeshow", stop_propagation(/*beforeshow_handler*/ ctx[19])),
					listen(ul, "keyup", /*keyup_handler*/ ctx[20])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[12], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*className*/ 64) {
				attr(ul, "class", /*className*/ ctx[6]);
			}

			if (!current || dirty & /*style*/ 128) {
				attr(ul, "style", /*style*/ ctx[7]);
			}

			if (!current || dirty & /*multi, collapsible, duration, transition, animation*/ 62 && ul_uk_accordion_value !== (ul_uk_accordion_value = "multiple: " + /*multi*/ ctx[4] + "; collapsible: " + /*collapsible*/ ctx[2] + "; duration: " + /*duration*/ ctx[3] + "; transition: " + /*transition*/ ctx[5] + "; animation: " + /*animation*/ ctx[1])) {
				attr(ul, "uk-accordion", ul_uk_accordion_value);
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(ul);
			}

			if (default_slot) default_slot.d(detaching);
			/*ul_binding*/ ctx[21](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$j($$self, $$props, $$invalidate) {
	let refPresent;
	let { $$slots: slots = {}, $$scope } = $$props;
	let { animation = true } = $$props;
	let { collapsible = true } = $$props;
	let { duration = 200 } = $$props;
	let { multi = false } = $$props;
	let { index = multi ? [] : false } = $$props;
	let { transition = "ease" } = $$props;
	let { ref = undefined } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let externalAssignment = true;

	function react() {
		if (externalAssignment) {
			const sortedOpenIndices = index === false
			? []
			: (Array.isArray(index) ? [...index] : [index]).sort();

			for (let i = 0, sortedI = 0; i < ref.children.length; i++) {
				if (sortedI < sortedOpenIndices.length && i === sortedOpenIndices[sortedI]) {
					if (!ref.children[i].classList.contains("uk-open")) {
						UIkit.accordion(ref).toggle(i);
					}

					sortedI++;
				} else {
					if (ref.children[i].classList.contains("uk-open")) {
						UIkit.accordion(ref).toggle(i);
					}
				}
			}
		}

		externalAssignment = true;
	}

	function toggleMulti() {
		if (multi && !Array.isArray(index)) {
			$$invalidate(10, index = index === false ? [] : [index]);
		} else if (!multi && Array.isArray(index)) {
			$$invalidate(10, index = index[0] === undefined ? false : index[0]);
		}
	}

	function handleToggle() {
		let newIndices = [...ref.children].map((c, i) => ({
			isOpen: c.classList.contains("uk-open"),
			index: i
		})).filter(({ isOpen }) => isOpen).map(({ index }) => index);

		if (multi) {
			if (typeof index !== typeof newIndices || [...newIndices].sort().join(",") !== [...index].sort().join(",")) {
				externalAssignment = false;
				$$invalidate(10, index = newIndices);
			}
		} else {
			let newIndex = newIndices[0];

			if (newIndex === undefined) {
				newIndex = false;
			}

			if (newIndex !== index) {
				externalAssignment = false;
				$$invalidate(10, index = newIndex);
			}
		}
	}

	function handleKeyToggle(e) {
		/** @type {HTMLElement} */
		const target = e.target;

		if (target.classList.contains("uk-accordion-title")) {
			const targetIndex = [...ref.children].indexOf(e.target.parentElement);

			if (targetIndex !== -1) {
				UIkit.accordion(ref).toggle(targetIndex);
			}
		}
	}

	function hide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function show_handler(event) {
		bubble.call(this, $$self, event);
	}

	function hidden_handler(event) {
		bubble.call(this, $$self, event);
	}

	function shown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforehide_handler(event) {
		bubble.call(this, $$self, event);
	}

	function beforeshow_handler(event) {
		bubble.call(this, $$self, event);
	}

	const keyup_handler = e => ["Enter"].includes(e.code) && handleKeyToggle(e);

	function ul_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('animation' in $$props) $$invalidate(1, animation = $$props.animation);
		if ('collapsible' in $$props) $$invalidate(2, collapsible = $$props.collapsible);
		if ('duration' in $$props) $$invalidate(3, duration = $$props.duration);
		if ('multi' in $$props) $$invalidate(4, multi = $$props.multi);
		if ('index' in $$props) $$invalidate(10, index = $$props.index);
		if ('transition' in $$props) $$invalidate(5, transition = $$props.transition);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('style' in $$props) $$invalidate(7, style = $$props.style);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*ref*/ 1) {
			$$invalidate(11, refPresent = Boolean(ref));
		}

		if ($$self.$$.dirty & /*index, refPresent*/ 3072) {
			(refPresent && react());
		}

		if ($$self.$$.dirty & /*multi*/ 16) {
			(toggleMulti());
		}
	};

	return [
		ref,
		animation,
		collapsible,
		duration,
		multi,
		transition,
		className,
		style,
		handleToggle,
		handleKeyToggle,
		index,
		refPresent,
		$$scope,
		slots,
		hide_handler,
		show_handler,
		hidden_handler,
		shown_handler,
		beforehide_handler,
		beforeshow_handler,
		keyup_handler,
		ul_binding
	];
}

class Accordion extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
			animation: 1,
			collapsible: 2,
			duration: 3,
			multi: 4,
			index: 10,
			transition: 5,
			ref: 0,
			className: 6,
			style: 7
		});
	}
}

/* src/components/accordion/AccordionItem.svelte generated by Svelte v4.2.19 */

function create_else_block$1(ctx) {
	let t;

	return {
		c() {
			t = text(/*title*/ ctx[1]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) set_data(t, /*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (10:4) {#if isTitleHtml}
function create_if_block$6(ctx) {
	let html_tag;
	let html_anchor;

	return {
		c() {
			html_tag = new HtmlTag(false);
			html_anchor = empty();
			html_tag.a = html_anchor;
		},
		m(target, anchor) {
			html_tag.m(/*title*/ ctx[1], target, anchor);
			insert(target, html_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*title*/ 2) html_tag.p(/*title*/ ctx[1]);
		},
		d(detaching) {
			if (detaching) {
				detach(html_anchor);
				html_tag.d();
			}
		}
	};
}

function create_fragment$i(ctx) {
	let li;
	let a;
	let t;
	let div;
	let current;

	function select_block_type(ctx, dirty) {
		if (/*isTitleHtml*/ ctx[2]) return create_if_block$6;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);
	const default_slot_template = /*#slots*/ ctx[4].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

	return {
		c() {
			li = element("li");
			a = element("a");
			if_block.c();
			t = space();
			div = element("div");
			if (default_slot) default_slot.c();
			attr(a, "class", "uk-accordion-title");
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
			attr(div, "class", "uk-accordion-content");
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, a);
			if_block.m(a, null);
			append(li, t);
			append(li, div);

			if (default_slot) {
				default_slot.m(div, null);
			}

			/*li_binding*/ ctx[5](li);
			current = true;
		},
		p(ctx, [dirty]) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(a, null);
				}
			}

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 8)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[3],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[3])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[3], dirty, null),
						null
					);
				}
			}
		},
		i(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(li);
			}

			if_block.d();
			if (default_slot) default_slot.d(detaching);
			/*li_binding*/ ctx[5](null);
		}
	};
}

function instance$i($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	let { title = "" } = $$props;
	let { isTitleHtml = false } = $$props;
	let { ref = undefined } = $$props;

	function li_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(0, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('title' in $$props) $$invalidate(1, title = $$props.title);
		if ('isTitleHtml' in $$props) $$invalidate(2, isTitleHtml = $$props.isTitleHtml);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('$$scope' in $$props) $$invalidate(3, $$scope = $$props.$$scope);
	};

	return [ref, title, isTitleHtml, $$scope, slots, li_binding];
}

class AccordionItem extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance$i, create_fragment$i, safe_not_equal, { title: 1, isTitleHtml: 2, ref: 0 });
	}
}

/* src/components/form/AsyncAutocomplete.svelte generated by Svelte v4.2.19 */

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[75] = list[i];
	child_ctx[77] = i;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[75] = list[i];
	return child_ctx;
}

// (421:1) {#if label}
function create_if_block_7(ctx) {
	let label_1;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			label_1 = element("label");
			t0 = text(/*label*/ ctx[8]);
			t1 = space();
			t2 = text(/*suffix*/ ctx[23]);
			attr(label_1, "for", /*id*/ ctx[6]);
			attr(label_1, "class", "uk-form-label svelte-f6mr8l");
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			append(label_1, t0);
			append(label_1, t1);
			append(label_1, t2);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 256) set_data(t0, /*label*/ ctx[8]);
			if (dirty[0] & /*suffix*/ 8388608) set_data(t2, /*suffix*/ ctx[23]);

			if (dirty[0] & /*id*/ 64) {
				attr(label_1, "for", /*id*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(label_1);
			}
		}
	};
}

// (451:108) 
function create_if_block_6(ctx) {
	let a;
	let mounted;
	let dispose;

	return {
		c() {
			a = element("a");
			a.textContent = "";
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
			attr(a, "class", "uk-form-icon uk-form-icon-flip");
			attr(a, "uk-icon", "icon: close");
		},
		m(target, anchor) {
			insert(target, a, anchor);

			if (!mounted) {
				dispose = [
					listen(a, "keydown", /*keydown_handler*/ ctx[56]),
					listen(a, "click", /*click_handler*/ ctx[57])
				];

				mounted = true;
			}
		},
		p: noop$1,
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(a);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (449:2) {#if loading && showSuggested}
function create_if_block_5(ctx) {
	let loader;
	let current;

	loader = new Loader({
			props: {
				className: "uk-form-icon uk-form-icon-flip",
				ratio: 0.4
			}
		});

	return {
		c() {
			create_component(loader.$$.fragment);
		},
		m(target, anchor) {
			mount_component(loader, target, anchor);
			current = true;
		},
		p: noop$1,
		i(local) {
			if (current) return;
			transition_in(loader.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(loader.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(loader, detaching);
		}
	};
}

// (477:1) {#if multi && selectedOptions.length > 0}
function create_if_block_4(ctx) {
	let div;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_value_1 = ensure_array_like(/*selectedOptions*/ ctx[4]);
	const get_key = ctx => /*option*/ ctx[75];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "uk-margin-small-top");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selectedOptions*/ 16 | dirty[1] & /*toggleOption*/ 8) {
				each_value_1 = ensure_array_like(/*selectedOptions*/ ctx[4]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1$1, null, get_each_context_1$1);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

// (479:3) {#each selectedOptions as option (option)}
function create_each_block_1$1(key_1, ctx) {
	let span;
	let t0_value = /*option*/ ctx[75].label + "";
	let t0;
	let t1;
	let a;
	let t3;
	let mounted;
	let dispose;

	function keydown_handler_1(...args) {
		return /*keydown_handler_1*/ ctx[58](/*option*/ ctx[75], ...args);
	}

	function click_handler_1() {
		return /*click_handler_1*/ ctx[59](/*option*/ ctx[75]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			span = element("span");
			t0 = text(t0_value);
			t1 = text("\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t");
			a = element("a");
			a.textContent = "";
			t3 = space();
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
			attr(a, "uk-icon", "icon: close");
			attr(span, "class", "uk-badge uk-margin-small-right uk-margin-small-bottom");
			this.first = span;
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t0);
			append(span, t1);
			append(span, a);
			append(span, t3);

			if (!mounted) {
				dispose = [
					listen(a, "keydown", keydown_handler_1),
					listen(a, "click", click_handler_1)
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty[0] & /*selectedOptions*/ 16 && t0_value !== (t0_value = /*option*/ ctx[75].label + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}

			mounted = false;
			run_all(dispose);
		}
	};
}

// (502:1) {#if showSuggested && !disabled}
function create_if_block$5(ctx) {
	let div;
	let div_intro;

	function select_block_type_1(ctx, dirty) {
		if (/*filteredOptions*/ ctx[29].length > 0) return create_if_block_1$2;
		if (/*textIfNoResult*/ ctx[11]) return create_if_block_3$2;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			div = element("div");
			if (if_block) if_block.c();
			attr(div, "class", "uk-grid-small uk-box-shadow-small suggested uk-background-default uk-margin-remove-top uk-margin-remove-left uk-grid svelte-f6mr8l");
			toggle_class(div, "custom-uk-autocomplete-suggested", true);
		},
		m(target, anchor) {
			insert(target, div, anchor);
			if (if_block) if_block.m(div, null);
			/*div_binding_1*/ ctx[61](div);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div, null);
				}
			}
		},
		i(local) {
			if (local) {
				if (!div_intro) {
					add_render_callback(() => {
						div_intro = create_in_transition(div, fly, {
							y: 50,
							duration: /*animationDuration*/ ctx[19]
						});

						div_intro.start();
					});
				}
			}
		},
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			if (if_block) {
				if_block.d();
			}

			/*div_binding_1*/ ctx[61](null);
		}
	};
}

// (535:28) 
function create_if_block_3$2(ctx) {
	let div;
	let t;

	return {
		c() {
			div = element("div");
			t = text(/*textIfNoResult*/ ctx[11]);
			attr(div, "class", "uk-text-center uk-text-italic uk-width-1-1");
			set_style(div, "padding-top", ".5em");
			set_style(div, "padding-bottom", ".5em");
			set_style(div, "cursor", "default");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*textIfNoResult*/ 2048) set_data(t, /*textIfNoResult*/ ctx[11]);
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}
		}
	};
}

// (510:3) {#if filteredOptions.length > 0}
function create_if_block_1$2(ctx) {
	let div;
	let t;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let each_1_anchor;
	let each_value = ensure_array_like(/*filteredOptions*/ ctx[29]);
	const get_key = ctx => /*option*/ ctx[75];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$2(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block$2(key, child_ctx));
	}

	return {
		c() {
			div = element("div");
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			set_style(div, "display", "none");
		},
		m(target, anchor) {
			insert(target, div, anchor);
			/*div_binding*/ ctx[60](div);
			insert(target, t, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*filteredOptions, outlineOptionIndex, multi, value, id*/ 537919681 | dirty[1] & /*handleChangeGenerator*/ 16) {
				each_value = ensure_array_like(/*filteredOptions*/ ctx[29]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$2, each_1_anchor, get_each_context$2);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div);
				detach(t);
				detach(each_1_anchor);
			}

			/*div_binding*/ ctx[60](null);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d(detaching);
			}
		}
	};
}

// (529:6) {#if !multi && option.value === value}
function create_if_block_2$2(ctx) {
	let span;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-icon");
			attr(span, "uk-icon", "icon: check; ratio: .75");
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (512:4) {#each filteredOptions as option, i (option)}
function create_each_block$2(key_1, ctx) {
	let label_1;
	let input;
	let input_name_value;
	let input_checked_value;
	let t0;
	let t1;
	let t2_value = /*option*/ ctx[75].label + "";
	let t2;
	let t3;
	let label_1_intro;
	let mounted;
	let dispose;
	let if_block = !/*multi*/ ctx[7] && /*option*/ ctx[75].value === /*value*/ ctx[0] && create_if_block_2$2();

	return {
		key: key_1,
		first: null,
		c() {
			label_1 = element("label");
			input = element("input");
			t0 = space();
			if (if_block) if_block.c();
			t1 = space();
			t2 = text(t2_value);
			t3 = space();
			attr(input, "class", "uk-radio interactive-hidden svelte-f6mr8l");
			attr(input, "type", "radio");
			attr(input, "name", input_name_value = /*id*/ ctx[6] + "-radio");
			input.checked = input_checked_value = /*option*/ ctx[75].value === /*value*/ ctx[0];
			attr(label_1, "class", "uk-width-1-1 svelte-f6mr8l");
			toggle_class(label_1, "uk-background-muted", /*i*/ ctx[77] === /*outlineOptionIndex*/ ctx[20]);
			toggle_class(label_1, "outline", /*i*/ ctx[77] === /*outlineOptionIndex*/ ctx[20]);
			toggle_class(label_1, "uk-background-default", /*i*/ ctx[77] !== /*outlineOptionIndex*/ ctx[20]);
			toggle_class(label_1, "no-outline", /*i*/ ctx[77] !== /*outlineOptionIndex*/ ctx[20]);
			this.first = label_1;
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			append(label_1, input);
			append(label_1, t0);
			if (if_block) if_block.m(label_1, null);
			append(label_1, t1);
			append(label_1, t2);
			append(label_1, t3);

			if (!mounted) {
				dispose = [
					listen(input, "change", stop_propagation(function () {
						if (is_function(/*handleChangeGenerator*/ ctx[35](/*option*/ ctx[75]))) /*handleChangeGenerator*/ ctx[35](/*option*/ ctx[75]).apply(this, arguments);
					})),
					listen(input, "click", stop_propagation(function () {
						if (is_function(/*handleChangeGenerator*/ ctx[35](/*option*/ ctx[75]))) /*handleChangeGenerator*/ ctx[35](/*option*/ ctx[75]).apply(this, arguments);
					}))
				];

				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*id*/ 64 && input_name_value !== (input_name_value = /*id*/ ctx[6] + "-radio")) {
				attr(input, "name", input_name_value);
			}

			if (dirty[0] & /*filteredOptions, value*/ 536870913 && input_checked_value !== (input_checked_value = /*option*/ ctx[75].value === /*value*/ ctx[0])) {
				input.checked = input_checked_value;
			}

			if (!/*multi*/ ctx[7] && /*option*/ ctx[75].value === /*value*/ ctx[0]) {
				if (if_block) ; else {
					if_block = create_if_block_2$2();
					if_block.c();
					if_block.m(label_1, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*filteredOptions*/ 536870912 && t2_value !== (t2_value = /*option*/ ctx[75].label + "")) set_data(t2, t2_value);

			if (dirty[0] & /*filteredOptions, outlineOptionIndex*/ 537919488) {
				toggle_class(label_1, "uk-background-muted", /*i*/ ctx[77] === /*outlineOptionIndex*/ ctx[20]);
			}

			if (dirty[0] & /*filteredOptions, outlineOptionIndex*/ 537919488) {
				toggle_class(label_1, "outline", /*i*/ ctx[77] === /*outlineOptionIndex*/ ctx[20]);
			}

			if (dirty[0] & /*filteredOptions, outlineOptionIndex*/ 537919488) {
				toggle_class(label_1, "uk-background-default", /*i*/ ctx[77] !== /*outlineOptionIndex*/ ctx[20]);
			}

			if (dirty[0] & /*filteredOptions, outlineOptionIndex*/ 537919488) {
				toggle_class(label_1, "no-outline", /*i*/ ctx[77] !== /*outlineOptionIndex*/ ctx[20]);
			}
		},
		i(local) {
			if (local) {
				if (!label_1_intro) {
					add_render_callback(() => {
						label_1_intro = create_in_transition(label_1, fly, {
							y: -10,
							duration: /*animationDuration*/ ctx[19]
						});

						label_1_intro.start();
					});
				}
			}
		},
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(label_1);
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$h(ctx) {
	let t0;
	let div1;
	let t1;
	let div0;
	let input;
	let t2;
	let current_block_type_index;
	let if_block1;
	let t3;
	let t4;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*label*/ ctx[8] && create_if_block_7(ctx);
	const if_block_creators = [create_if_block_5, create_if_block_6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*loading*/ ctx[5] && /*showSuggested*/ ctx[25]) return 0;
		if ((/*multi*/ ctx[7] && /*value*/ ctx[0].length > 0 || !/*multi*/ ctx[7] && /*value*/ ctx[0] !== null && /*value*/ ctx[0] !== undefined) && !/*disabled*/ ctx[12]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block2 = /*multi*/ ctx[7] && /*selectedOptions*/ ctx[4].length > 0 && create_if_block_4(ctx);
	let if_block3 = /*showSuggested*/ ctx[25] && !/*disabled*/ ctx[12] && create_if_block$5(ctx);

	return {
		c() {
			t0 = space();
			div1 = element("div");
			if (if_block0) if_block0.c();
			t1 = space();
			div0 = element("div");
			input = element("input");
			t2 = space();
			if (if_block1) if_block1.c();
			t3 = space();
			if (if_block2) if_block2.c();
			t4 = space();
			if (if_block3) if_block3.c();
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "placeholder", /*placeholder*/ ctx[14]);
			attr(input, "class", "uk-input");
			attr(input, "type", "search");
			attr(input, "uk-tooltip", /*tooltip*/ ctx[13]);
			attr(input, "id", /*id*/ ctx[6]);
			input.value = /*query*/ ctx[1];
			input.required = false;
			input.disabled = /*disabled*/ ctx[12];
			toggle_class(input, "custom-uk-autocomplete-input", true);
			toggle_class(input, "uk-form-danger", /*state*/ ctx[3] === "invalid");
			toggle_class(input, "uk-form-success", /*state*/ ctx[3] === "valid");
			set_style(div0, "position", "relative");
			attr(div1, "style", /*style*/ ctx[10]);
			attr(div1, "class", div1_class_value = "" + (null_to_empty(/*className*/ ctx[9]) + " svelte-f6mr8l"));
			toggle_class(div1, "custom-uk-autocomplete-wrapper", true);
			toggle_class(div1, "text-wrapper", true);
			toggle_class(div1, "uk-margin-bottom", true);
		},
		m(target, anchor) {
			insert(target, t0, anchor);
			insert(target, div1, anchor);
			if (if_block0) if_block0.m(div1, null);
			append(div1, t1);
			append(div1, div0);
			append(div0, input);
			/*input_binding*/ ctx[54](input);
			append(div0, t2);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(div0, null);
			}

			append(div1, t3);
			if (if_block2) if_block2.m(div1, null);
			append(div1, t4);
			if (if_block3) if_block3.m(div1, null);
			/*div1_binding*/ ctx[62](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(document.body, "click", /*hideSuggested*/ ctx[32]),
					listen(document.body, "touchstart", /*touchstart_handler*/ ctx[52]),
					listen(document.body, "mousedown", /*mousedown_handler*/ ctx[53]),
					listen(input, "input", /*handleInput*/ ctx[36]),
					listen(input, "keydown", /*handleKeydown*/ ctx[37]),
					listen(input, "focus", /*showSuggestedOptions*/ ctx[31]),
					listen(input, "click", /*showSuggestedOptions*/ ctx[31]),
					listen(input, "blur", /*handleBlur*/ ctx[33]),
					listen(input, "focus", /*focus_handler*/ ctx[55]),
					listen(div1, "click", /*click_handler_2*/ ctx[63])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*label*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_7(ctx);
					if_block0.c();
					if_block0.m(div1, t1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!current || dirty[0] & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (!current || dirty[0] & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (!current || dirty[0] & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (!current || dirty[0] & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (!current || dirty[0] & /*placeholder*/ 16384) {
				attr(input, "placeholder", /*placeholder*/ ctx[14]);
			}

			if (!current || dirty[0] & /*tooltip*/ 8192) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[13]);
			}

			if (!current || dirty[0] & /*id*/ 64) {
				attr(input, "id", /*id*/ ctx[6]);
			}

			if (!current || dirty[0] & /*query*/ 2 && input.value !== /*query*/ ctx[1]) {
				input.value = /*query*/ ctx[1];
			}

			if (!current || dirty[0] & /*disabled*/ 4096) {
				input.disabled = /*disabled*/ ctx[12];
			}

			if (!current || dirty[0] & /*state*/ 8) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[3] === "invalid");
			}

			if (!current || dirty[0] & /*state*/ 8) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[3] === "valid");
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block1) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block1 = if_blocks[current_block_type_index];

					if (!if_block1) {
						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block1.c();
					} else {
						if_block1.p(ctx, dirty);
					}

					transition_in(if_block1, 1);
					if_block1.m(div0, null);
				} else {
					if_block1 = null;
				}
			}

			if (/*multi*/ ctx[7] && /*selectedOptions*/ ctx[4].length > 0) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_4(ctx);
					if_block2.c();
					if_block2.m(div1, t4);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (/*showSuggested*/ ctx[25] && !/*disabled*/ ctx[12]) {
				if (if_block3) {
					if_block3.p(ctx, dirty);

					if (dirty[0] & /*showSuggested, disabled*/ 33558528) {
						transition_in(if_block3, 1);
					}
				} else {
					if_block3 = create_if_block$5(ctx);
					if_block3.c();
					transition_in(if_block3, 1);
					if_block3.m(div1, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (!current || dirty[0] & /*style*/ 1024) {
				attr(div1, "style", /*style*/ ctx[10]);
			}

			if (!current || dirty[0] & /*className*/ 512 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*className*/ ctx[9]) + " svelte-f6mr8l"))) {
				attr(div1, "class", div1_class_value);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				toggle_class(div1, "custom-uk-autocomplete-wrapper", true);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				toggle_class(div1, "text-wrapper", true);
			}

			if (!current || dirty[0] & /*className*/ 512) {
				toggle_class(div1, "uk-margin-bottom", true);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block1);
			transition_in(if_block3);
			current = true;
		},
		o(local) {
			transition_out(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(div1);
			}

			if (if_block0) if_block0.d();
			/*input_binding*/ ctx[54](null);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			/*div1_binding*/ ctx[62](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance$h($$self, $$props, $$invalidate) {
	let optionsRendered;
	let $globalOptionalMarker;
	let $globalRequiredMarker;
	component_subscribe($$self, globalOptionalMarker, $$value => $$invalidate(50, $globalOptionalMarker = $$value));
	component_subscribe($$self, globalRequiredMarker, $$value => $$invalidate(51, $globalRequiredMarker = $$value));
	let { id = generateId() } = $$props;
	let { multi = false } = $$props;
	let { value = !multi ? null : [] } = $$props;
	let { label = "" } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { textIfNoResult = "" } = $$props;
	let { textIfInvalid = "" } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { optional = false } = $$props;
	let { ref = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = "off" } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { animationDuration = 100 } = $$props;
	let { state = "initial" } = $$props;
	let { query = "" } = $$props;
	let { selectedOptions = [] } = $$props;
	let { dataProvider } = $$props;
	let { dataProviderErrorHandler = err => console.error(err) } = $$props;
	let { loading = false } = $$props;
	let { debounceMs = 200 } = $$props;
	let { maxSuggestions = 5 } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let suffix = "";

	function updateLabelSuffix() {
		if (optional) {
			$$invalidate(23, suffix = typeof optionalMarker === "string"
			? optionalMarker
			: $globalOptionalMarker);
		} else {
			$$invalidate(23, suffix = typeof requiredMarker === "string"
			? requiredMarker
			: $globalRequiredMarker);
		}
	}

	let searchRef;

	/**
 * Autocomplete options, the value must be unique
 * @type {Array<{label: string, value: any}>} */
	let options = [];

	let lastQuery = null;
	let forceUpdate = false;

	async function _reload() {
		if (!loading && (forceUpdate || query !== lastQuery)) {
			$$invalidate(5, loading = true);

			try {
				let providerQuery;
				let data;
				let debounce = false;

				function updateProviderArgs() {
					providerQuery = query;
				}

				function providerArgsChanged() {
					return providerQuery !== query || forceUpdate;
				}

				do {
					do {
						forceUpdate = false;
						updateProviderArgs();

						if (debounce && debounceMs > 0) {
							await sleep(debounceMs);
						}
					} while (providerArgsChanged());

					data = await dataProvider(query);
					debounce = true;
				} while (providerArgsChanged());

				$$invalidate(48, options = data);
				lastQuery = query;
			} catch(err) {
				dataProviderErrorHandler(err);
			} finally {
				$$invalidate(5, loading = false);
			}
		}
	}

	function reload() {
		forceUpdate = true;
		return _reload();
	}

	const debouncedReload = debounceMs > 0 ? debounce(_reload, debounceMs) : _reload;
	let showSuggested = false;
	let innerClick = false;
	const dispatch = createEventDispatcher();

	function showSuggestedOptions(e) {
		$$invalidate(25, showSuggested = true);
		$$invalidate(27, hideOnBlur = true);
	}

	function hideSuggested() {
		if (!innerClick) {
			$$invalidate(25, showSuggested = false);
		}

		$$invalidate(26, innerClick = false);
	}

	function updateValidity() {
		if (searchRef) {
			if (!optional && (multi && value.length === 0 || !multi && (value === null || value === undefined))) {
				searchRef.setCustomValidity(textIfInvalid || "Field is required");
			} else {
				searchRef.setCustomValidity("");
			}
		}
	}

	let hideOnBlur = true;
	let everFocused = false;

	function handleBlur() {
		if (everFocused && options.length === 0 && (multi && value.length > 0 || !multi && value !== null && value !== undefined)) {
			$$invalidate(0, value = multi ? [] : null);
			dispatchCustomEvent(searchRef, "change", value);
			dispatch("change", value);
		}

		updateValidity();

		if (everFocused) {
			$$invalidate(3, state = searchRef.checkValidity() ? "valid" : "invalid");
		}

		if (hideOnBlur) {
			$$invalidate(25, showSuggested = false);
		}

		$$invalidate(27, hideOnBlur = true);
	}

	onMount(() => {
		handleBlur();
	});

	function toggleOption(option, checked) {
		if (checked) {
			if (multi) {
				if (query !== "") {
					$$invalidate(1, query = "");
				}

				if (!value.includes(option.value)) {
					$$invalidate(0, value = [...value, option.value]);
					$$invalidate(4, selectedOptions = [...selectedOptions, option]);
				}
			} else {
				if (query !== option.label) {
					$$invalidate(1, query = option.label);
				}

				if (value !== option.value) {
					$$invalidate(0, value = option.value);
				}

				$$invalidate(4, selectedOptions = [option]);
			}

			$$invalidate(26, innerClick = false);
			hideSuggested();
		} else {
			if (multi) {
				if (value.includes(option.value)) {
					const optionIndex = selectedOptions.indexOf(option);

					if (optionIndex !== -1) {
						selectedOptions.splice(optionIndex, 1);
						$$invalidate(4, selectedOptions = [...selectedOptions]);
					}

					const valueIndex = value.indexOf(option.value);

					if (valueIndex !== -1) {
						value.splice(valueIndex, 1);
						$$invalidate(0, value = [...value]);
					}
				}
			} else {
				$$invalidate(4, selectedOptions = []);
			}
		}

		handleBlur();
		dispatchCustomEvent(searchRef, "change", value);
		dispatch("change", value);
	}

	function handleChangeGenerator(option) {
		return function () {
			toggleOption(option, this.checked);
		};
	}

	let outlineOptionIndex = 0;
	let optionsRenderedRef;

	function updateSuggestedMaxHeight() {
		if (suggestedRef && suggestedRef.querySelector("label")) {
			$$invalidate(22, suggestedRef.style.maxHeight = suggestedRef.querySelector("label").offsetHeight * maxSuggestions + "px", suggestedRef);
		}
	}

	function handleInput() {
		if (query !== this.value) {
			$$invalidate(1, query = this.value);
			dispatch("query", query);
			$$invalidate(25, showSuggested = true);
		}
	}

	let suggestedRef = null;

	/** @param {KeyboardEvent} e */
	function handleKeydown(e) {
		if (e.key === "Escape") {
			$$invalidate(25, showSuggested = false);
		} else if (suggestedRef && options.length > 0 && ["ArrowUp", "ArrowDown", "Enter", "PageUp", "PageDown"].includes(e.key)) {
			e.preventDefault();

			switch (e.key) {
				case "ArrowUp":
					$$invalidate(20, outlineOptionIndex = Math.max(0, outlineOptionIndex - 1));
					break;
				case "ArrowDown":
					$$invalidate(20, outlineOptionIndex = Math.min(options.length - 1, outlineOptionIndex + 1));
					break;
				case "PageUp":
					$$invalidate(20, outlineOptionIndex = Math.max(0, outlineOptionIndex - maxSuggestions));
					break;
				case "PageDown":
					$$invalidate(20, outlineOptionIndex = Math.min(options.length - 1, outlineOptionIndex + maxSuggestions));
					break;
				case "Enter":
					const input = suggestedRef.querySelectorAll("input")[outlineOptionIndex];
					input.checked = true;
					dispatchCustomEvent(input, "change");
					break;
			}
		} else if (e.key === "Enter" && options.length === 0) {
			$$invalidate(27, hideOnBlur = false);
			handleBlur();
		}
	}

	function resetQueryAndValue() {
		if (multi) {
			$$invalidate(0, value = []);
		} else {
			$$invalidate(0, value = null);
		}

		$$invalidate(4, selectedOptions = []);
		$$invalidate(1, query = "");
	}

	let lastMultiValue = multi;

	function handleMultiChange() {
		if (multi === lastMultiValue) {
			return;
		}

		lastMultiValue = multi;
		resetQueryAndValue();
	}

	let filteredOptions = [];

	function updateFilteredOptions() {
		$$invalidate(29, filteredOptions = options.filter(o => !multi || !value.includes(o.value)));
	}

	function scheduleDataProviderCall() {
		if (debouncedReload.clear) {
			debouncedReload.clear();
		}

		debouncedReload();
	}

	const touchstart_handler = () => $$invalidate(27, hideOnBlur = false);
	const mousedown_handler = () => $$invalidate(27, hideOnBlur = false);

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			searchRef = $$value;
			$$invalidate(24, searchRef);
		});
	}

	const focus_handler = () => ($$invalidate(28, everFocused = true), $$invalidate(3, state = "initial"));

	const keydown_handler = e => {
		if (["Enter"].includes(e.code)) {
			e.preventDefault();
			resetQueryAndValue();
			handleBlur();
			dispatchCustomEvent(searchRef, "change", value);
			dispatch("change", value);
			searchRef.focus();
		}
	};

	const click_handler = () => {
		resetQueryAndValue();
		handleBlur();
		dispatchCustomEvent(searchRef, "change", value);
		dispatch("change", value);
	};

	const keydown_handler_1 = (option, e) => {
		if (["Enter"].includes(e.code)) {
			e.preventDefault();
			toggleOption(option, false);
		}
	};

	const click_handler_1 = option => {
		toggleOption(option, false);
	};

	function div_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			optionsRenderedRef = $$value;
			$$invalidate(21, optionsRenderedRef);
		});
	}

	function div_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			suggestedRef = $$value;
			((($$invalidate(22, suggestedRef), $$invalidate(48, options)), $$invalidate(20, outlineOptionIndex)), $$invalidate(0, value));
		});
	}

	function div1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(2, ref);
		});
	}

	const click_handler_2 = () => $$invalidate(26, innerClick = true);

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(6, id = $$props.id);
		if ('multi' in $$props) $$invalidate(7, multi = $$props.multi);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(8, label = $$props.label);
		if ('className' in $$props) $$invalidate(9, className = $$props.className);
		if ('style' in $$props) $$invalidate(10, style = $$props.style);
		if ('textIfNoResult' in $$props) $$invalidate(11, textIfNoResult = $$props.textIfNoResult);
		if ('textIfInvalid' in $$props) $$invalidate(39, textIfInvalid = $$props.textIfInvalid);
		if ('disabled' in $$props) $$invalidate(12, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(13, tooltip = $$props.tooltip);
		if ('placeholder' in $$props) $$invalidate(14, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(40, optional = $$props.optional);
		if ('ref' in $$props) $$invalidate(2, ref = $$props.ref);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('animationDuration' in $$props) $$invalidate(19, animationDuration = $$props.animationDuration);
		if ('state' in $$props) $$invalidate(3, state = $$props.state);
		if ('query' in $$props) $$invalidate(1, query = $$props.query);
		if ('selectedOptions' in $$props) $$invalidate(4, selectedOptions = $$props.selectedOptions);
		if ('dataProvider' in $$props) $$invalidate(41, dataProvider = $$props.dataProvider);
		if ('dataProviderErrorHandler' in $$props) $$invalidate(42, dataProviderErrorHandler = $$props.dataProviderErrorHandler);
		if ('loading' in $$props) $$invalidate(5, loading = $$props.loading);
		if ('debounceMs' in $$props) $$invalidate(43, debounceMs = $$props.debounceMs);
		if ('maxSuggestions' in $$props) $$invalidate(44, maxSuggestions = $$props.maxSuggestions);
		if ('requiredMarker' in $$props) $$invalidate(45, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(46, optionalMarker = $$props.optionalMarker);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[1] & /*optional, requiredMarker, optionalMarker, $globalRequiredMarker, $globalOptionalMarker*/ 1622528) {
			(updateLabelSuffix());
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			{
				$$invalidate(20, outlineOptionIndex = 0);
				updateValidity();
			}
		}

		if ($$self.$$.dirty[1] & /*options*/ 131072) {
			if (options) {
				$$invalidate(20, outlineOptionIndex = 0);
			}
		}

		if ($$self.$$.dirty[0] & /*suggestedRef, outlineOptionIndex*/ 5242880 | $$self.$$.dirty[1] & /*options*/ 131072) {
			if (suggestedRef) {
				if (options.length === 0) {
					$$invalidate(22, suggestedRef.scrollTop = 0, suggestedRef);
				} else {
					$$invalidate(22, suggestedRef.scrollTop = Math.max(0, suggestedRef.scrollHeight / options.length * (outlineOptionIndex - 3)), suggestedRef);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*optionsRenderedRef*/ 2097152) {
			$$invalidate(49, optionsRendered = Boolean(optionsRenderedRef));
		}

		if ($$self.$$.dirty[1] & /*optionsRendered*/ 262144) {
			if (optionsRendered) {
				updateSuggestedMaxHeight();
			}
		}

		if ($$self.$$.dirty[0] & /*multi*/ 128) {
			(handleMultiChange());
		}

		if ($$self.$$.dirty[0] & /*multi*/ 128 | $$self.$$.dirty[1] & /*options*/ 131072) {
			(updateFilteredOptions());
		}

		if ($$self.$$.dirty[0] & /*query*/ 2) {
			(scheduleDataProviderCall());
		}
	};

	return [
		value,
		query,
		ref,
		state,
		selectedOptions,
		loading,
		id,
		multi,
		label,
		className,
		style,
		textIfNoResult,
		disabled,
		tooltip,
		placeholder,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		animationDuration,
		outlineOptionIndex,
		optionsRenderedRef,
		suggestedRef,
		suffix,
		searchRef,
		showSuggested,
		innerClick,
		hideOnBlur,
		everFocused,
		filteredOptions,
		dispatch,
		showSuggestedOptions,
		hideSuggested,
		handleBlur,
		toggleOption,
		handleChangeGenerator,
		handleInput,
		handleKeydown,
		resetQueryAndValue,
		textIfInvalid,
		optional,
		dataProvider,
		dataProviderErrorHandler,
		debounceMs,
		maxSuggestions,
		requiredMarker,
		optionalMarker,
		reload,
		options,
		optionsRendered,
		$globalOptionalMarker,
		$globalRequiredMarker,
		touchstart_handler,
		mousedown_handler,
		input_binding,
		focus_handler,
		keydown_handler,
		click_handler,
		keydown_handler_1,
		click_handler_1,
		div_binding,
		div_binding_1,
		div1_binding,
		click_handler_2
	];
}

class AsyncAutocomplete extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$h,
			create_fragment$h,
			safe_not_equal,
			{
				id: 6,
				multi: 7,
				value: 0,
				label: 8,
				className: 9,
				style: 10,
				textIfNoResult: 11,
				textIfInvalid: 39,
				disabled: 12,
				tooltip: 13,
				placeholder: 14,
				optional: 40,
				ref: 2,
				autocapitalize: 15,
				autocomplete: 16,
				autocorrect: 17,
				spellcheck: 18,
				animationDuration: 19,
				state: 3,
				query: 1,
				selectedOptions: 4,
				dataProvider: 41,
				dataProviderErrorHandler: 42,
				loading: 5,
				debounceMs: 43,
				maxSuggestions: 44,
				requiredMarker: 45,
				optionalMarker: 46,
				reload: 47
			},
			null,
			[-1, -1, -1]
		);
	}

	get reload() {
		return this.$$.ctx[47];
	}
}

function matchDistance(str, search) {
	const levenDst = leven(str, search);
	const compensation = -Math.max(0, str.length - search.length);
	return levenDst + compensation;
}

/**
 * @template T
 * @param {string} search 
 * @param {T[]} objects 
 * @param {(o: T) => string} stringExtractor 
 */
function filterAndSort(search, objects, stringExtractor) {
	const searchLower = search.toLowerCase();
	const distances = objects.map((o, index) => ({
		distance: matchDistance(stringExtractor(o).toLowerCase(), searchLower),
		index,
		value: stringExtractor(o).toLowerCase(),
	}))
		.filter((d) => d.distance < d.value.length)
		.sort((a, b) => {
			if (a.distance - b.distance === 0) {
				const aHasSubstring = a.value.indexOf(search) !== -1;
				const bHasSubstring = b.value.indexOf(search) !== -1;
				if (aHasSubstring && !bHasSubstring) {
					return -1
				}
				if (!aHasSubstring && bHasSubstring) {
					return 1;
				}
				return a.value.localeCompare(b.value);
			}
			return a.distance - b.distance;
		});
	const filteredAndSorted = new Array(distances.length);
	for (let i = 0; i < distances.length; i++) {
		filteredAndSorted[i] = objects[distances[i].index];
	}

	return filteredAndSorted;
}

/* src/components/form/Autocomplete.svelte generated by Svelte v4.2.19 */

function create_fragment$g(ctx) {
	let asyncautocomplete;
	let updating_selectedOptions;
	let updating_query;
	let updating_ref;
	let updating_state;
	let updating_value;
	let current;

	function asyncautocomplete_selectedOptions_binding(value) {
		/*asyncautocomplete_selectedOptions_binding*/ ctx[28](value);
	}

	function asyncautocomplete_query_binding(value) {
		/*asyncautocomplete_query_binding*/ ctx[29](value);
	}

	function asyncautocomplete_ref_binding(value) {
		/*asyncautocomplete_ref_binding*/ ctx[30](value);
	}

	function asyncautocomplete_state_binding(value) {
		/*asyncautocomplete_state_binding*/ ctx[31](value);
	}

	function asyncautocomplete_value_binding(value) {
		/*asyncautocomplete_value_binding*/ ctx[32](value);
	}

	let asyncautocomplete_props = {
		multi: /*multi*/ ctx[6],
		animationDuration: /*animationDuration*/ ctx[20],
		autocomplete: /*autocomplete*/ ctx[17],
		autocapitalize: /*autocapitalize*/ ctx[16],
		autocorrect: /*autocorrect*/ ctx[18],
		className: /*className*/ ctx[8],
		dataProvider: /*dataProvider*/ ctx[24],
		dataProviderErrorHandler: noop,
		debounceMs: 0,
		disabled: /*disabled*/ ctx[12],
		id: /*id*/ ctx[5],
		label: /*label*/ ctx[7],
		optional: /*optional*/ ctx[15],
		optionalMarker: /*optionalMarker*/ ctx[22],
		placeholder: /*placeholder*/ ctx[14],
		requiredMarker: /*requiredMarker*/ ctx[21],
		spellcheck: /*spellcheck*/ ctx[19],
		style: /*style*/ ctx[9],
		textIfInvalid: /*textIfInvalid*/ ctx[11],
		textIfNoResult: /*textIfNoResult*/ ctx[10],
		tooltip: /*tooltip*/ ctx[13]
	};

	if (/*selectedOptions*/ ctx[4] !== void 0) {
		asyncautocomplete_props.selectedOptions = /*selectedOptions*/ ctx[4];
	}

	if (/*query*/ ctx[3] !== void 0) {
		asyncautocomplete_props.query = /*query*/ ctx[3];
	}

	if (/*ref*/ ctx[1] !== void 0) {
		asyncautocomplete_props.ref = /*ref*/ ctx[1];
	}

	if (/*state*/ ctx[2] !== void 0) {
		asyncautocomplete_props.state = /*state*/ ctx[2];
	}

	if (/*value*/ ctx[0] !== void 0) {
		asyncautocomplete_props.value = /*value*/ ctx[0];
	}

	asyncautocomplete = new AsyncAutocomplete({ props: asyncautocomplete_props });
	/*asyncautocomplete_binding*/ ctx[27](asyncautocomplete);
	binding_callbacks.push(() => bind(asyncautocomplete, 'selectedOptions', asyncautocomplete_selectedOptions_binding));
	binding_callbacks.push(() => bind(asyncautocomplete, 'query', asyncautocomplete_query_binding));
	binding_callbacks.push(() => bind(asyncautocomplete, 'ref', asyncautocomplete_ref_binding));
	binding_callbacks.push(() => bind(asyncautocomplete, 'state', asyncautocomplete_state_binding));
	binding_callbacks.push(() => bind(asyncautocomplete, 'value', asyncautocomplete_value_binding));
	asyncautocomplete.$on("change", /*change_handler*/ ctx[33]);
	asyncautocomplete.$on("query", /*query_handler*/ ctx[34]);

	return {
		c() {
			create_component(asyncautocomplete.$$.fragment);
		},
		m(target, anchor) {
			mount_component(asyncautocomplete, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const asyncautocomplete_changes = {};
			if (dirty[0] & /*multi*/ 64) asyncautocomplete_changes.multi = /*multi*/ ctx[6];
			if (dirty[0] & /*animationDuration*/ 1048576) asyncautocomplete_changes.animationDuration = /*animationDuration*/ ctx[20];
			if (dirty[0] & /*autocomplete*/ 131072) asyncautocomplete_changes.autocomplete = /*autocomplete*/ ctx[17];
			if (dirty[0] & /*autocapitalize*/ 65536) asyncautocomplete_changes.autocapitalize = /*autocapitalize*/ ctx[16];
			if (dirty[0] & /*autocorrect*/ 262144) asyncautocomplete_changes.autocorrect = /*autocorrect*/ ctx[18];
			if (dirty[0] & /*className*/ 256) asyncautocomplete_changes.className = /*className*/ ctx[8];
			if (dirty[0] & /*disabled*/ 4096) asyncautocomplete_changes.disabled = /*disabled*/ ctx[12];
			if (dirty[0] & /*id*/ 32) asyncautocomplete_changes.id = /*id*/ ctx[5];
			if (dirty[0] & /*label*/ 128) asyncautocomplete_changes.label = /*label*/ ctx[7];
			if (dirty[0] & /*optional*/ 32768) asyncautocomplete_changes.optional = /*optional*/ ctx[15];
			if (dirty[0] & /*optionalMarker*/ 4194304) asyncautocomplete_changes.optionalMarker = /*optionalMarker*/ ctx[22];
			if (dirty[0] & /*placeholder*/ 16384) asyncautocomplete_changes.placeholder = /*placeholder*/ ctx[14];
			if (dirty[0] & /*requiredMarker*/ 2097152) asyncautocomplete_changes.requiredMarker = /*requiredMarker*/ ctx[21];
			if (dirty[0] & /*spellcheck*/ 524288) asyncautocomplete_changes.spellcheck = /*spellcheck*/ ctx[19];
			if (dirty[0] & /*style*/ 512) asyncautocomplete_changes.style = /*style*/ ctx[9];
			if (dirty[0] & /*textIfInvalid*/ 2048) asyncautocomplete_changes.textIfInvalid = /*textIfInvalid*/ ctx[11];
			if (dirty[0] & /*textIfNoResult*/ 1024) asyncautocomplete_changes.textIfNoResult = /*textIfNoResult*/ ctx[10];
			if (dirty[0] & /*tooltip*/ 8192) asyncautocomplete_changes.tooltip = /*tooltip*/ ctx[13];

			if (!updating_selectedOptions && dirty[0] & /*selectedOptions*/ 16) {
				updating_selectedOptions = true;
				asyncautocomplete_changes.selectedOptions = /*selectedOptions*/ ctx[4];
				add_flush_callback(() => updating_selectedOptions = false);
			}

			if (!updating_query && dirty[0] & /*query*/ 8) {
				updating_query = true;
				asyncautocomplete_changes.query = /*query*/ ctx[3];
				add_flush_callback(() => updating_query = false);
			}

			if (!updating_ref && dirty[0] & /*ref*/ 2) {
				updating_ref = true;
				asyncautocomplete_changes.ref = /*ref*/ ctx[1];
				add_flush_callback(() => updating_ref = false);
			}

			if (!updating_state && dirty[0] & /*state*/ 4) {
				updating_state = true;
				asyncautocomplete_changes.state = /*state*/ ctx[2];
				add_flush_callback(() => updating_state = false);
			}

			if (!updating_value && dirty[0] & /*value*/ 1) {
				updating_value = true;
				asyncautocomplete_changes.value = /*value*/ ctx[0];
				add_flush_callback(() => updating_value = false);
			}

			asyncautocomplete.$set(asyncautocomplete_changes);
		},
		i(local) {
			if (current) return;
			transition_in(asyncautocomplete.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(asyncautocomplete.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			/*asyncautocomplete_binding*/ ctx[27](null);
			destroy_component(asyncautocomplete, detaching);
		}
	};
}

function instance$g($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { options = [] } = $$props;
	let { multi = false } = $$props;
	let { value = !multi ? null : [] } = $$props;
	let { label = "" } = $$props;
	let { className = undefined } = $$props;
	let { style = undefined } = $$props;
	let { textIfNoResult = "" } = $$props;
	let { textIfInvalid = "" } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { placeholder = undefined } = $$props;
	let { optional = false } = $$props;
	let { ref = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = "off" } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { animationDuration = 100 } = $$props;
	let { state = "initial" } = $$props;
	let { query = "" } = $$props;
	let { selectedOptions = [] } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;

	function dataProvider(query) {
		return filterAndSort(query.toLowerCase(), options, o => o.label.toLowerCase());
	}

	function handleValueChange() {
		if (!multi) {
			const candidate = options.find(o => o.value === value);

			if (candidate) {
				$$invalidate(3, query = candidate.label);
				$$invalidate(4, selectedOptions = [candidate]);
			} else {
				$$invalidate(3, query = "");
				$$invalidate(4, selectedOptions = []);
			}
		} else {
			$$invalidate(3, query = "");

			// Keeps the selection order
			$$invalidate(4, selectedOptions = value.map(v => options.find(o => o.value === v)).filter(o => o !== undefined));
		}
	}

	let asyncAutocomplete;

	async function reload() {
		if (!asyncAutocomplete) {
			return;
		}

		return asyncAutocomplete.reload();
	}

	function asyncautocomplete_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			asyncAutocomplete = $$value;
			$$invalidate(23, asyncAutocomplete);
		});
	}

	function asyncautocomplete_selectedOptions_binding(value) {
		selectedOptions = value;
		$$invalidate(4, selectedOptions);
	}

	function asyncautocomplete_query_binding(value) {
		query = value;
		$$invalidate(3, query);
	}

	function asyncautocomplete_ref_binding(value) {
		ref = value;
		$$invalidate(1, ref);
	}

	function asyncautocomplete_state_binding(value) {
		state = value;
		$$invalidate(2, state);
	}

	function asyncautocomplete_value_binding(value$1) {
		value = value$1;
		$$invalidate(0, value);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function query_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(5, id = $$props.id);
		if ('options' in $$props) $$invalidate(25, options = $$props.options);
		if ('multi' in $$props) $$invalidate(6, multi = $$props.multi);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('label' in $$props) $$invalidate(7, label = $$props.label);
		if ('className' in $$props) $$invalidate(8, className = $$props.className);
		if ('style' in $$props) $$invalidate(9, style = $$props.style);
		if ('textIfNoResult' in $$props) $$invalidate(10, textIfNoResult = $$props.textIfNoResult);
		if ('textIfInvalid' in $$props) $$invalidate(11, textIfInvalid = $$props.textIfInvalid);
		if ('disabled' in $$props) $$invalidate(12, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(13, tooltip = $$props.tooltip);
		if ('placeholder' in $$props) $$invalidate(14, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(15, optional = $$props.optional);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('autocapitalize' in $$props) $$invalidate(16, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(17, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(18, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(19, spellcheck = $$props.spellcheck);
		if ('animationDuration' in $$props) $$invalidate(20, animationDuration = $$props.animationDuration);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
		if ('query' in $$props) $$invalidate(3, query = $$props.query);
		if ('selectedOptions' in $$props) $$invalidate(4, selectedOptions = $$props.selectedOptions);
		if ('requiredMarker' in $$props) $$invalidate(21, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(22, optionalMarker = $$props.optionalMarker);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			(handleValueChange());
		}

		if ($$self.$$.dirty[0] & /*options*/ 33554432) {
			(reload());
		}
	};

	return [
		value,
		ref,
		state,
		query,
		selectedOptions,
		id,
		multi,
		label,
		className,
		style,
		textIfNoResult,
		textIfInvalid,
		disabled,
		tooltip,
		placeholder,
		optional,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		animationDuration,
		requiredMarker,
		optionalMarker,
		asyncAutocomplete,
		dataProvider,
		options,
		reload,
		asyncautocomplete_binding,
		asyncautocomplete_selectedOptions_binding,
		asyncautocomplete_query_binding,
		asyncautocomplete_ref_binding,
		asyncautocomplete_state_binding,
		asyncautocomplete_value_binding,
		change_handler,
		query_handler
	];
}

class Autocomplete extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$g,
			create_fragment$g,
			safe_not_equal,
			{
				id: 5,
				options: 25,
				multi: 6,
				value: 0,
				label: 7,
				className: 8,
				style: 9,
				textIfNoResult: 10,
				textIfInvalid: 11,
				disabled: 12,
				tooltip: 13,
				placeholder: 14,
				optional: 15,
				ref: 1,
				autocapitalize: 16,
				autocomplete: 17,
				autocorrect: 18,
				spellcheck: 19,
				animationDuration: 20,
				state: 2,
				query: 3,
				selectedOptions: 4,
				requiredMarker: 21,
				optionalMarker: 22,
				reload: 26
			},
			null,
			[-1, -1]
		);
	}

	get reload() {
		return this.$$.ctx[26];
	}
}

/* src/components/form/Checkbox.svelte generated by Svelte v4.2.19 */

function create_default_slot$c(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			attr(input, "uk-tooltip", /*tooltip*/ ctx[13]);
			input.required = input_required_value = !/*optional*/ ctx[11];
			attr(input, "type", "checkbox");
			input.disabled = /*disabled*/ ctx[12];
			attr(input, "class", "uk-checkbox");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[17](input);
			input.checked = /*value*/ ctx[0];

			if (!mounted) {
				dispose = [
					listen(input, "change", /*input_change_handler*/ ctx[18]),
					listen(input, "change", /*change_handler*/ ctx[16]),
					listen(input, "blur", /*blur_handler*/ ctx[19]),
					listen(input, "focus", /*focus_handler*/ ctx[20])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty & /*tooltip*/ 8192) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[13]);
			}

			if (dirty & /*optional*/ 2048 && input_required_value !== (input_required_value = !/*optional*/ ctx[11])) {
				input.required = input_required_value;
			}

			if (dirty & /*disabled*/ 4096) {
				input.disabled = /*disabled*/ ctx[12];
			}

			if (dirty & /*value*/ 1) {
				input.checked = /*value*/ ctx[0];
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[17](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$f(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				labelWrap: true,
				requiredMarker: /*requiredMarker*/ ctx[14],
				optionalMarker: /*optionalMarker*/ ctx[15],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				className: /*className*/ ctx[6],
				style: /*style*/ ctx[5],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[11],
				$$slots: { default: [create_default_slot$c] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_changes = {};
			if (dirty & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty & /*requiredMarker*/ 16384) field_changes.requiredMarker = /*requiredMarker*/ ctx[14];
			if (dirty & /*optionalMarker*/ 32768) field_changes.optionalMarker = /*optionalMarker*/ ctx[15];
			if (dirty & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty & /*optional*/ 2048) field_changes.optional = /*optional*/ ctx[11];

			if (dirty & /*$$scope, id, name, tooltip, optional, disabled, ref, value, state*/ 2111631) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$f($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_change_handler() {
		value = this.checked;
		$$invalidate(0, value);
	}

	const blur_handler = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('optional' in $$props) $$invalidate(11, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(12, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(13, tooltip = $$props.tooltip);
		if ('requiredMarker' in $$props) $$invalidate(14, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(15, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		optional,
		disabled,
		tooltip,
		requiredMarker,
		optionalMarker,
		change_handler,
		input_binding,
		input_change_handler,
		blur_handler,
		focus_handler
	];
}

class Checkbox extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$f, create_fragment$f, safe_not_equal, {
			id: 3,
			label: 4,
			style: 5,
			className: 6,
			name: 7,
			textIfInvalid: 8,
			textIfValid: 9,
			helperText: 10,
			optional: 11,
			value: 0,
			ref: 1,
			disabled: 12,
			tooltip: 13,
			requiredMarker: 14,
			optionalMarker: 15,
			state: 2
		});
	}
}

/* src/components/form/DatePicker.svelte generated by Svelte v4.2.19 */

function create_default_slot$b(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[17]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[18]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[19]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[20]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "date");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "min", /*min*/ ctx[15]);
			attr(input, "max", /*max*/ ctx[16]);
			attr(input, "class", "uk-input");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[27](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[28]),
					listen(input, "input", /*input_handler*/ ctx[23]),
					listen(input, "change", /*change_handler*/ ctx[24]),
					listen(input, "blur", /*blur_handler*/ ctx[25]),
					listen(input, "focus", /*focus_handler*/ ctx[26]),
					listen(input, "blur", /*blur_handler_1*/ ctx[29]),
					listen(input, "focus", /*focus_handler_1*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*autocapitalize*/ 131072) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[17]);
			}

			if (dirty[0] & /*autocomplete*/ 262144) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[18]);
			}

			if (dirty[0] & /*autocorrect*/ 524288) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[19]);
			}

			if (dirty[0] & /*spellcheck*/ 1048576) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[20]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty[0] & /*min*/ 32768) {
				attr(input, "min", /*min*/ ctx[15]);
			}

			if (dirty[0] & /*max*/ 65536) {
				attr(input, "max", /*max*/ ctx[16]);
			}

			if (dirty[0] & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[27](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$e(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[21],
				optionalMarker: /*optionalMarker*/ ctx[22],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				className: /*className*/ ctx[6],
				style: /*style*/ ctx[5],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$b] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 2097152) field_changes.requiredMarker = /*requiredMarker*/ ctx[21];
			if (dirty[0] & /*optionalMarker*/ 4194304) field_changes.optionalMarker = /*optionalMarker*/ ctx[22];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty[0] & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty[0] & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*autocapitalize, autocomplete, autocorrect, spellcheck, id, name, tooltip, optional, placeholder, disabled, min, max, ref, value, state*/ 2095247 | dirty[1] & /*$$scope*/ 1) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$e($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { min = undefined } = $$props;
	let { max = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('min' in $$props) $$invalidate(15, min = $$props.min);
		if ('max' in $$props) $$invalidate(16, max = $$props.max);
		if ('autocapitalize' in $$props) $$invalidate(17, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(18, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(19, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(20, spellcheck = $$props.spellcheck);
		if ('requiredMarker' in $$props) $$invalidate(21, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(22, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		min,
		max,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class DatePicker extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$e,
			create_fragment$e,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				style: 5,
				className: 6,
				name: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 1,
				disabled: 13,
				tooltip: 14,
				min: 15,
				max: 16,
				autocapitalize: 17,
				autocomplete: 18,
				autocorrect: 19,
				spellcheck: 20,
				requiredMarker: 21,
				optionalMarker: 22,
				state: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/EmailInput.svelte generated by Svelte v4.2.19 */

function create_default_slot$a(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "email");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "class", "uk-input");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[25](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[26]),
					listen(input, "input", /*input_handler*/ ctx[21]),
					listen(input, "change", /*change_handler*/ ctx[22]),
					listen(input, "blur", /*blur_handler*/ ctx[23]),
					listen(input, "focus", /*focus_handler*/ ctx[24]),
					listen(input, "blur", /*blur_handler_1*/ ctx[27]),
					listen(input, "focus", /*focus_handler_1*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$d(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[19],
				optionalMarker: /*optionalMarker*/ ctx[20],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				style: /*style*/ ctx[5],
				className: /*className*/ ctx[6],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$a] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_changes = {};
			if (dirty & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty & /*requiredMarker*/ 524288) field_changes.requiredMarker = /*requiredMarker*/ ctx[19];
			if (dirty & /*optionalMarker*/ 1048576) field_changes.optionalMarker = /*optionalMarker*/ ctx[20];
			if (dirty & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty & /*$$scope, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, tooltip, optional, placeholder, disabled, ref, value, state*/ 537393295) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$d($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = 'off' } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = 'off' } = $$props;
	let { spellcheck = 'off' } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('requiredMarker' in $$props) $$invalidate(19, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(20, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class EmailInput extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$d, create_fragment$d, safe_not_equal, {
			id: 3,
			label: 4,
			style: 5,
			className: 6,
			name: 7,
			textIfInvalid: 8,
			textIfValid: 9,
			helperText: 10,
			placeholder: 11,
			optional: 12,
			value: 0,
			ref: 1,
			disabled: 13,
			tooltip: 14,
			autocapitalize: 15,
			autocomplete: 16,
			autocorrect: 17,
			spellcheck: 18,
			requiredMarker: 19,
			optionalMarker: 20,
			state: 2
		});
	}
}

/* src/components/form/TextInput.svelte generated by Svelte v4.2.19 */

function create_if_block_2$1(ctx) {
	let if_block_anchor;
	let if_block = /*icon*/ ctx[15] && create_if_block_3$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[15]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (89:4) {#if icon}
function create_if_block_3$1(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-form-icon");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[15]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 32768 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[15])) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (120:2) {#if iconPosition === 'right'}
function create_if_block$4(ctx) {
	let if_block_anchor;
	let if_block = /*icon*/ ctx[15] && create_if_block_1$1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[15]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (121:4) {#if icon}
function create_if_block_1$1(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-form-icon right svelte-1whx3ya");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[15]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 32768 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[15])) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (75:0) <Field   hasIcon={!!icon}   inputId={id}   {requiredMarker}   {optionalMarker}   {label}   {state}   {className}   {style}   {textIfInvalid}   {textIfValid}   {helperText}   {optional}>
function create_default_slot$9(ctx) {
	let t0;
	let input;
	let input_required_value;
	let t1;
	let if_block1_anchor;
	let mounted;
	let dispose;
	let if_block0 = /*iconPosition*/ ctx[16] === 'left' && create_if_block_2$1(ctx);
	let if_block1 = /*iconPosition*/ ctx[16] === 'right' && create_if_block$4(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			input = element("input");
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(input, "minlength", /*minlength*/ ctx[23]);
			attr(input, "maxlength", /*maxlength*/ ctx[24]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[19]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[20]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[21]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[22]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "text");
			attr(input, "inputmode", /*inputmode*/ ctx[17]);
			attr(input, "pattern", /*pattern*/ ctx[18]);
			attr(input, "class", "uk-input svelte-1whx3ya");
			toggle_class(input, "paddingRight", /*iconPosition*/ ctx[16] === 'right');
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, input, anchor);
			/*input_binding*/ ctx[32](input);
			set_input_value(input, /*value*/ ctx[0]);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[33]),
					listen(input, "change", /*change_handler*/ ctx[27]),
					listen(input, "keydown", /*keydown_handler*/ ctx[28]),
					listen(input, "input", /*input_handler*/ ctx[29]),
					listen(input, "blur", /*blur_handler*/ ctx[30]),
					listen(input, "blur", /*blur_handler_1*/ ctx[34]),
					listen(input, "focus", /*focus_handler_1*/ ctx[35]),
					listen(input, "focus", /*focus_handler*/ ctx[31])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*iconPosition*/ ctx[16] === 'left') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2$1(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*minlength*/ 8388608) {
				attr(input, "minlength", /*minlength*/ ctx[23]);
			}

			if (dirty[0] & /*maxlength*/ 16777216) {
				attr(input, "maxlength", /*maxlength*/ ctx[24]);
			}

			if (dirty[0] & /*autocapitalize*/ 524288) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[19]);
			}

			if (dirty[0] & /*autocomplete*/ 1048576) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[20]);
			}

			if (dirty[0] & /*autocorrect*/ 2097152) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[21]);
			}

			if (dirty[0] & /*spellcheck*/ 4194304) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[22]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty[0] & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*inputmode*/ 131072) {
				attr(input, "inputmode", /*inputmode*/ ctx[17]);
			}

			if (dirty[0] & /*pattern*/ 262144) {
				attr(input, "pattern", /*pattern*/ ctx[18]);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*iconPosition*/ 65536) {
				toggle_class(input, "paddingRight", /*iconPosition*/ ctx[16] === 'right');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}

			if (/*iconPosition*/ ctx[16] === 'right') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$4(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(input);
				detach(t1);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			/*input_binding*/ ctx[32](null);
			if (if_block1) if_block1.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$c(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				hasIcon: !!/*icon*/ ctx[15],
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[25],
				optionalMarker: /*optionalMarker*/ ctx[26],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				className: /*className*/ ctx[6],
				style: /*style*/ ctx[5],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$9] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*icon*/ 32768) field_changes.hasIcon = !!/*icon*/ ctx[15];
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 33554432) field_changes.requiredMarker = /*requiredMarker*/ ctx[25];
			if (dirty[0] & /*optionalMarker*/ 67108864) field_changes.optionalMarker = /*optionalMarker*/ ctx[26];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty[0] & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty[0] & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*icon, iconPosition, minlength, maxlength, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, disabled, tooltip, optional, placeholder, inputmode, pattern, ref, value, state*/ 33552527 | dirty[1] & /*$$scope*/ 32) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$c($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { iconPosition = "left" } = $$props;
	let { inputmode = undefined } = $$props;
	let { pattern = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('icon' in $$props) $$invalidate(15, icon = $$props.icon);
		if ('iconPosition' in $$props) $$invalidate(16, iconPosition = $$props.iconPosition);
		if ('inputmode' in $$props) $$invalidate(17, inputmode = $$props.inputmode);
		if ('pattern' in $$props) $$invalidate(18, pattern = $$props.pattern);
		if ('autocapitalize' in $$props) $$invalidate(19, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(20, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(21, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(22, spellcheck = $$props.spellcheck);
		if ('minlength' in $$props) $$invalidate(23, minlength = $$props.minlength);
		if ('maxlength' in $$props) $$invalidate(24, maxlength = $$props.maxlength);
		if ('requiredMarker' in $$props) $$invalidate(25, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(26, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		icon,
		iconPosition,
		inputmode,
		pattern,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		minlength,
		maxlength,
		requiredMarker,
		optionalMarker,
		change_handler,
		keydown_handler,
		input_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class TextInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$c,
			create_fragment$c,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				style: 5,
				className: 6,
				name: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 1,
				disabled: 13,
				tooltip: 14,
				icon: 15,
				iconPosition: 16,
				inputmode: 17,
				pattern: 18,
				autocapitalize: 19,
				autocomplete: 20,
				autocorrect: 21,
				spellcheck: 22,
				minlength: 23,
				maxlength: 24,
				requiredMarker: 25,
				optionalMarker: 26,
				state: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/FixedPointInput.svelte generated by Svelte v4.2.19 */

function create_fragment$b(ctx) {
	let textinput;
	let updating_state;
	let updating_ref;
	let current;

	function textinput_state_binding(value) {
		/*textinput_state_binding*/ ctx[25](value);
	}

	function textinput_ref_binding(value) {
		/*textinput_ref_binding*/ ctx[26](value);
	}

	let textinput_props = {
		autocapitalize: "off",
		autocomplete: "off",
		autocorrect: "off",
		spellcheck: "false",
		id: /*id*/ ctx[2],
		icon: /*icon*/ ctx[12],
		iconPosition: /*iconPosition*/ ctx[13],
		label: /*label*/ ctx[3],
		style: /*style*/ ctx[4],
		className: /*className*/ ctx[5],
		textIfInvalid: /*textIfInvalid*/ ctx[6],
		textIfValid: /*textIfValid*/ ctx[7],
		helperText: /*helperText*/ ctx[8],
		optional: /*optional*/ ctx[9],
		disabled: /*disabled*/ ctx[10],
		tooltip: /*tooltip*/ ctx[11],
		value: /*localeValue*/ ctx[14],
		inputmode: "numeric"
	};

	if (/*state*/ ctx[1] !== void 0) {
		textinput_props.state = /*state*/ ctx[1];
	}

	if (/*ref*/ ctx[0] !== void 0) {
		textinput_props.ref = /*ref*/ ctx[0];
	}

	textinput = new TextInput({ props: textinput_props });
	binding_callbacks.push(() => bind(textinput, 'state', textinput_state_binding));
	binding_callbacks.push(() => bind(textinput, 'ref', textinput_ref_binding));
	textinput.$on("keydown", /*handleKeydown*/ ctx[16]);
	textinput.$on("input", /*handleInput*/ ctx[17]);
	textinput.$on("input", /*input_handler*/ ctx[27]);
	textinput.$on("change", /*updateState*/ ctx[19]);
	textinput.$on("blur", /*updateState*/ ctx[19]);
	textinput.$on("blur", /*handleBlur*/ ctx[18]);
	textinput.$on("blur", /*blur_handler*/ ctx[28]);
	textinput.$on("focus", /*handleFocus*/ ctx[15]);

	return {
		c() {
			create_component(textinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(textinput, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const textinput_changes = {};
			if (dirty[0] & /*id*/ 4) textinput_changes.id = /*id*/ ctx[2];
			if (dirty[0] & /*icon*/ 4096) textinput_changes.icon = /*icon*/ ctx[12];
			if (dirty[0] & /*iconPosition*/ 8192) textinput_changes.iconPosition = /*iconPosition*/ ctx[13];
			if (dirty[0] & /*label*/ 8) textinput_changes.label = /*label*/ ctx[3];
			if (dirty[0] & /*style*/ 16) textinput_changes.style = /*style*/ ctx[4];
			if (dirty[0] & /*className*/ 32) textinput_changes.className = /*className*/ ctx[5];
			if (dirty[0] & /*textIfInvalid*/ 64) textinput_changes.textIfInvalid = /*textIfInvalid*/ ctx[6];
			if (dirty[0] & /*textIfValid*/ 128) textinput_changes.textIfValid = /*textIfValid*/ ctx[7];
			if (dirty[0] & /*helperText*/ 256) textinput_changes.helperText = /*helperText*/ ctx[8];
			if (dirty[0] & /*optional*/ 512) textinput_changes.optional = /*optional*/ ctx[9];
			if (dirty[0] & /*disabled*/ 1024) textinput_changes.disabled = /*disabled*/ ctx[10];
			if (dirty[0] & /*tooltip*/ 2048) textinput_changes.tooltip = /*tooltip*/ ctx[11];
			if (dirty[0] & /*localeValue*/ 16384) textinput_changes.value = /*localeValue*/ ctx[14];

			if (!updating_state && dirty[0] & /*state*/ 2) {
				updating_state = true;
				textinput_changes.state = /*state*/ ctx[1];
				add_flush_callback(() => updating_state = false);
			}

			if (!updating_ref && dirty[0] & /*ref*/ 1) {
				updating_ref = true;
				textinput_changes.ref = /*ref*/ ctx[0];
				add_flush_callback(() => updating_ref = false);
			}

			textinput.$set(textinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(textinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(textinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(textinput, detaching);
		}
	};
}

function instance$b($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { decimalPlaces = 2 } = $$props;
	let { inhibitDecimalSeparatorKey = false } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { min = undefined } = $$props;
	let { max = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { iconPosition = "left" } = $$props;
	let { state = "initial" } = $$props;
	const dispatch = createEventDispatcher();
	let localeValue = '';
	let decimalSeparator = Number(.1).toLocaleString().replace(/\d/g, '');
	let referenceValue = undefined;

	/** @type {string[]} */
	let digits;

	let external = true;

	function react() {
		if (!value) {
			$$invalidate(20, value = "");
		} else if (typeof value === "number") {
			$$invalidate(20, value = value.toString());
		} else if (typeof value === "string") {
			if (Number.isNaN(Number(value))) {
				throw new Error('invalid string format');
			}
		} else {
			$$invalidate(20, value = ""); // unable to convert
		}

		if (value !== "") {
			while (value[0] === '0') {
				$$invalidate(20, value = value.substring(1)); // trim leading 0s
			}

			if (value.includes('.') && value.length - value.indexOf('.') - 1 > decimalPlaces) {
				$$invalidate(20, value = value.substring(0, value.indexOf('.') + decimalPlaces + 1));
			}

			digits = [
				...value.replace('.', '').split(''),
				...new Array(decimalPlaces - (value.includes('.')
					? value.length - value.indexOf('.') - 1
					: 0)).fill('0')
			];
		} else {
			digits = [];
		}

		updateValue();

		if (external && referenceValue !== value) {
			referenceValue = value;
		}

		external = true;
	}

	function digitsToValue() {
		const displayDigits = [
			...new Array(Math.max(0, decimalPlaces + 1 - digits.length)).fill('0'),
			...digits
		];

		if (displayDigits.length - decimalPlaces < displayDigits.length) {
			displayDigits.splice(displayDigits.length - decimalPlaces, 0, '.');
		}

		return displayDigits.join('');
	}

	function updateValue() {
		$$invalidate(20, value = digitsToValue());

		$$invalidate(14, localeValue = Number(value).toLocaleString(undefined, {
			minimumFractionDigits: decimalPlaces,
			maximumFractionDigits: decimalPlaces
		}));

		updateState();
	}

	let clearBeforeInput = true;

	function handleFocus() {
		clearBeforeInput = true;
	}

	const passthroughKeys = ['Enter', 'Tab'];

	const allowedKeys = [
		'Backspace',
		'Space',
		'Delete',
		'Escape',
		decimalSeparator,
		'.',
		...new Array(10).fill(0).map((_, index) => index.toString())
	];

	function handleKey({ key, location }) {
		if (allowedKeys.includes(key)) {
			if (clearBeforeInput) {
				digits = [];
				clearBeforeInput = false;
			}

			switch (key) {
				case 'Backspace':
					digits.pop();
					break;
				case 'Delete':
				case 'Escape':
				case 'Space':
					digits = [];
					break;
				case decimalSeparator:
				case '.':
					if (!inhibitDecimalSeparatorKey) {
						digits.push(...new Array(decimalPlaces).fill('0'));
					}
					break;
				default:
					digits.push(key);
					if (Number(digitsToValue()).toFixed(decimalPlaces).slice(-1) !== key) {
						// Over maximum admitted value by the Number type
						digits.pop();
					}
					break;
			}

			while (digits[0] === '0') {
				digits.shift();
			}

			external = false;
			updateValue();
			setTimeout(() => ref.setSelectionRange(localeValue.length + 1, localeValue.length + 1), 1); // Evil virtual keyboards...
		}
	}

	/** @param {KeyboardEvent} e */
	function handleKeydown(e) {
		if (e.key !== "Unidentified" && !passthroughKeys.includes(e.key)) {
			e.preventDefault();
			e.stopPropagation();
			handleKey(e);
		} else if (e.key === 'Enter') {
			updateState();

			if (referenceValue !== value) {
				referenceValue = value;
				dispatch('change', value);
			}
		}
	}

	function handleInput(e) {
		e.preventDefault();
		e.stopPropagation();

		if (ref.value.length > value.length) {
			const key = ref.value.slice(-1);
			$$invalidate(0, ref.value = ref.value.slice(0, -1), ref);

			handleKey({
				key: key === ' ' ? 'Space' : key,
				location: 3
			});
		} else if (ref.value.length < value.length) {
			const delta = value.length - ref.value.length;

			for (let i = 0; i < delta; i++) {
				handleKey({ key: 'Backspace', location: 3 });
			}

			setTimeout(
				() => {
					// Evil virtual keyboards...
					ref.setSelectionRange(localeValue.length + 1, localeValue.length + 1);

					$$invalidate(0, ref.value = localeValue, ref);
				},
				1
			);
		}
	}

	function handleBlur() {
		if (referenceValue !== value) {
			referenceValue = value;
			dispatch('change', value);
		}
	}

	function updateState() {
		if (ref) {
			if (max !== undefined && Number(value) > max) {
				ref.setCustomValidity(textIfInvalid || `Value must be less than or equal to ${max}`);
			} else if (min !== undefined && Number(value) < min) {
				ref.setCustomValidity(textIfInvalid || `Value must be greater than or equal to ${min}`);
			} else {
				ref.setCustomValidity('');
			}
		}
	}

	onMount(() => {
		updateState();
	});

	function textinput_state_binding(value) {
		state = value;
		$$invalidate(1, state);
	}

	function textinput_ref_binding(value) {
		ref = value;
		$$invalidate(0, ref);
	}

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('decimalPlaces' in $$props) $$invalidate(21, decimalPlaces = $$props.decimalPlaces);
		if ('inhibitDecimalSeparatorKey' in $$props) $$invalidate(22, inhibitDecimalSeparatorKey = $$props.inhibitDecimalSeparatorKey);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('className' in $$props) $$invalidate(5, className = $$props.className);
		if ('textIfInvalid' in $$props) $$invalidate(6, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(7, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(8, helperText = $$props.helperText);
		if ('optional' in $$props) $$invalidate(9, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(20, value = $$props.value);
		if ('min' in $$props) $$invalidate(23, min = $$props.min);
		if ('max' in $$props) $$invalidate(24, max = $$props.max);
		if ('ref' in $$props) $$invalidate(0, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(10, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(11, tooltip = $$props.tooltip);
		if ('icon' in $$props) $$invalidate(12, icon = $$props.icon);
		if ('iconPosition' in $$props) $$invalidate(13, iconPosition = $$props.iconPosition);
		if ('state' in $$props) $$invalidate(1, state = $$props.state);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, decimalPlaces*/ 3145728) {
			(react());
		}
	};

	return [
		ref,
		state,
		id,
		label,
		style,
		className,
		textIfInvalid,
		textIfValid,
		helperText,
		optional,
		disabled,
		tooltip,
		icon,
		iconPosition,
		localeValue,
		handleFocus,
		handleKeydown,
		handleInput,
		handleBlur,
		updateState,
		value,
		decimalPlaces,
		inhibitDecimalSeparatorKey,
		min,
		max,
		textinput_state_binding,
		textinput_ref_binding,
		input_handler,
		blur_handler
	];
}

class FixedPointInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$b,
			create_fragment$b,
			safe_not_equal,
			{
				id: 2,
				decimalPlaces: 21,
				inhibitDecimalSeparatorKey: 22,
				label: 3,
				style: 4,
				className: 5,
				textIfInvalid: 6,
				textIfValid: 7,
				helperText: 8,
				optional: 9,
				value: 20,
				min: 23,
				max: 24,
				ref: 0,
				disabled: 10,
				tooltip: 11,
				icon: 12,
				iconPosition: 13,
				state: 1
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/MonthPicker.svelte generated by Svelte v4.2.19 */

function create_default_slot$8(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "week");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "class", "uk-input");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[25](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[26]),
					listen(input, "input", /*input_handler*/ ctx[21]),
					listen(input, "change", /*change_handler*/ ctx[22]),
					listen(input, "blur", /*blur_handler*/ ctx[23]),
					listen(input, "focus", /*focus_handler*/ ctx[24]),
					listen(input, "blur", /*blur_handler_1*/ ctx[27]),
					listen(input, "focus", /*focus_handler_1*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$a(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[19],
				optionalMarker: /*optionalMarker*/ ctx[20],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				className: /*className*/ ctx[6],
				style: /*style*/ ctx[5],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$8] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_changes = {};
			if (dirty & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty & /*requiredMarker*/ 524288) field_changes.requiredMarker = /*requiredMarker*/ ctx[19];
			if (dirty & /*optionalMarker*/ 1048576) field_changes.optionalMarker = /*optionalMarker*/ ctx[20];
			if (dirty & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty & /*$$scope, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, tooltip, optional, placeholder, disabled, ref, value, state*/ 537393295) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$a($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('requiredMarker' in $$props) $$invalidate(19, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(20, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class MonthPicker extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
			id: 3,
			label: 4,
			style: 5,
			className: 6,
			name: 7,
			textIfInvalid: 8,
			textIfValid: 9,
			helperText: 10,
			placeholder: 11,
			optional: 12,
			value: 0,
			ref: 1,
			disabled: 13,
			tooltip: 14,
			autocapitalize: 15,
			autocomplete: 16,
			autocorrect: 17,
			spellcheck: 18,
			requiredMarker: 19,
			optionalMarker: 20,
			state: 2
		});
	}
}

/* src/components/form/NumberInput.svelte generated by Svelte v4.2.19 */

function create_if_block_2(ctx) {
	let if_block_anchor;
	let if_block = /*icon*/ ctx[18] && create_if_block_3(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[18]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_3(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (87:4) {#if icon}
function create_if_block_3(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-form-icon");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[18]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 262144 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[18])) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (114:2) {#if iconPosition === 'right'}
function create_if_block$3(ctx) {
	let if_block_anchor;
	let if_block = /*icon*/ ctx[18] && create_if_block_1(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (/*icon*/ ctx[18]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

// (115:4) {#if icon}
function create_if_block_1(ctx) {
	let span;
	let span_uk_icon_value;

	return {
		c() {
			span = element("span");
			attr(span, "class", "uk-form-icon right svelte-1whx3ya");
			attr(span, "uk-icon", span_uk_icon_value = "icon: " + /*icon*/ ctx[18]);
		},
		m(target, anchor) {
			insert(target, span, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*icon*/ 262144 && span_uk_icon_value !== (span_uk_icon_value = "icon: " + /*icon*/ ctx[18])) {
				attr(span, "uk-icon", span_uk_icon_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
			}
		}
	};
}

// (73:0) <Field   hasIcon={!!icon}   inputId={id}   {requiredMarker}   {optionalMarker}   {label}   {state}   {className}   {style}   {textIfInvalid}   {textIfValid}   {helperText}   {optional}>
function create_default_slot$7(ctx) {
	let t0;
	let input;
	let input_required_value;
	let t1;
	let if_block1_anchor;
	let mounted;
	let dispose;
	let if_block0 = /*iconPosition*/ ctx[19] === 'left' && create_if_block_2(ctx);
	let if_block1 = /*iconPosition*/ ctx[19] === 'right' && create_if_block$3(ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space();
			input = element("input");
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[20]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[21]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[22]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[23]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			attr(input, "min", /*min*/ ctx[13]);
			attr(input, "max", /*max*/ ctx[14]);
			attr(input, "step", /*step*/ ctx[15]);
			input.disabled = /*disabled*/ ctx[16];
			attr(input, "uk-tooltip", /*tooltip*/ ctx[17]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "number");
			attr(input, "class", "uk-input svelte-1whx3ya");
			toggle_class(input, "paddingRight", /*iconPosition*/ ctx[19] === 'right');
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, input, anchor);
			/*input_binding*/ ctx[28](input);
			set_input_value(input, /*value*/ ctx[0]);
			insert(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert(target, if_block1_anchor, anchor);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[29]),
					listen(input, "input", /*input_handler*/ ctx[26]),
					listen(input, "change", /*change_handler*/ ctx[27]),
					listen(input, "blur", /*blur_handler*/ ctx[30]),
					listen(input, "focus", /*focus_handler*/ ctx[31])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*iconPosition*/ ctx[19] === 'left') {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_2(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*autocapitalize*/ 1048576) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[20]);
			}

			if (dirty[0] & /*autocomplete*/ 2097152) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[21]);
			}

			if (dirty[0] & /*autocorrect*/ 4194304) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[22]);
			}

			if (dirty[0] & /*spellcheck*/ 8388608) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[23]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*min*/ 8192) {
				attr(input, "min", /*min*/ ctx[13]);
			}

			if (dirty[0] & /*max*/ 16384) {
				attr(input, "max", /*max*/ ctx[14]);
			}

			if (dirty[0] & /*step*/ 32768) {
				attr(input, "step", /*step*/ ctx[15]);
			}

			if (dirty[0] & /*disabled*/ 65536) {
				input.disabled = /*disabled*/ ctx[16];
			}

			if (dirty[0] & /*tooltip*/ 131072) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[17]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*value*/ 1 && to_number(input.value) !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*iconPosition*/ 524288) {
				toggle_class(input, "paddingRight", /*iconPosition*/ ctx[19] === 'right');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}

			if (/*iconPosition*/ ctx[19] === 'right') {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block$3(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(input);
				detach(t1);
				detach(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			/*input_binding*/ ctx[28](null);
			if (if_block1) if_block1.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$9(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				hasIcon: !!/*icon*/ ctx[18],
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[24],
				optionalMarker: /*optionalMarker*/ ctx[25],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				className: /*className*/ ctx[6],
				style: /*style*/ ctx[5],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$7] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*icon*/ 262144) field_changes.hasIcon = !!/*icon*/ ctx[18];
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 16777216) field_changes.requiredMarker = /*requiredMarker*/ ctx[24];
			if (dirty[0] & /*optionalMarker*/ 33554432) field_changes.optionalMarker = /*optionalMarker*/ ctx[25];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty[0] & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty[0] & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*icon, iconPosition, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, min, max, step, disabled, tooltip, optional, placeholder, ref, value, state*/ 16775311 | dirty[1] & /*$$scope*/ 2) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$9($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { min = undefined } = $$props;
	let { max = undefined } = $$props;
	let { step = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { icon = undefined } = $$props;
	let { iconPosition = "left" } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = to_number(this.value);
		$$invalidate(0, value);
	}

	const blur_handler = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler = () => ($$invalidate(2, state = 'initial'), ref.select());

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('min' in $$props) $$invalidate(13, min = $$props.min);
		if ('max' in $$props) $$invalidate(14, max = $$props.max);
		if ('step' in $$props) $$invalidate(15, step = $$props.step);
		if ('disabled' in $$props) $$invalidate(16, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(17, tooltip = $$props.tooltip);
		if ('icon' in $$props) $$invalidate(18, icon = $$props.icon);
		if ('iconPosition' in $$props) $$invalidate(19, iconPosition = $$props.iconPosition);
		if ('autocapitalize' in $$props) $$invalidate(20, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(21, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(22, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(23, spellcheck = $$props.spellcheck);
		if ('requiredMarker' in $$props) $$invalidate(24, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(25, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		min,
		max,
		step,
		disabled,
		tooltip,
		icon,
		iconPosition,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		input_binding,
		input_input_handler,
		blur_handler,
		focus_handler
	];
}

class NumberInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$9,
			create_fragment$9,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				style: 5,
				className: 6,
				name: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 1,
				min: 13,
				max: 14,
				step: 15,
				disabled: 16,
				tooltip: 17,
				icon: 18,
				iconPosition: 19,
				autocapitalize: 20,
				autocomplete: 21,
				autocorrect: 22,
				spellcheck: 23,
				requiredMarker: 24,
				optionalMarker: 25,
				state: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/PasswordInput.svelte generated by Svelte v4.2.19 */

function create_default_slot$6(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "minlength", /*minlength*/ ctx[19]);
			attr(input, "maxlength", /*maxlength*/ ctx[20]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "password");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			attr(input, "class", "uk-input");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[27](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[28]),
					listen(input, "input", /*input_handler*/ ctx[23]),
					listen(input, "change", /*change_handler*/ ctx[24]),
					listen(input, "blur", /*blur_handler*/ ctx[25]),
					listen(input, "focus", /*focus_handler*/ ctx[26]),
					listen(input, "blur", /*blur_handler_1*/ ctx[29]),
					listen(input, "focus", /*focus_handler_1*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*minlength*/ 524288) {
				attr(input, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*maxlength*/ 1048576) {
				attr(input, "maxlength", /*maxlength*/ ctx[20]);
			}

			if (dirty[0] & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty[0] & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty[0] & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty[0] & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[27](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$8(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[21],
				optionalMarker: /*optionalMarker*/ ctx[22],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				style: /*style*/ ctx[5],
				className: /*className*/ ctx[6],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$6] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 2097152) field_changes.requiredMarker = /*requiredMarker*/ ctx[21];
			if (dirty[0] & /*optionalMarker*/ 4194304) field_changes.optionalMarker = /*optionalMarker*/ ctx[22];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty[0] & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty[0] & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*minlength, maxlength, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, optional, placeholder, disabled, tooltip, ref, value, state*/ 2095247 | dirty[1] & /*$$scope*/ 1) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$8($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = "off" } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = "off" } = $$props;
	let { spellcheck = "off" } = $$props;
	let { minlength = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('minlength' in $$props) $$invalidate(19, minlength = $$props.minlength);
		if ('maxlength' in $$props) $$invalidate(20, maxlength = $$props.maxlength);
		if ('requiredMarker' in $$props) $$invalidate(21, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(22, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		minlength,
		maxlength,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class PasswordInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$8,
			create_fragment$8,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				style: 5,
				className: 6,
				name: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 1,
				disabled: 13,
				tooltip: 14,
				autocapitalize: 15,
				autocomplete: 16,
				autocorrect: 17,
				spellcheck: 18,
				minlength: 19,
				maxlength: 20,
				requiredMarker: 21,
				optionalMarker: 22,
				state: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/PasswordInputAlt.svelte generated by Svelte v4.2.19 */

function create_else_block(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "minlength", /*minlength*/ ctx[19]);
			attr(input, "maxlength", /*maxlength*/ ctx[20]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "text");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			attr(input, "class", "uk-input svelte-1whx3ya");
			toggle_class(input, "paddingRight", true);
			toggle_class(input, "uk-form-danger", /*state*/ ctx[1] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[1] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding_1*/ ctx[38](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_1*/ ctx[39]),
					listen(input, "input", /*input_handler_1*/ ctx[30]),
					listen(input, "change", /*change_handler_1*/ ctx[31]),
					listen(input, "blur", /*blur_handler_1*/ ctx[32]),
					listen(input, "focus", /*focus_handler_1*/ ctx[33]),
					listen(input, "blur", /*blur_handler_3*/ ctx[40]),
					listen(input, "focus", /*focus_handler_3*/ ctx[41])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*minlength*/ 524288) {
				attr(input, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*maxlength*/ 1048576) {
				attr(input, "maxlength", /*maxlength*/ ctx[20]);
			}

			if (dirty[0] & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty[0] & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty[0] & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty[0] & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*state*/ 2) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[1] === 'invalid');
			}

			if (dirty[0] & /*state*/ 2) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[1] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding_1*/ ctx[38](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (86:2) {#if !show}
function create_if_block$2(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "minlength", /*minlength*/ ctx[19]);
			attr(input, "maxlength", /*maxlength*/ ctx[20]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "password");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			attr(input, "class", "uk-input svelte-1whx3ya");
			toggle_class(input, "paddingRight", true);
			toggle_class(input, "uk-form-danger", /*state*/ ctx[1] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[1] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[34](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[35]),
					listen(input, "input", /*input_handler*/ ctx[26]),
					listen(input, "change", /*change_handler*/ ctx[27]),
					listen(input, "blur", /*blur_handler*/ ctx[28]),
					listen(input, "focus", /*focus_handler*/ ctx[29]),
					listen(input, "blur", /*blur_handler_2*/ ctx[36]),
					listen(input, "focus", /*focus_handler_2*/ ctx[37])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*minlength*/ 524288) {
				attr(input, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*maxlength*/ 1048576) {
				attr(input, "maxlength", /*maxlength*/ ctx[20]);
			}

			if (dirty[0] & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty[0] & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty[0] & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty[0] & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*state*/ 2) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[1] === 'invalid');
			}

			if (dirty[0] & /*state*/ 2) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[1] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[34](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (73:0) <Field   hasIcon={true}   inputId={id}   {requiredMarker}   {optionalMarker}   {label}   {state}   {style}   {className}   {textIfInvalid}   {textIfValid}   {helperText}   {optional}>
function create_default_slot$5(ctx) {
	let t0;
	let a;
	let t1;
	let a_uk_icon_value;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (!/*show*/ ctx[2]) return create_if_block$2;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	return {
		c() {
			if_block.c();
			t0 = space();
			a = element("a");
			t1 = text("");
			attr(a, "role", "button");
			attr(a, "tabindex", "0");
			attr(a, "class", "uk-form-icon right svelte-1whx3ya");
			attr(a, "uk-icon", a_uk_icon_value = "icon: " + (/*show*/ ctx[2] ? 'unlock' : 'lock'));
		},
		m(target, anchor) {
			if_block.m(target, anchor);
			insert(target, t0, anchor);
			insert(target, a, anchor);
			append(a, t1);

			if (!mounted) {
				dispose = [
					listen(a, "keyup", /*keyup_handler*/ ctx[42]),
					listen(a, "click", /*click_handler*/ ctx[43])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(t0.parentNode, t0);
				}
			}

			if (dirty[0] & /*show*/ 4 && a_uk_icon_value !== (a_uk_icon_value = "icon: " + (/*show*/ ctx[2] ? 'unlock' : 'lock'))) {
				attr(a, "uk-icon", a_uk_icon_value);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(t0);
				detach(a);
			}

			if_block.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$7(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				hasIcon: true,
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[21],
				optionalMarker: /*optionalMarker*/ ctx[22],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[1],
				style: /*style*/ ctx[5],
				className: /*className*/ ctx[6],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$5] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 2097152) field_changes.requiredMarker = /*requiredMarker*/ ctx[21];
			if (dirty[0] & /*optionalMarker*/ 4194304) field_changes.optionalMarker = /*optionalMarker*/ ctx[22];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 2) field_changes.state = /*state*/ ctx[1];
			if (dirty[0] & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty[0] & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*show, minlength, maxlength, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, optional, placeholder, disabled, tooltip, refPassword, value, state, refText*/ 27261071 | dirty[1] & /*$$scope*/ 8192) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$7($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = "off" } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = "off" } = $$props;
	let { spellcheck = "off" } = $$props;
	let { minlength = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let refPassword;
	let refText;
	let { state = "initial" } = $$props;
	let { show = false } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refPassword = $$value;
			$$invalidate(23, refPassword);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_2 = () => $$invalidate(1, state = refPassword.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_2 = () => $$invalidate(1, state = 'initial');

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			refText = $$value;
			$$invalidate(24, refText);
		});
	}

	function input_input_handler_1() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_3 = () => $$invalidate(1, state = refText.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_3 = () => $$invalidate(1, state = 'initial');
	const keyup_handler = e => ['Enter'].includes(e.code) && $$invalidate(2, show = !show);
	const click_handler = () => $$invalidate(2, show = !show);

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(25, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('minlength' in $$props) $$invalidate(19, minlength = $$props.minlength);
		if ('maxlength' in $$props) $$invalidate(20, maxlength = $$props.maxlength);
		if ('requiredMarker' in $$props) $$invalidate(21, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(22, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(1, state = $$props.state);
		if ('show' in $$props) $$invalidate(2, show = $$props.show);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*refPassword, refText*/ 25165824) {
			$$invalidate(25, ref = refPassword || refText);
		}
	};

	return [
		value,
		state,
		show,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		minlength,
		maxlength,
		requiredMarker,
		optionalMarker,
		refPassword,
		refText,
		ref,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_handler_1,
		change_handler_1,
		blur_handler_1,
		focus_handler_1,
		input_binding,
		input_input_handler,
		blur_handler_2,
		focus_handler_2,
		input_binding_1,
		input_input_handler_1,
		blur_handler_3,
		focus_handler_3,
		keyup_handler,
		click_handler
	];
}

class PasswordInputAlt extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$7,
			create_fragment$7,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				style: 5,
				className: 6,
				name: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 25,
				disabled: 13,
				tooltip: 14,
				autocapitalize: 15,
				autocomplete: 16,
				autocorrect: 17,
				spellcheck: 18,
				minlength: 19,
				maxlength: 20,
				requiredMarker: 21,
				optionalMarker: 22,
				state: 1,
				show: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/PercentageInput.svelte generated by Svelte v4.2.19 */

function create_fragment$6(ctx) {
	let numberinput;
	let updating_ref;
	let current;

	function numberinput_ref_binding(value) {
		/*numberinput_ref_binding*/ ctx[18](value);
	}

	let numberinput_props = {
		autocapitalize: /*autocapitalize*/ ctx[14],
		autocomplete: /*autocomplete*/ ctx[15],
		autocorrect: /*autocorrect*/ ctx[16],
		spellcheck: /*spellcheck*/ ctx[17],
		tooltip: /*tooltip*/ ctx[12],
		disabled: /*disabled*/ ctx[11],
		id: /*id*/ ctx[2],
		min: /*allowNegative*/ ctx[10] ? -100 : 0,
		max: 100,
		step: /*step*/ ctx[13],
		icon: "percentage",
		iconPosition: 'right',
		label: /*label*/ ctx[3],
		style: /*style*/ ctx[4],
		className: /*className*/ ctx[5],
		textIfInvalid: /*textIfInvalid*/ ctx[6],
		textIfValid: /*textIfValid*/ ctx[7],
		helperText: /*helperText*/ ctx[8],
		optional: /*optional*/ ctx[9],
		value: /*value*/ ctx[0]
	};

	if (/*ref*/ ctx[1] !== void 0) {
		numberinput_props.ref = /*ref*/ ctx[1];
	}

	numberinput = new NumberInput({ props: numberinput_props });
	binding_callbacks.push(() => bind(numberinput, 'ref', numberinput_ref_binding));
	numberinput.$on("change", /*change_handler*/ ctx[19]);

	return {
		c() {
			create_component(numberinput.$$.fragment);
		},
		m(target, anchor) {
			mount_component(numberinput, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const numberinput_changes = {};
			if (dirty & /*autocapitalize*/ 16384) numberinput_changes.autocapitalize = /*autocapitalize*/ ctx[14];
			if (dirty & /*autocomplete*/ 32768) numberinput_changes.autocomplete = /*autocomplete*/ ctx[15];
			if (dirty & /*autocorrect*/ 65536) numberinput_changes.autocorrect = /*autocorrect*/ ctx[16];
			if (dirty & /*spellcheck*/ 131072) numberinput_changes.spellcheck = /*spellcheck*/ ctx[17];
			if (dirty & /*tooltip*/ 4096) numberinput_changes.tooltip = /*tooltip*/ ctx[12];
			if (dirty & /*disabled*/ 2048) numberinput_changes.disabled = /*disabled*/ ctx[11];
			if (dirty & /*id*/ 4) numberinput_changes.id = /*id*/ ctx[2];
			if (dirty & /*allowNegative*/ 1024) numberinput_changes.min = /*allowNegative*/ ctx[10] ? -100 : 0;
			if (dirty & /*step*/ 8192) numberinput_changes.step = /*step*/ ctx[13];
			if (dirty & /*label*/ 8) numberinput_changes.label = /*label*/ ctx[3];
			if (dirty & /*style*/ 16) numberinput_changes.style = /*style*/ ctx[4];
			if (dirty & /*className*/ 32) numberinput_changes.className = /*className*/ ctx[5];
			if (dirty & /*textIfInvalid*/ 64) numberinput_changes.textIfInvalid = /*textIfInvalid*/ ctx[6];
			if (dirty & /*textIfValid*/ 128) numberinput_changes.textIfValid = /*textIfValid*/ ctx[7];
			if (dirty & /*helperText*/ 256) numberinput_changes.helperText = /*helperText*/ ctx[8];
			if (dirty & /*optional*/ 512) numberinput_changes.optional = /*optional*/ ctx[9];
			if (dirty & /*value*/ 1) numberinput_changes.value = /*value*/ ctx[0];

			if (!updating_ref && dirty & /*ref*/ 2) {
				updating_ref = true;
				numberinput_changes.ref = /*ref*/ ctx[1];
				add_flush_callback(() => updating_ref = false);
			}

			numberinput.$set(numberinput_changes);
		},
		i(local) {
			if (current) return;
			transition_in(numberinput.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(numberinput.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(numberinput, detaching);
		}
	};
}

function instance$6($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { allowNegative = false } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { step = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;

	function numberinput_ref_binding(value) {
		ref = value;
		$$invalidate(1, ref);
	}

	const change_handler = () => $$invalidate(0, value = ref.value.replace(',', '.'));

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
		if ('className' in $$props) $$invalidate(5, className = $$props.className);
		if ('textIfInvalid' in $$props) $$invalidate(6, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(7, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(8, helperText = $$props.helperText);
		if ('optional' in $$props) $$invalidate(9, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('allowNegative' in $$props) $$invalidate(10, allowNegative = $$props.allowNegative);
		if ('disabled' in $$props) $$invalidate(11, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(12, tooltip = $$props.tooltip);
		if ('step' in $$props) $$invalidate(13, step = $$props.step);
		if ('autocapitalize' in $$props) $$invalidate(14, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(15, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(16, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(17, spellcheck = $$props.spellcheck);
	};

	return [
		value,
		ref,
		id,
		label,
		style,
		className,
		textIfInvalid,
		textIfValid,
		helperText,
		optional,
		allowNegative,
		disabled,
		tooltip,
		step,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		numberinput_ref_binding,
		change_handler
	];
}

class PercentageInput extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
			id: 2,
			label: 3,
			style: 4,
			className: 5,
			textIfInvalid: 6,
			textIfValid: 7,
			helperText: 8,
			optional: 9,
			value: 0,
			ref: 1,
			allowNegative: 10,
			disabled: 11,
			tooltip: 12,
			step: 13,
			autocapitalize: 14,
			autocomplete: 15,
			autocorrect: 16,
			spellcheck: 17
		});
	}
}

/* src/components/form/Radio.svelte generated by Svelte v4.2.19 */

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i];
	child_ctx[24] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i];
	return child_ctx;
}

// (87:2) {#if label}
function create_if_block$1(ctx) {
	let label_1;
	let t0;
	let t1;
	let t2;

	return {
		c() {
			label_1 = element("label");
			t0 = text(/*label*/ ctx[3]);
			t1 = space();
			t2 = text(/*suffix*/ ctx[13]);
			attr(label_1, "class", "uk-form-label svelte-1k6kq2z");
			attr(label_1, "for", /*id*/ ctx[2]);
			toggle_class(label_1, "disabled", /*disabled*/ ctx[6]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			append(label_1, t0);
			append(label_1, t1);
			append(label_1, t2);
		},
		p(ctx, dirty) {
			if (dirty & /*label*/ 8) set_data(t0, /*label*/ ctx[3]);
			if (dirty & /*suffix*/ 8192) set_data(t2, /*suffix*/ ctx[13]);

			if (dirty & /*id*/ 4) {
				attr(label_1, "for", /*id*/ ctx[2]);
			}

			if (dirty & /*disabled*/ 64) {
				toggle_class(label_1, "disabled", /*disabled*/ ctx[6]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(label_1);
			}
		}
	};
}

// (101:4) {#each options as option (option)}
function create_each_block_1(key_1, ctx) {
	let div;
	let button;
	let t0_value = /*option*/ ctx[22].label + "";
	let t0;
	let button_disabled_value;
	let t1;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[19](/*option*/ ctx[22]);
	}

	return {
		key: key_1,
		first: null,
		c() {
			div = element("div");
			button = element("button");
			t0 = text(t0_value);
			t1 = space();
			button.disabled = button_disabled_value = /*disabled*/ ctx[6] || /*option*/ ctx[22].disabled;
			attr(button, "type", "button");
			toggle_class(button, "uk-text-nowrap", true);
			toggle_class(button, "uk-width-1-1", true);
			toggle_class(button, "uk-height-1-1", true);
			toggle_class(button, "custom-uk-active", /*option*/ ctx[22].value === /*value*/ ctx[0]);
			toggle_class(button, "uk-button-primary", /*option*/ ctx[22].value === /*value*/ ctx[0] && /*variant*/ ctx[11] === 'primary');
			toggle_class(button, "uk-button-secondary", /*option*/ ctx[22].value === /*value*/ ctx[0] && /*variant*/ ctx[11] === 'secondary');
			toggle_class(button, "uk-button-danger", /*option*/ ctx[22].value === /*value*/ ctx[0] && /*variant*/ ctx[11] === 'danger');
			toggle_class(button, "uk-button-default", /*option*/ ctx[22].value !== /*value*/ ctx[0]);
			toggle_class(button, "uk-button-small", /*size*/ ctx[9] === 'small');
			toggle_class(button, "uk-button-large", /*size*/ ctx[9] === 'large');
			toggle_class(button, "uk-button", true);
			attr(div, "class", "uk-flex-1");
			this.first = div;
		},
		m(target, anchor) {
			insert(target, div, anchor);
			append(div, button);
			append(button, t0);
			append(div, t1);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*options*/ 32 && t0_value !== (t0_value = /*option*/ ctx[22].label + "")) set_data(t0, t0_value);

			if (dirty & /*disabled, options*/ 96 && button_disabled_value !== (button_disabled_value = /*disabled*/ ctx[6] || /*option*/ ctx[22].disabled)) {
				button.disabled = button_disabled_value;
			}

			if (dirty & /*options, value*/ 33) {
				toggle_class(button, "custom-uk-active", /*option*/ ctx[22].value === /*value*/ ctx[0]);
			}

			if (dirty & /*options, value, variant*/ 2081) {
				toggle_class(button, "uk-button-primary", /*option*/ ctx[22].value === /*value*/ ctx[0] && /*variant*/ ctx[11] === 'primary');
			}

			if (dirty & /*options, value, variant*/ 2081) {
				toggle_class(button, "uk-button-secondary", /*option*/ ctx[22].value === /*value*/ ctx[0] && /*variant*/ ctx[11] === 'secondary');
			}

			if (dirty & /*options, value, variant*/ 2081) {
				toggle_class(button, "uk-button-danger", /*option*/ ctx[22].value === /*value*/ ctx[0] && /*variant*/ ctx[11] === 'danger');
			}

			if (dirty & /*options, value*/ 33) {
				toggle_class(button, "uk-button-default", /*option*/ ctx[22].value !== /*value*/ ctx[0]);
			}

			if (dirty & /*size*/ 512) {
				toggle_class(button, "uk-button-small", /*size*/ ctx[9] === 'small');
			}

			if (dirty & /*size*/ 512) {
				toggle_class(button, "uk-button-large", /*size*/ ctx[9] === 'large');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			mounted = false;
			dispose();
		}
	};
}

// (130:4) {#each options as option, i (option)}
function create_each_block$1(key_1, ctx) {
	let option_1;
	let t0_value = /*option*/ ctx[22].label + "";
	let t0;
	let t1;
	let option_1_selected_value;
	let option_1_value_value;
	let option_1_disabled_value;

	return {
		key: key_1,
		first: null,
		c() {
			option_1 = element("option");
			t0 = text(t0_value);
			t1 = space();
			option_1.selected = option_1_selected_value = /*option*/ ctx[22].value === /*value*/ ctx[0];
			option_1.__value = option_1_value_value = /*i*/ ctx[24];
			set_input_value(option_1, option_1.__value);
			option_1.disabled = option_1_disabled_value = /*option*/ ctx[22].disabled || false;
			this.first = option_1;
		},
		m(target, anchor) {
			insert(target, option_1, anchor);
			append(option_1, t0);
			append(option_1, t1);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*options*/ 32 && t0_value !== (t0_value = /*option*/ ctx[22].label + "")) set_data(t0, t0_value);

			if (dirty & /*options, value*/ 33 && option_1_selected_value !== (option_1_selected_value = /*option*/ ctx[22].value === /*value*/ ctx[0])) {
				option_1.selected = option_1_selected_value;
			}

			if (dirty & /*options*/ 32 && option_1_value_value !== (option_1_value_value = /*i*/ ctx[24])) {
				option_1.__value = option_1_value_value;
				set_input_value(option_1, option_1.__value);
			}

			if (dirty & /*options*/ 32 && option_1_disabled_value !== (option_1_disabled_value = /*option*/ ctx[22].disabled || false)) {
				option_1.disabled = option_1_disabled_value;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(option_1);
			}
		}
	};
}

function create_fragment$5(ctx) {
	let div1;
	let t0;
	let div0;
	let each_blocks_1 = [];
	let each0_lookup = new Map();
	let t1;
	let select;
	let option_1;
	let each_blocks = [];
	let each1_lookup = new Map();
	let select_required_value;
	let div1_class_value;
	let if_block = /*label*/ ctx[3] && create_if_block$1(ctx);
	let each_value_1 = ensure_array_like(/*options*/ ctx[5]);
	const get_key = ctx => /*option*/ ctx[22];

	for (let i = 0; i < each_value_1.length; i += 1) {
		let child_ctx = get_each_context_1(ctx, each_value_1, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_1[i] = create_each_block_1(key, child_ctx));
	}

	let each_value = ensure_array_like(/*options*/ ctx[5]);
	const get_key_1 = ctx => /*option*/ ctx[22];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context$1(ctx, each_value, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
	}

	return {
		c() {
			div1 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div0 = element("div");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			t1 = space();
			select = element("select");
			option_1 = element("option");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "id", /*id*/ ctx[2]);
			attr(div0, "uk-tooltip", /*tooltip*/ ctx[8]);
			attr(div0, "class", "svelte-1k6kq2z");
			toggle_class(div0, "disabled", /*disabled*/ ctx[6]);
			toggle_class(div0, "uk-flex", true);
			toggle_class(div0, "uk-width-1-1", true);
			toggle_class(div0, "uk-flex-wrap", true);
			option_1.selected = true;
			attr(option_1, "disaled", "");
			option_1.__value = "";
			set_input_value(option_1, option_1.__value);
			attr(select, "tabindex", "-1");
			select.required = select_required_value = !/*optional*/ ctx[7];
			select.disabled = /*disabled*/ ctx[6];
			attr(select, "name", /*name*/ ctx[4]);
			attr(select, "class", "svelte-1k6kq2z");
			attr(div1, "style", /*style*/ ctx[12]);
			attr(div1, "class", div1_class_value = "" + (null_to_empty(/*className*/ ctx[10]) + " svelte-1k6kq2z"));
			toggle_class(div1, "uk-margin-bottom", true);
			toggle_class(div1, "custom-uk-radio-wrapper", true);
			toggle_class(div1, "radio-wrapper", true);
		},
		m(target, anchor) {
			insert(target, div1, anchor);
			if (if_block) if_block.m(div1, null);
			append(div1, t0);
			append(div1, div0);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(div0, null);
				}
			}

			/*div0_binding*/ ctx[20](div0);
			append(div1, t1);
			append(div1, select);
			append(select, option_1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(select, null);
				}
			}
		},
		p(ctx, [dirty]) {
			if (/*label*/ ctx[3]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(div1, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*disabled, options, value, variant, size, dispatch*/ 19041) {
				each_value_1 = ensure_array_like(/*options*/ ctx[5]);
				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, destroy_block, create_each_block_1, null, get_each_context_1);
			}

			if (dirty & /*id*/ 4) {
				attr(div0, "id", /*id*/ ctx[2]);
			}

			if (dirty & /*tooltip*/ 256) {
				attr(div0, "uk-tooltip", /*tooltip*/ ctx[8]);
			}

			if (dirty & /*disabled*/ 64) {
				toggle_class(div0, "disabled", /*disabled*/ ctx[6]);
			}

			if (dirty & /*options, value*/ 33) {
				each_value = ensure_array_like(/*options*/ ctx[5]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, select, destroy_block, create_each_block$1, null, get_each_context$1);
			}

			if (dirty & /*optional*/ 128 && select_required_value !== (select_required_value = !/*optional*/ ctx[7])) {
				select.required = select_required_value;
			}

			if (dirty & /*disabled*/ 64) {
				select.disabled = /*disabled*/ ctx[6];
			}

			if (dirty & /*name*/ 16) {
				attr(select, "name", /*name*/ ctx[4]);
			}

			if (dirty & /*style*/ 4096) {
				attr(div1, "style", /*style*/ ctx[12]);
			}

			if (dirty & /*className*/ 1024 && div1_class_value !== (div1_class_value = "" + (null_to_empty(/*className*/ ctx[10]) + " svelte-1k6kq2z"))) {
				attr(div1, "class", div1_class_value);
			}

			if (dirty & /*className*/ 1024) {
				toggle_class(div1, "uk-margin-bottom", true);
			}

			if (dirty & /*className*/ 1024) {
				toggle_class(div1, "custom-uk-radio-wrapper", true);
			}

			if (dirty & /*className*/ 1024) {
				toggle_class(div1, "radio-wrapper", true);
			}
		},
		i: noop$1,
		o: noop$1,
		d(detaching) {
			if (detaching) {
				detach(div1);
			}

			if (if_block) if_block.d();

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].d();
			}

			/*div0_binding*/ ctx[20](null);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}
		}
	};
}

function instance$5($$self, $$props, $$invalidate) {
	let $globalOptionalMarker;
	let $globalRequiredMarker;
	component_subscribe($$self, globalOptionalMarker, $$value => $$invalidate(17, $globalOptionalMarker = $$value));
	component_subscribe($$self, globalRequiredMarker, $$value => $$invalidate(18, $globalRequiredMarker = $$value));
	let { id = generateId() } = $$props;
	let { label = undefined } = $$props;
	let { name = undefined } = $$props;
	let { value = undefined } = $$props;
	let { options = [] } = $$props;
	let { disabled = false } = $$props;
	let { optional = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { ref = undefined } = $$props;
	let { size = undefined } = $$props;
	let { className = undefined } = $$props;
	let { variant = "primary" } = $$props;
	let { style = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let suffix = '';

	function updateLabelSuffix() {
		if (optional) {
			$$invalidate(13, suffix = typeof optionalMarker === 'string'
			? optionalMarker
			: $globalOptionalMarker);
		} else {
			$$invalidate(13, suffix = typeof requiredMarker === 'string'
			? requiredMarker
			: $globalRequiredMarker);
		}
	}

	const dispatch = createEventDispatcher();

	const click_handler = option => {
		if (!disabled && value !== option.value) {
			$$invalidate(0, value = option.value);
			dispatch('change', value);
		}
	};

	function div0_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(2, id = $$props.id);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('name' in $$props) $$invalidate(4, name = $$props.name);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('options' in $$props) $$invalidate(5, options = $$props.options);
		if ('disabled' in $$props) $$invalidate(6, disabled = $$props.disabled);
		if ('optional' in $$props) $$invalidate(7, optional = $$props.optional);
		if ('tooltip' in $$props) $$invalidate(8, tooltip = $$props.tooltip);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('size' in $$props) $$invalidate(9, size = $$props.size);
		if ('className' in $$props) $$invalidate(10, className = $$props.className);
		if ('variant' in $$props) $$invalidate(11, variant = $$props.variant);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
		if ('requiredMarker' in $$props) $$invalidate(15, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(16, optionalMarker = $$props.optionalMarker);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*optional, requiredMarker, optionalMarker, $globalRequiredMarker, $globalOptionalMarker*/ 491648) {
			(updateLabelSuffix());
		}
	};

	return [
		value,
		ref,
		id,
		label,
		name,
		options,
		disabled,
		optional,
		tooltip,
		size,
		className,
		variant,
		style,
		suffix,
		dispatch,
		requiredMarker,
		optionalMarker,
		$globalOptionalMarker,
		$globalRequiredMarker,
		click_handler,
		div0_binding
	];
}

class Radio extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
			id: 2,
			label: 3,
			name: 4,
			value: 0,
			options: 5,
			disabled: 6,
			optional: 7,
			tooltip: 8,
			ref: 1,
			size: 9,
			className: 10,
			variant: 11,
			style: 12,
			requiredMarker: 15,
			optionalMarker: 16
		});
	}
}

/* src/components/form/Select.svelte generated by Svelte v4.2.19 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[24] = list[i];
	child_ctx[26] = i;
	return child_ctx;
}

// (89:4) {#if placeholder}
function create_if_block(ctx) {
	let option_1;
	let t;

	return {
		c() {
			option_1 = element("option");
			t = text(/*placeholder*/ ctx[10]);
			option_1.__value = "";
			set_input_value(option_1, option_1.__value);
			option_1.disabled = true;
			option_1.selected = true;
		},
		m(target, anchor) {
			insert(target, option_1, anchor);
			append(option_1, t);
		},
		p(ctx, dirty) {
			if (dirty & /*placeholder*/ 1024) set_data(t, /*placeholder*/ ctx[10]);
		},
		d(detaching) {
			if (detaching) {
				detach(option_1);
			}
		}
	};
}

// (92:4) {#each options as option, i (option)}
function create_each_block(key_1, ctx) {
	let option_1;
	let t0_value = /*option*/ ctx[24].label + "";
	let t0;
	let t1;
	let option_1_selected_value;
	let option_1_value_value;
	let option_1_disabled_value;

	return {
		key: key_1,
		first: null,
		c() {
			option_1 = element("option");
			t0 = text(t0_value);
			t1 = space();
			option_1.selected = option_1_selected_value = /*option*/ ctx[24].value === /*value*/ ctx[0];
			option_1.__value = option_1_value_value = /*i*/ ctx[26];
			set_input_value(option_1, option_1.__value);
			option_1.disabled = option_1_disabled_value = /*option*/ ctx[24].disabled || false;
			this.first = option_1;
		},
		m(target, anchor) {
			insert(target, option_1, anchor);
			append(option_1, t0);
			append(option_1, t1);
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*options*/ 4096 && t0_value !== (t0_value = /*option*/ ctx[24].label + "")) set_data(t0, t0_value);

			if (dirty & /*options, value*/ 4097 && option_1_selected_value !== (option_1_selected_value = /*option*/ ctx[24].value === /*value*/ ctx[0])) {
				option_1.selected = option_1_selected_value;
			}

			if (dirty & /*options*/ 4096 && option_1_value_value !== (option_1_value_value = /*i*/ ctx[26])) {
				option_1.__value = option_1_value_value;
				set_input_value(option_1, option_1.__value);
			}

			if (dirty & /*options*/ 4096 && option_1_disabled_value !== (option_1_disabled_value = /*option*/ ctx[24].disabled || false)) {
				option_1.disabled = option_1_disabled_value;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(option_1);
			}
		}
	};
}

// (62:0) <Field   inputId={id}   {requiredMarker}   {optionalMarker}   {label}   {state}   {className}   {style}   {textIfInvalid}   {textIfValid}   {helperText}   {optional}>
function create_default_slot$4(ctx) {
	let select;
	let if_block_anchor;
	let each_blocks = [];
	let each_1_lookup = new Map();
	let select_required_value;
	let mounted;
	let dispose;
	let if_block = /*placeholder*/ ctx[10] && create_if_block(ctx);
	let each_value = ensure_array_like(/*options*/ ctx[12]);
	const get_key = ctx => /*option*/ ctx[24];

	for (let i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c() {
			select = element("select");
			if (if_block) if_block.c();
			if_block_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			select.required = select_required_value = !/*optional*/ ctx[11];
			attr(select, "class", "uk-select");
			select.disabled = /*disabled*/ ctx[13];
			attr(select, "uk-tooltip", /*tooltip*/ ctx[14]);
		},
		m(target, anchor) {
			insert(target, select, anchor);
			if (if_block) if_block.m(select, null);
			append(select, if_block_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(select, null);
				}
			}

			/*select_binding*/ ctx[19](select);

			if (!mounted) {
				dispose = [
					listen(select, "change", /*change_handler*/ ctx[20]),
					listen(select, "blur", /*blur_handler*/ ctx[21]),
					listen(select, "focus", /*focus_handler*/ ctx[22])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*placeholder*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(select, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*options, value*/ 4097) {
				each_value = ensure_array_like(/*options*/ ctx[12]);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block, null, get_each_context);
			}

			if (dirty & /*optional*/ 2048 && select_required_value !== (select_required_value = !/*optional*/ ctx[11])) {
				select.required = select_required_value;
			}

			if (dirty & /*disabled*/ 8192) {
				select.disabled = /*disabled*/ ctx[13];
			}

			if (dirty & /*tooltip*/ 16384) {
				attr(select, "uk-tooltip", /*tooltip*/ ctx[14]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(select);
			}

			if (if_block) if_block.d();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			/*select_binding*/ ctx[19](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$4(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[15],
				optionalMarker: /*optionalMarker*/ ctx[16],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				className: /*className*/ ctx[6],
				style: /*style*/ ctx[5],
				textIfInvalid: /*textIfInvalid*/ ctx[7],
				textIfValid: /*textIfValid*/ ctx[8],
				helperText: /*helperText*/ ctx[9],
				optional: /*optional*/ ctx[11],
				$$slots: { default: [create_default_slot$4] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_changes = {};
			if (dirty & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty & /*requiredMarker*/ 32768) field_changes.requiredMarker = /*requiredMarker*/ ctx[15];
			if (dirty & /*optionalMarker*/ 65536) field_changes.optionalMarker = /*optionalMarker*/ ctx[16];
			if (dirty & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty & /*textIfInvalid*/ 128) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[7];
			if (dirty & /*textIfValid*/ 256) field_changes.textIfValid = /*textIfValid*/ ctx[8];
			if (dirty & /*helperText*/ 512) field_changes.helperText = /*helperText*/ ctx[9];
			if (dirty & /*optional*/ 2048) field_changes.optional = /*optional*/ ctx[11];

			if (dirty & /*$$scope, optional, disabled, tooltip, ref, value, options, referenceValue, state, placeholder*/ 134380551) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$4($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { options = [] } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;
	const dispatch = createEventDispatcher();
	let referenceValue;

	function handleValueChange() {
		$$invalidate(17, referenceValue = value);

		if (value === undefined && ref) {
			$$invalidate(1, ref.selectedIndex = 0, ref);
		}
	}

	function select_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
			$$invalidate(12, options);
		});
	}

	const change_handler = e => {
		$$invalidate(0, value = options[Number(e.target.value)].value);

		if (referenceValue !== value) {
			$$invalidate(17, referenceValue = value);
			dispatch('change', value);
		}
	};

	const blur_handler = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('textIfInvalid' in $$props) $$invalidate(7, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(8, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(9, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(10, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(11, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('options' in $$props) $$invalidate(12, options = $$props.options);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('requiredMarker' in $$props) $$invalidate(15, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(16, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			(handleValueChange());
		}
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		options,
		disabled,
		tooltip,
		requiredMarker,
		optionalMarker,
		referenceValue,
		dispatch,
		select_binding,
		change_handler,
		blur_handler,
		focus_handler
	];
}

class Select extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
			id: 3,
			label: 4,
			style: 5,
			className: 6,
			textIfInvalid: 7,
			textIfValid: 8,
			helperText: 9,
			placeholder: 10,
			optional: 11,
			value: 0,
			options: 12,
			ref: 1,
			disabled: 13,
			tooltip: 14,
			requiredMarker: 15,
			optionalMarker: 16,
			state: 2
		});
	}
}

/* src/components/form/TelInput.svelte generated by Svelte v4.2.19 */

function create_default_slot$3(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "minlength", /*minlength*/ ctx[19]);
			attr(input, "maxlength", /*maxlength*/ ctx[20]);
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "tel");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "class", "uk-input");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[27](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[28]),
					listen(input, "input", /*input_handler*/ ctx[23]),
					listen(input, "change", /*change_handler*/ ctx[24]),
					listen(input, "blur", /*blur_handler*/ ctx[25]),
					listen(input, "focus", /*focus_handler*/ ctx[26]),
					listen(input, "blur", /*blur_handler_1*/ ctx[29]),
					listen(input, "focus", /*focus_handler_1*/ ctx[30])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*minlength*/ 524288) {
				attr(input, "minlength", /*minlength*/ ctx[19]);
			}

			if (dirty[0] & /*maxlength*/ 1048576) {
				attr(input, "maxlength", /*maxlength*/ ctx[20]);
			}

			if (dirty[0] & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty[0] & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty[0] & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty[0] & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty[0] & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty[0] & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty[0] & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[27](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$3(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[21],
				optionalMarker: /*optionalMarker*/ ctx[22],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				style: /*style*/ ctx[5],
				className: /*className*/ ctx[6],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 2097152) field_changes.requiredMarker = /*requiredMarker*/ ctx[21];
			if (dirty[0] & /*optionalMarker*/ 4194304) field_changes.optionalMarker = /*optionalMarker*/ ctx[22];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty[0] & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty[0] & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*minlength, maxlength, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, tooltip, optional, placeholder, disabled, ref, value, state*/ 2095247 | dirty[1] & /*$$scope*/ 1) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$3($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('minlength' in $$props) $$invalidate(19, minlength = $$props.minlength);
		if ('maxlength' in $$props) $$invalidate(20, maxlength = $$props.maxlength);
		if ('requiredMarker' in $$props) $$invalidate(21, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(22, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		minlength,
		maxlength,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class TelInput extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				style: 5,
				className: 6,
				name: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 1,
				disabled: 13,
				tooltip: 14,
				autocapitalize: 15,
				autocomplete: 16,
				autocorrect: 17,
				spellcheck: 18,
				minlength: 19,
				maxlength: 20,
				requiredMarker: 21,
				optionalMarker: 22,
				state: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/Textarea.svelte generated by Svelte v4.2.19 */

function create_default_slot$2(ctx) {
	let textarea;
	let textarea_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			textarea = element("textarea");
			attr(textarea, "minlength", /*minlength*/ ctx[20]);
			attr(textarea, "maxlength", /*maxlength*/ ctx[21]);
			attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			attr(textarea, "autocomplete", /*autocomplete*/ ctx[17]);
			attr(textarea, "autocorrect", /*autocorrect*/ ctx[18]);
			attr(textarea, "spellcheck", /*spellcheck*/ ctx[19]);
			attr(textarea, "id", /*id*/ ctx[3]);
			attr(textarea, "name", /*name*/ ctx[5]);
			textarea.disabled = /*disabled*/ ctx[14];
			attr(textarea, "uk-tooltip", /*tooltip*/ ctx[15]);
			textarea.required = textarea_required_value = !/*optional*/ ctx[12];
			attr(textarea, "placeholder", /*placeholder*/ ctx[11]);
			attr(textarea, "rows", /*rows*/ ctx[13]);
			attr(textarea, "class", "uk-textarea");
			toggle_class(textarea, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(textarea, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, textarea, anchor);
			/*textarea_binding*/ ctx[28](textarea);
			set_input_value(textarea, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(textarea, "input", /*textarea_input_handler*/ ctx[29]),
					listen(textarea, "input", /*input_handler*/ ctx[24]),
					listen(textarea, "change", /*change_handler*/ ctx[25]),
					listen(textarea, "blur", /*blur_handler*/ ctx[26]),
					listen(textarea, "focus", /*focus_handler*/ ctx[27]),
					listen(textarea, "blur", /*blur_handler_1*/ ctx[30]),
					listen(textarea, "focus", /*focus_handler_1*/ ctx[31])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*minlength*/ 1048576) {
				attr(textarea, "minlength", /*minlength*/ ctx[20]);
			}

			if (dirty[0] & /*maxlength*/ 2097152) {
				attr(textarea, "maxlength", /*maxlength*/ ctx[21]);
			}

			if (dirty[0] & /*autocapitalize*/ 65536) {
				attr(textarea, "autocapitalize", /*autocapitalize*/ ctx[16]);
			}

			if (dirty[0] & /*autocomplete*/ 131072) {
				attr(textarea, "autocomplete", /*autocomplete*/ ctx[17]);
			}

			if (dirty[0] & /*autocorrect*/ 262144) {
				attr(textarea, "autocorrect", /*autocorrect*/ ctx[18]);
			}

			if (dirty[0] & /*spellcheck*/ 524288) {
				attr(textarea, "spellcheck", /*spellcheck*/ ctx[19]);
			}

			if (dirty[0] & /*id*/ 8) {
				attr(textarea, "id", /*id*/ ctx[3]);
			}

			if (dirty[0] & /*name*/ 32) {
				attr(textarea, "name", /*name*/ ctx[5]);
			}

			if (dirty[0] & /*disabled*/ 16384) {
				textarea.disabled = /*disabled*/ ctx[14];
			}

			if (dirty[0] & /*tooltip*/ 32768) {
				attr(textarea, "uk-tooltip", /*tooltip*/ ctx[15]);
			}

			if (dirty[0] & /*optional*/ 4096 && textarea_required_value !== (textarea_required_value = !/*optional*/ ctx[12])) {
				textarea.required = textarea_required_value;
			}

			if (dirty[0] & /*placeholder*/ 2048) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty[0] & /*rows*/ 8192) {
				attr(textarea, "rows", /*rows*/ ctx[13]);
			}

			if (dirty[0] & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(textarea, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty[0] & /*state*/ 4) {
				toggle_class(textarea, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(textarea);
			}

			/*textarea_binding*/ ctx[28](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$2(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[22],
				optionalMarker: /*optionalMarker*/ ctx[23],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				style: /*style*/ ctx[6],
				className: /*className*/ ctx[7],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const field_changes = {};
			if (dirty[0] & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty[0] & /*requiredMarker*/ 4194304) field_changes.requiredMarker = /*requiredMarker*/ ctx[22];
			if (dirty[0] & /*optionalMarker*/ 8388608) field_changes.optionalMarker = /*optionalMarker*/ ctx[23];
			if (dirty[0] & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty[0] & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty[0] & /*style*/ 64) field_changes.style = /*style*/ ctx[6];
			if (dirty[0] & /*className*/ 128) field_changes.className = /*className*/ ctx[7];
			if (dirty[0] & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty[0] & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty[0] & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty[0] & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty[0] & /*minlength, maxlength, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, disabled, tooltip, optional, placeholder, rows, ref, value, state*/ 4192303 | dirty[1] & /*$$scope*/ 2) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$2($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { name = undefined } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { rows = 5 } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { minlength = undefined } = $$props;
	let { maxlength = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('name' in $$props) $$invalidate(5, name = $$props.name);
		if ('style' in $$props) $$invalidate(6, style = $$props.style);
		if ('className' in $$props) $$invalidate(7, className = $$props.className);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('rows' in $$props) $$invalidate(13, rows = $$props.rows);
		if ('disabled' in $$props) $$invalidate(14, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(15, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(16, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(17, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(18, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(19, spellcheck = $$props.spellcheck);
		if ('minlength' in $$props) $$invalidate(20, minlength = $$props.minlength);
		if ('maxlength' in $$props) $$invalidate(21, maxlength = $$props.maxlength);
		if ('requiredMarker' in $$props) $$invalidate(22, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(23, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		name,
		style,
		className,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		rows,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		minlength,
		maxlength,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		textarea_binding,
		textarea_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class Textarea extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance$2,
			create_fragment$2,
			safe_not_equal,
			{
				id: 3,
				label: 4,
				name: 5,
				style: 6,
				className: 7,
				textIfInvalid: 8,
				textIfValid: 9,
				helperText: 10,
				placeholder: 11,
				optional: 12,
				value: 0,
				ref: 1,
				rows: 13,
				disabled: 14,
				tooltip: 15,
				autocapitalize: 16,
				autocomplete: 17,
				autocorrect: 18,
				spellcheck: 19,
				minlength: 20,
				maxlength: 21,
				requiredMarker: 22,
				optionalMarker: 23,
				state: 2
			},
			null,
			[-1, -1]
		);
	}
}

/* src/components/form/TimePicker.svelte generated by Svelte v4.2.19 */

function create_default_slot$1(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "time");
			attr(input, "class", "uk-input");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[25](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[26]),
					listen(input, "input", /*input_handler*/ ctx[21]),
					listen(input, "change", /*change_handler*/ ctx[22]),
					listen(input, "blur", /*blur_handler*/ ctx[23]),
					listen(input, "focus", /*focus_handler*/ ctx[24]),
					listen(input, "blur", /*blur_handler_1*/ ctx[27]),
					listen(input, "focus", /*focus_handler_1*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment$1(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[19],
				optionalMarker: /*optionalMarker*/ ctx[20],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				style: /*style*/ ctx[5],
				className: /*className*/ ctx[6],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_changes = {};
			if (dirty & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty & /*requiredMarker*/ 524288) field_changes.requiredMarker = /*requiredMarker*/ ctx[19];
			if (dirty & /*optionalMarker*/ 1048576) field_changes.optionalMarker = /*optionalMarker*/ ctx[20];
			if (dirty & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty & /*$$scope, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, disabled, tooltip, optional, placeholder, ref, value, state*/ 537393295) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance$1($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('requiredMarker' in $$props) $$invalidate(19, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(20, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class TimePicker extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			id: 3,
			label: 4,
			style: 5,
			className: 6,
			name: 7,
			textIfInvalid: 8,
			textIfValid: 9,
			helperText: 10,
			placeholder: 11,
			optional: 12,
			value: 0,
			ref: 1,
			disabled: 13,
			tooltip: 14,
			autocapitalize: 15,
			autocomplete: 16,
			autocorrect: 17,
			spellcheck: 18,
			requiredMarker: 19,
			optionalMarker: 20,
			state: 2
		});
	}
}

/* src/components/form/WeekPicker.svelte generated by Svelte v4.2.19 */

function create_default_slot(ctx) {
	let input;
	let input_required_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			attr(input, "id", /*id*/ ctx[3]);
			attr(input, "name", /*name*/ ctx[7]);
			attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			input.required = input_required_value = !/*optional*/ ctx[12];
			attr(input, "placeholder", /*placeholder*/ ctx[11]);
			attr(input, "type", "week");
			input.disabled = /*disabled*/ ctx[13];
			attr(input, "class", "uk-input");
			toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
		},
		m(target, anchor) {
			insert(target, input, anchor);
			/*input_binding*/ ctx[25](input);
			set_input_value(input, /*value*/ ctx[0]);

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[26]),
					listen(input, "input", /*input_handler*/ ctx[21]),
					listen(input, "change", /*change_handler*/ ctx[22]),
					listen(input, "blur", /*blur_handler*/ ctx[23]),
					listen(input, "focus", /*focus_handler*/ ctx[24]),
					listen(input, "blur", /*blur_handler_1*/ ctx[27]),
					listen(input, "focus", /*focus_handler_1*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*autocapitalize*/ 32768) {
				attr(input, "autocapitalize", /*autocapitalize*/ ctx[15]);
			}

			if (dirty & /*autocomplete*/ 65536) {
				attr(input, "autocomplete", /*autocomplete*/ ctx[16]);
			}

			if (dirty & /*autocorrect*/ 131072) {
				attr(input, "autocorrect", /*autocorrect*/ ctx[17]);
			}

			if (dirty & /*spellcheck*/ 262144) {
				attr(input, "spellcheck", /*spellcheck*/ ctx[18]);
			}

			if (dirty & /*id*/ 8) {
				attr(input, "id", /*id*/ ctx[3]);
			}

			if (dirty & /*name*/ 128) {
				attr(input, "name", /*name*/ ctx[7]);
			}

			if (dirty & /*tooltip*/ 16384) {
				attr(input, "uk-tooltip", /*tooltip*/ ctx[14]);
			}

			if (dirty & /*optional*/ 4096 && input_required_value !== (input_required_value = !/*optional*/ ctx[12])) {
				input.required = input_required_value;
			}

			if (dirty & /*placeholder*/ 2048) {
				attr(input, "placeholder", /*placeholder*/ ctx[11]);
			}

			if (dirty & /*disabled*/ 8192) {
				input.disabled = /*disabled*/ ctx[13];
			}

			if (dirty & /*value*/ 1) {
				set_input_value(input, /*value*/ ctx[0]);
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-danger", /*state*/ ctx[2] === 'invalid');
			}

			if (dirty & /*state*/ 4) {
				toggle_class(input, "uk-form-success", /*state*/ ctx[2] === 'valid');
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[25](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let field;
	let current;

	field = new Field({
			props: {
				inputId: /*id*/ ctx[3],
				requiredMarker: /*requiredMarker*/ ctx[19],
				optionalMarker: /*optionalMarker*/ ctx[20],
				label: /*label*/ ctx[4],
				state: /*state*/ ctx[2],
				className: /*className*/ ctx[6],
				style: /*style*/ ctx[5],
				textIfInvalid: /*textIfInvalid*/ ctx[8],
				textIfValid: /*textIfValid*/ ctx[9],
				helperText: /*helperText*/ ctx[10],
				optional: /*optional*/ ctx[12],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(field.$$.fragment);
		},
		m(target, anchor) {
			mount_component(field, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const field_changes = {};
			if (dirty & /*id*/ 8) field_changes.inputId = /*id*/ ctx[3];
			if (dirty & /*requiredMarker*/ 524288) field_changes.requiredMarker = /*requiredMarker*/ ctx[19];
			if (dirty & /*optionalMarker*/ 1048576) field_changes.optionalMarker = /*optionalMarker*/ ctx[20];
			if (dirty & /*label*/ 16) field_changes.label = /*label*/ ctx[4];
			if (dirty & /*state*/ 4) field_changes.state = /*state*/ ctx[2];
			if (dirty & /*className*/ 64) field_changes.className = /*className*/ ctx[6];
			if (dirty & /*style*/ 32) field_changes.style = /*style*/ ctx[5];
			if (dirty & /*textIfInvalid*/ 256) field_changes.textIfInvalid = /*textIfInvalid*/ ctx[8];
			if (dirty & /*textIfValid*/ 512) field_changes.textIfValid = /*textIfValid*/ ctx[9];
			if (dirty & /*helperText*/ 1024) field_changes.helperText = /*helperText*/ ctx[10];
			if (dirty & /*optional*/ 4096) field_changes.optional = /*optional*/ ctx[12];

			if (dirty & /*$$scope, autocapitalize, autocomplete, autocorrect, spellcheck, id, name, tooltip, optional, placeholder, disabled, ref, value, state*/ 537393295) {
				field_changes.$$scope = { dirty, ctx };
			}

			field.$set(field_changes);
		},
		i(local) {
			if (current) return;
			transition_in(field.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(field.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(field, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { id = generateId() } = $$props;
	let { label = "" } = $$props;
	let { style = undefined } = $$props;
	let { className = undefined } = $$props;
	let { name = undefined } = $$props;
	let { textIfInvalid = undefined } = $$props;
	let { textIfValid = undefined } = $$props;
	let { helperText = undefined } = $$props;
	let { placeholder = "" } = $$props;
	let { optional = false } = $$props;
	let { value } = $$props;
	let { ref = undefined } = $$props;
	let { disabled = false } = $$props;
	let { tooltip = undefined } = $$props;
	let { autocapitalize = undefined } = $$props;
	let { autocomplete = undefined } = $$props;
	let { autocorrect = undefined } = $$props;
	let { spellcheck = undefined } = $$props;
	let { requiredMarker = undefined } = $$props;
	let { optionalMarker = undefined } = $$props;
	let { state = "initial" } = $$props;

	function input_handler(event) {
		bubble.call(this, $$self, event);
	}

	function change_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			ref = $$value;
			$$invalidate(1, ref);
		});
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	const blur_handler_1 = () => $$invalidate(2, state = ref.checkValidity() ? 'valid' : 'invalid');
	const focus_handler_1 = () => $$invalidate(2, state = 'initial');

	$$self.$$set = $$props => {
		if ('id' in $$props) $$invalidate(3, id = $$props.id);
		if ('label' in $$props) $$invalidate(4, label = $$props.label);
		if ('style' in $$props) $$invalidate(5, style = $$props.style);
		if ('className' in $$props) $$invalidate(6, className = $$props.className);
		if ('name' in $$props) $$invalidate(7, name = $$props.name);
		if ('textIfInvalid' in $$props) $$invalidate(8, textIfInvalid = $$props.textIfInvalid);
		if ('textIfValid' in $$props) $$invalidate(9, textIfValid = $$props.textIfValid);
		if ('helperText' in $$props) $$invalidate(10, helperText = $$props.helperText);
		if ('placeholder' in $$props) $$invalidate(11, placeholder = $$props.placeholder);
		if ('optional' in $$props) $$invalidate(12, optional = $$props.optional);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('ref' in $$props) $$invalidate(1, ref = $$props.ref);
		if ('disabled' in $$props) $$invalidate(13, disabled = $$props.disabled);
		if ('tooltip' in $$props) $$invalidate(14, tooltip = $$props.tooltip);
		if ('autocapitalize' in $$props) $$invalidate(15, autocapitalize = $$props.autocapitalize);
		if ('autocomplete' in $$props) $$invalidate(16, autocomplete = $$props.autocomplete);
		if ('autocorrect' in $$props) $$invalidate(17, autocorrect = $$props.autocorrect);
		if ('spellcheck' in $$props) $$invalidate(18, spellcheck = $$props.spellcheck);
		if ('requiredMarker' in $$props) $$invalidate(19, requiredMarker = $$props.requiredMarker);
		if ('optionalMarker' in $$props) $$invalidate(20, optionalMarker = $$props.optionalMarker);
		if ('state' in $$props) $$invalidate(2, state = $$props.state);
	};

	return [
		value,
		ref,
		state,
		id,
		label,
		style,
		className,
		name,
		textIfInvalid,
		textIfValid,
		helperText,
		placeholder,
		optional,
		disabled,
		tooltip,
		autocapitalize,
		autocomplete,
		autocorrect,
		spellcheck,
		requiredMarker,
		optionalMarker,
		input_handler,
		change_handler,
		blur_handler,
		focus_handler,
		input_binding,
		input_input_handler,
		blur_handler_1,
		focus_handler_1
	];
}

class WeekPicker extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			id: 3,
			label: 4,
			style: 5,
			className: 6,
			name: 7,
			textIfInvalid: 8,
			textIfValid: 9,
			helperText: 10,
			placeholder: 11,
			optional: 12,
			value: 0,
			ref: 1,
			disabled: 13,
			tooltip: 14,
			autocapitalize: 15,
			autocomplete: 16,
			autocorrect: 17,
			spellcheck: 18,
			requiredMarker: 19,
			optionalMarker: 20,
			state: 2
		});
	}
}

export { Accordion, AccordionItem, Alert, Article, AsyncAutocomplete, AsyncDataTable, Autocomplete, Badge, Breadcrumb, Button, Card, Checkbox, Comment, DataTable, DatePicker, DescriptionList, Divider, Dropdown, EmailInput, Field, FixedPointInput, Form, FormModal, Loader, LoaderOverlay, LoaderOverlayScoped, LoaderWrapper, Modal, MonthPicker, Nav, NumberInput, Offcanvas, OrderableList, Pagination, PasswordInput, PasswordInputAlt, PercentageInput, Radio, ScrollableNav, SearchInput, Select, Switcher, Tab, Table, TelInput, TextInput, Textarea, TimePicker, WeekPicker, generateId, globalOptionalMarker, globalRequiredMarker };
